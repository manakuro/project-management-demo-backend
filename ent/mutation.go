// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"project-management-demo-backend/ent/activitytype"
	"project-management-demo-backend/ent/archivedtaskactivity"
	"project-management-demo-backend/ent/archivedtaskactivitytask"
	"project-management-demo-backend/ent/archivedworkspaceactivity"
	"project-management-demo-backend/ent/archivedworkspaceactivitytask"
	"project-management-demo-backend/ent/color"
	"project-management-demo-backend/ent/deletedtask"
	"project-management-demo-backend/ent/favoriteproject"
	"project-management-demo-backend/ent/favoriteworkspace"
	"project-management-demo-backend/ent/filetype"
	"project-management-demo-backend/ent/icon"
	"project-management-demo-backend/ent/predicate"
	"project-management-demo-backend/ent/project"
	"project-management-demo-backend/ent/projectbasecolor"
	"project-management-demo-backend/ent/projecticon"
	"project-management-demo-backend/ent/projectlightcolor"
	"project-management-demo-backend/ent/projecttask"
	"project-management-demo-backend/ent/projecttaskcolumn"
	"project-management-demo-backend/ent/projecttaskliststatus"
	"project-management-demo-backend/ent/projecttasksection"
	"project-management-demo-backend/ent/projectteammate"
	"project-management-demo-backend/ent/schema/testuserprofile"
	"project-management-demo-backend/ent/schema/ulid"
	"project-management-demo-backend/ent/tag"
	"project-management-demo-backend/ent/task"
	"project-management-demo-backend/ent/taskactivity"
	"project-management-demo-backend/ent/taskactivitytask"
	"project-management-demo-backend/ent/taskcollaborator"
	"project-management-demo-backend/ent/taskcolumn"
	"project-management-demo-backend/ent/taskfeed"
	"project-management-demo-backend/ent/taskfeedlike"
	"project-management-demo-backend/ent/taskfile"
	"project-management-demo-backend/ent/tasklike"
	"project-management-demo-backend/ent/tasklistcompletedstatus"
	"project-management-demo-backend/ent/tasklistsortstatus"
	"project-management-demo-backend/ent/taskpriority"
	"project-management-demo-backend/ent/tasksection"
	"project-management-demo-backend/ent/tasktag"
	"project-management-demo-backend/ent/teammate"
	"project-management-demo-backend/ent/teammatetask"
	"project-management-demo-backend/ent/teammatetaskcolumn"
	"project-management-demo-backend/ent/teammatetaskliststatus"
	"project-management-demo-backend/ent/teammatetasksection"
	"project-management-demo-backend/ent/teammatetasktabstatus"
	"project-management-demo-backend/ent/testtodo"
	"project-management-demo-backend/ent/testuser"
	"project-management-demo-backend/ent/workspace"
	"project-management-demo-backend/ent/workspaceactivity"
	"project-management-demo-backend/ent/workspaceactivitytask"
	"project-management-demo-backend/ent/workspaceteammate"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeActivityType                  = "ActivityType"
	TypeArchivedTaskActivity          = "ArchivedTaskActivity"
	TypeArchivedTaskActivityTask      = "ArchivedTaskActivityTask"
	TypeArchivedWorkspaceActivity     = "ArchivedWorkspaceActivity"
	TypeArchivedWorkspaceActivityTask = "ArchivedWorkspaceActivityTask"
	TypeColor                         = "Color"
	TypeDeletedTask                   = "DeletedTask"
	TypeFavoriteProject               = "FavoriteProject"
	TypeFavoriteWorkspace             = "FavoriteWorkspace"
	TypeFileType                      = "FileType"
	TypeIcon                          = "Icon"
	TypeProject                       = "Project"
	TypeProjectBaseColor              = "ProjectBaseColor"
	TypeProjectIcon                   = "ProjectIcon"
	TypeProjectLightColor             = "ProjectLightColor"
	TypeProjectTask                   = "ProjectTask"
	TypeProjectTaskColumn             = "ProjectTaskColumn"
	TypeProjectTaskListStatus         = "ProjectTaskListStatus"
	TypeProjectTaskSection            = "ProjectTaskSection"
	TypeProjectTeammate               = "ProjectTeammate"
	TypeTag                           = "Tag"
	TypeTask                          = "Task"
	TypeTaskActivity                  = "TaskActivity"
	TypeTaskActivityTask              = "TaskActivityTask"
	TypeTaskCollaborator              = "TaskCollaborator"
	TypeTaskColumn                    = "TaskColumn"
	TypeTaskFeed                      = "TaskFeed"
	TypeTaskFeedLike                  = "TaskFeedLike"
	TypeTaskFile                      = "TaskFile"
	TypeTaskLike                      = "TaskLike"
	TypeTaskListCompletedStatus       = "TaskListCompletedStatus"
	TypeTaskListSortStatus            = "TaskListSortStatus"
	TypeTaskPriority                  = "TaskPriority"
	TypeTaskSection                   = "TaskSection"
	TypeTaskTag                       = "TaskTag"
	TypeTeammate                      = "Teammate"
	TypeTeammateTask                  = "TeammateTask"
	TypeTeammateTaskColumn            = "TeammateTaskColumn"
	TypeTeammateTaskListStatus        = "TeammateTaskListStatus"
	TypeTeammateTaskSection           = "TeammateTaskSection"
	TypeTeammateTaskTabStatus         = "TeammateTaskTabStatus"
	TypeTestTodo                      = "TestTodo"
	TypeTestUser                      = "TestUser"
	TypeWorkspace                     = "Workspace"
	TypeWorkspaceActivity             = "WorkspaceActivity"
	TypeWorkspaceActivityTask         = "WorkspaceActivityTask"
	TypeWorkspaceTeammate             = "WorkspaceTeammate"
)

// ActivityTypeMutation represents an operation that mutates the ActivityType nodes in the graph.
type ActivityTypeMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *ulid.ID
	name                               *string
	type_code                          *activitytype.TypeCode
	created_at                         *time.Time
	updated_at                         *time.Time
	clearedFields                      map[string]struct{}
	taskActivities                     map[ulid.ID]struct{}
	removedtaskActivities              map[ulid.ID]struct{}
	clearedtaskActivities              bool
	workspaceActivities                map[ulid.ID]struct{}
	removedworkspaceActivities         map[ulid.ID]struct{}
	clearedworkspaceActivities         bool
	archivedTaskActivities             map[ulid.ID]struct{}
	removedarchivedTaskActivities      map[ulid.ID]struct{}
	clearedarchivedTaskActivities      bool
	archivedWorkspaceActivities        map[ulid.ID]struct{}
	removedarchivedWorkspaceActivities map[ulid.ID]struct{}
	clearedarchivedWorkspaceActivities bool
	done                               bool
	oldValue                           func(context.Context) (*ActivityType, error)
	predicates                         []predicate.ActivityType
}

var _ ent.Mutation = (*ActivityTypeMutation)(nil)

// activitytypeOption allows management of the mutation configuration using functional options.
type activitytypeOption func(*ActivityTypeMutation)

// newActivityTypeMutation creates new mutation for the ActivityType entity.
func newActivityTypeMutation(c config, op Op, opts ...activitytypeOption) *ActivityTypeMutation {
	m := &ActivityTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeActivityType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityTypeID sets the ID field of the mutation.
func withActivityTypeID(id ulid.ID) activitytypeOption {
	return func(m *ActivityTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ActivityType
		)
		m.oldValue = func(ctx context.Context) (*ActivityType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActivityType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivityType sets the old ActivityType of the mutation.
func withActivityType(node *ActivityType) activitytypeOption {
	return func(m *ActivityTypeMutation) {
		m.oldValue = func(context.Context) (*ActivityType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ActivityType entities.
func (m *ActivityTypeMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActivityTypeMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActivityTypeMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActivityType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ActivityTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ActivityTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ActivityType entity.
// If the ActivityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ActivityTypeMutation) ResetName() {
	m.name = nil
}

// SetTypeCode sets the "type_code" field.
func (m *ActivityTypeMutation) SetTypeCode(ac activitytype.TypeCode) {
	m.type_code = &ac
}

// TypeCode returns the value of the "type_code" field in the mutation.
func (m *ActivityTypeMutation) TypeCode() (r activitytype.TypeCode, exists bool) {
	v := m.type_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeCode returns the old "type_code" field's value of the ActivityType entity.
// If the ActivityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityTypeMutation) OldTypeCode(ctx context.Context) (v activitytype.TypeCode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeCode: %w", err)
	}
	return oldValue.TypeCode, nil
}

// ResetTypeCode resets all changes to the "type_code" field.
func (m *ActivityTypeMutation) ResetTypeCode() {
	m.type_code = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ActivityTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ActivityTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ActivityType entity.
// If the ActivityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ActivityTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ActivityTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ActivityTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ActivityType entity.
// If the ActivityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ActivityTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddTaskActivityIDs adds the "taskActivities" edge to the TaskActivity entity by ids.
func (m *ActivityTypeMutation) AddTaskActivityIDs(ids ...ulid.ID) {
	if m.taskActivities == nil {
		m.taskActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.taskActivities[ids[i]] = struct{}{}
	}
}

// ClearTaskActivities clears the "taskActivities" edge to the TaskActivity entity.
func (m *ActivityTypeMutation) ClearTaskActivities() {
	m.clearedtaskActivities = true
}

// TaskActivitiesCleared reports if the "taskActivities" edge to the TaskActivity entity was cleared.
func (m *ActivityTypeMutation) TaskActivitiesCleared() bool {
	return m.clearedtaskActivities
}

// RemoveTaskActivityIDs removes the "taskActivities" edge to the TaskActivity entity by IDs.
func (m *ActivityTypeMutation) RemoveTaskActivityIDs(ids ...ulid.ID) {
	if m.removedtaskActivities == nil {
		m.removedtaskActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.taskActivities, ids[i])
		m.removedtaskActivities[ids[i]] = struct{}{}
	}
}

// RemovedTaskActivities returns the removed IDs of the "taskActivities" edge to the TaskActivity entity.
func (m *ActivityTypeMutation) RemovedTaskActivitiesIDs() (ids []ulid.ID) {
	for id := range m.removedtaskActivities {
		ids = append(ids, id)
	}
	return
}

// TaskActivitiesIDs returns the "taskActivities" edge IDs in the mutation.
func (m *ActivityTypeMutation) TaskActivitiesIDs() (ids []ulid.ID) {
	for id := range m.taskActivities {
		ids = append(ids, id)
	}
	return
}

// ResetTaskActivities resets all changes to the "taskActivities" edge.
func (m *ActivityTypeMutation) ResetTaskActivities() {
	m.taskActivities = nil
	m.clearedtaskActivities = false
	m.removedtaskActivities = nil
}

// AddWorkspaceActivityIDs adds the "workspaceActivities" edge to the WorkspaceActivity entity by ids.
func (m *ActivityTypeMutation) AddWorkspaceActivityIDs(ids ...ulid.ID) {
	if m.workspaceActivities == nil {
		m.workspaceActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.workspaceActivities[ids[i]] = struct{}{}
	}
}

// ClearWorkspaceActivities clears the "workspaceActivities" edge to the WorkspaceActivity entity.
func (m *ActivityTypeMutation) ClearWorkspaceActivities() {
	m.clearedworkspaceActivities = true
}

// WorkspaceActivitiesCleared reports if the "workspaceActivities" edge to the WorkspaceActivity entity was cleared.
func (m *ActivityTypeMutation) WorkspaceActivitiesCleared() bool {
	return m.clearedworkspaceActivities
}

// RemoveWorkspaceActivityIDs removes the "workspaceActivities" edge to the WorkspaceActivity entity by IDs.
func (m *ActivityTypeMutation) RemoveWorkspaceActivityIDs(ids ...ulid.ID) {
	if m.removedworkspaceActivities == nil {
		m.removedworkspaceActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.workspaceActivities, ids[i])
		m.removedworkspaceActivities[ids[i]] = struct{}{}
	}
}

// RemovedWorkspaceActivities returns the removed IDs of the "workspaceActivities" edge to the WorkspaceActivity entity.
func (m *ActivityTypeMutation) RemovedWorkspaceActivitiesIDs() (ids []ulid.ID) {
	for id := range m.removedworkspaceActivities {
		ids = append(ids, id)
	}
	return
}

// WorkspaceActivitiesIDs returns the "workspaceActivities" edge IDs in the mutation.
func (m *ActivityTypeMutation) WorkspaceActivitiesIDs() (ids []ulid.ID) {
	for id := range m.workspaceActivities {
		ids = append(ids, id)
	}
	return
}

// ResetWorkspaceActivities resets all changes to the "workspaceActivities" edge.
func (m *ActivityTypeMutation) ResetWorkspaceActivities() {
	m.workspaceActivities = nil
	m.clearedworkspaceActivities = false
	m.removedworkspaceActivities = nil
}

// AddArchivedTaskActivityIDs adds the "archivedTaskActivities" edge to the ArchivedTaskActivity entity by ids.
func (m *ActivityTypeMutation) AddArchivedTaskActivityIDs(ids ...ulid.ID) {
	if m.archivedTaskActivities == nil {
		m.archivedTaskActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.archivedTaskActivities[ids[i]] = struct{}{}
	}
}

// ClearArchivedTaskActivities clears the "archivedTaskActivities" edge to the ArchivedTaskActivity entity.
func (m *ActivityTypeMutation) ClearArchivedTaskActivities() {
	m.clearedarchivedTaskActivities = true
}

// ArchivedTaskActivitiesCleared reports if the "archivedTaskActivities" edge to the ArchivedTaskActivity entity was cleared.
func (m *ActivityTypeMutation) ArchivedTaskActivitiesCleared() bool {
	return m.clearedarchivedTaskActivities
}

// RemoveArchivedTaskActivityIDs removes the "archivedTaskActivities" edge to the ArchivedTaskActivity entity by IDs.
func (m *ActivityTypeMutation) RemoveArchivedTaskActivityIDs(ids ...ulid.ID) {
	if m.removedarchivedTaskActivities == nil {
		m.removedarchivedTaskActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.archivedTaskActivities, ids[i])
		m.removedarchivedTaskActivities[ids[i]] = struct{}{}
	}
}

// RemovedArchivedTaskActivities returns the removed IDs of the "archivedTaskActivities" edge to the ArchivedTaskActivity entity.
func (m *ActivityTypeMutation) RemovedArchivedTaskActivitiesIDs() (ids []ulid.ID) {
	for id := range m.removedarchivedTaskActivities {
		ids = append(ids, id)
	}
	return
}

// ArchivedTaskActivitiesIDs returns the "archivedTaskActivities" edge IDs in the mutation.
func (m *ActivityTypeMutation) ArchivedTaskActivitiesIDs() (ids []ulid.ID) {
	for id := range m.archivedTaskActivities {
		ids = append(ids, id)
	}
	return
}

// ResetArchivedTaskActivities resets all changes to the "archivedTaskActivities" edge.
func (m *ActivityTypeMutation) ResetArchivedTaskActivities() {
	m.archivedTaskActivities = nil
	m.clearedarchivedTaskActivities = false
	m.removedarchivedTaskActivities = nil
}

// AddArchivedWorkspaceActivityIDs adds the "archivedWorkspaceActivities" edge to the ArchivedWorkspaceActivity entity by ids.
func (m *ActivityTypeMutation) AddArchivedWorkspaceActivityIDs(ids ...ulid.ID) {
	if m.archivedWorkspaceActivities == nil {
		m.archivedWorkspaceActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.archivedWorkspaceActivities[ids[i]] = struct{}{}
	}
}

// ClearArchivedWorkspaceActivities clears the "archivedWorkspaceActivities" edge to the ArchivedWorkspaceActivity entity.
func (m *ActivityTypeMutation) ClearArchivedWorkspaceActivities() {
	m.clearedarchivedWorkspaceActivities = true
}

// ArchivedWorkspaceActivitiesCleared reports if the "archivedWorkspaceActivities" edge to the ArchivedWorkspaceActivity entity was cleared.
func (m *ActivityTypeMutation) ArchivedWorkspaceActivitiesCleared() bool {
	return m.clearedarchivedWorkspaceActivities
}

// RemoveArchivedWorkspaceActivityIDs removes the "archivedWorkspaceActivities" edge to the ArchivedWorkspaceActivity entity by IDs.
func (m *ActivityTypeMutation) RemoveArchivedWorkspaceActivityIDs(ids ...ulid.ID) {
	if m.removedarchivedWorkspaceActivities == nil {
		m.removedarchivedWorkspaceActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.archivedWorkspaceActivities, ids[i])
		m.removedarchivedWorkspaceActivities[ids[i]] = struct{}{}
	}
}

// RemovedArchivedWorkspaceActivities returns the removed IDs of the "archivedWorkspaceActivities" edge to the ArchivedWorkspaceActivity entity.
func (m *ActivityTypeMutation) RemovedArchivedWorkspaceActivitiesIDs() (ids []ulid.ID) {
	for id := range m.removedarchivedWorkspaceActivities {
		ids = append(ids, id)
	}
	return
}

// ArchivedWorkspaceActivitiesIDs returns the "archivedWorkspaceActivities" edge IDs in the mutation.
func (m *ActivityTypeMutation) ArchivedWorkspaceActivitiesIDs() (ids []ulid.ID) {
	for id := range m.archivedWorkspaceActivities {
		ids = append(ids, id)
	}
	return
}

// ResetArchivedWorkspaceActivities resets all changes to the "archivedWorkspaceActivities" edge.
func (m *ActivityTypeMutation) ResetArchivedWorkspaceActivities() {
	m.archivedWorkspaceActivities = nil
	m.clearedarchivedWorkspaceActivities = false
	m.removedarchivedWorkspaceActivities = nil
}

// Where appends a list predicates to the ActivityTypeMutation builder.
func (m *ActivityTypeMutation) Where(ps ...predicate.ActivityType) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ActivityTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ActivityType).
func (m *ActivityTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, activitytype.FieldName)
	}
	if m.type_code != nil {
		fields = append(fields, activitytype.FieldTypeCode)
	}
	if m.created_at != nil {
		fields = append(fields, activitytype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, activitytype.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activitytype.FieldName:
		return m.Name()
	case activitytype.FieldTypeCode:
		return m.TypeCode()
	case activitytype.FieldCreatedAt:
		return m.CreatedAt()
	case activitytype.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activitytype.FieldName:
		return m.OldName(ctx)
	case activitytype.FieldTypeCode:
		return m.OldTypeCode(ctx)
	case activitytype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case activitytype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ActivityType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activitytype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case activitytype.FieldTypeCode:
		v, ok := value.(activitytype.TypeCode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeCode(v)
		return nil
	case activitytype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case activitytype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ActivityType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ActivityType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityTypeMutation) ResetField(name string) error {
	switch name {
	case activitytype.FieldName:
		m.ResetName()
		return nil
	case activitytype.FieldTypeCode:
		m.ResetTypeCode()
		return nil
	case activitytype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case activitytype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ActivityType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.taskActivities != nil {
		edges = append(edges, activitytype.EdgeTaskActivities)
	}
	if m.workspaceActivities != nil {
		edges = append(edges, activitytype.EdgeWorkspaceActivities)
	}
	if m.archivedTaskActivities != nil {
		edges = append(edges, activitytype.EdgeArchivedTaskActivities)
	}
	if m.archivedWorkspaceActivities != nil {
		edges = append(edges, activitytype.EdgeArchivedWorkspaceActivities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activitytype.EdgeTaskActivities:
		ids := make([]ent.Value, 0, len(m.taskActivities))
		for id := range m.taskActivities {
			ids = append(ids, id)
		}
		return ids
	case activitytype.EdgeWorkspaceActivities:
		ids := make([]ent.Value, 0, len(m.workspaceActivities))
		for id := range m.workspaceActivities {
			ids = append(ids, id)
		}
		return ids
	case activitytype.EdgeArchivedTaskActivities:
		ids := make([]ent.Value, 0, len(m.archivedTaskActivities))
		for id := range m.archivedTaskActivities {
			ids = append(ids, id)
		}
		return ids
	case activitytype.EdgeArchivedWorkspaceActivities:
		ids := make([]ent.Value, 0, len(m.archivedWorkspaceActivities))
		for id := range m.archivedWorkspaceActivities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtaskActivities != nil {
		edges = append(edges, activitytype.EdgeTaskActivities)
	}
	if m.removedworkspaceActivities != nil {
		edges = append(edges, activitytype.EdgeWorkspaceActivities)
	}
	if m.removedarchivedTaskActivities != nil {
		edges = append(edges, activitytype.EdgeArchivedTaskActivities)
	}
	if m.removedarchivedWorkspaceActivities != nil {
		edges = append(edges, activitytype.EdgeArchivedWorkspaceActivities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case activitytype.EdgeTaskActivities:
		ids := make([]ent.Value, 0, len(m.removedtaskActivities))
		for id := range m.removedtaskActivities {
			ids = append(ids, id)
		}
		return ids
	case activitytype.EdgeWorkspaceActivities:
		ids := make([]ent.Value, 0, len(m.removedworkspaceActivities))
		for id := range m.removedworkspaceActivities {
			ids = append(ids, id)
		}
		return ids
	case activitytype.EdgeArchivedTaskActivities:
		ids := make([]ent.Value, 0, len(m.removedarchivedTaskActivities))
		for id := range m.removedarchivedTaskActivities {
			ids = append(ids, id)
		}
		return ids
	case activitytype.EdgeArchivedWorkspaceActivities:
		ids := make([]ent.Value, 0, len(m.removedarchivedWorkspaceActivities))
		for id := range m.removedarchivedWorkspaceActivities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtaskActivities {
		edges = append(edges, activitytype.EdgeTaskActivities)
	}
	if m.clearedworkspaceActivities {
		edges = append(edges, activitytype.EdgeWorkspaceActivities)
	}
	if m.clearedarchivedTaskActivities {
		edges = append(edges, activitytype.EdgeArchivedTaskActivities)
	}
	if m.clearedarchivedWorkspaceActivities {
		edges = append(edges, activitytype.EdgeArchivedWorkspaceActivities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case activitytype.EdgeTaskActivities:
		return m.clearedtaskActivities
	case activitytype.EdgeWorkspaceActivities:
		return m.clearedworkspaceActivities
	case activitytype.EdgeArchivedTaskActivities:
		return m.clearedarchivedTaskActivities
	case activitytype.EdgeArchivedWorkspaceActivities:
		return m.clearedarchivedWorkspaceActivities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ActivityType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityTypeMutation) ResetEdge(name string) error {
	switch name {
	case activitytype.EdgeTaskActivities:
		m.ResetTaskActivities()
		return nil
	case activitytype.EdgeWorkspaceActivities:
		m.ResetWorkspaceActivities()
		return nil
	case activitytype.EdgeArchivedTaskActivities:
		m.ResetArchivedTaskActivities()
		return nil
	case activitytype.EdgeArchivedWorkspaceActivities:
		m.ResetArchivedWorkspaceActivities()
		return nil
	}
	return fmt.Errorf("unknown ActivityType edge %s", name)
}

// ArchivedTaskActivityMutation represents an operation that mutates the ArchivedTaskActivity nodes in the graph.
type ArchivedTaskActivityMutation struct {
	config
	op                               Op
	typ                              string
	id                               *ulid.ID
	created_at                       *time.Time
	updated_at                       *time.Time
	clearedFields                    map[string]struct{}
	teammate                         *ulid.ID
	clearedteammate                  bool
	activityType                     *ulid.ID
	clearedactivityType              bool
	workspace                        *ulid.ID
	clearedworkspace                 bool
	archivedTaskActivityTasks        map[ulid.ID]struct{}
	removedarchivedTaskActivityTasks map[ulid.ID]struct{}
	clearedarchivedTaskActivityTasks bool
	done                             bool
	oldValue                         func(context.Context) (*ArchivedTaskActivity, error)
	predicates                       []predicate.ArchivedTaskActivity
}

var _ ent.Mutation = (*ArchivedTaskActivityMutation)(nil)

// archivedtaskactivityOption allows management of the mutation configuration using functional options.
type archivedtaskactivityOption func(*ArchivedTaskActivityMutation)

// newArchivedTaskActivityMutation creates new mutation for the ArchivedTaskActivity entity.
func newArchivedTaskActivityMutation(c config, op Op, opts ...archivedtaskactivityOption) *ArchivedTaskActivityMutation {
	m := &ArchivedTaskActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeArchivedTaskActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArchivedTaskActivityID sets the ID field of the mutation.
func withArchivedTaskActivityID(id ulid.ID) archivedtaskactivityOption {
	return func(m *ArchivedTaskActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *ArchivedTaskActivity
		)
		m.oldValue = func(ctx context.Context) (*ArchivedTaskActivity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ArchivedTaskActivity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArchivedTaskActivity sets the old ArchivedTaskActivity of the mutation.
func withArchivedTaskActivity(node *ArchivedTaskActivity) archivedtaskactivityOption {
	return func(m *ArchivedTaskActivityMutation) {
		m.oldValue = func(context.Context) (*ArchivedTaskActivity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArchivedTaskActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArchivedTaskActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ArchivedTaskActivity entities.
func (m *ArchivedTaskActivityMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArchivedTaskActivityMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArchivedTaskActivityMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ArchivedTaskActivity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetActivityTypeID sets the "activity_type_id" field.
func (m *ArchivedTaskActivityMutation) SetActivityTypeID(u ulid.ID) {
	m.activityType = &u
}

// ActivityTypeID returns the value of the "activity_type_id" field in the mutation.
func (m *ArchivedTaskActivityMutation) ActivityTypeID() (r ulid.ID, exists bool) {
	v := m.activityType
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityTypeID returns the old "activity_type_id" field's value of the ArchivedTaskActivity entity.
// If the ArchivedTaskActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivedTaskActivityMutation) OldActivityTypeID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivityTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivityTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityTypeID: %w", err)
	}
	return oldValue.ActivityTypeID, nil
}

// ResetActivityTypeID resets all changes to the "activity_type_id" field.
func (m *ArchivedTaskActivityMutation) ResetActivityTypeID() {
	m.activityType = nil
}

// SetTeammateID sets the "teammate_id" field.
func (m *ArchivedTaskActivityMutation) SetTeammateID(u ulid.ID) {
	m.teammate = &u
}

// TeammateID returns the value of the "teammate_id" field in the mutation.
func (m *ArchivedTaskActivityMutation) TeammateID() (r ulid.ID, exists bool) {
	v := m.teammate
	if v == nil {
		return
	}
	return *v, true
}

// OldTeammateID returns the old "teammate_id" field's value of the ArchivedTaskActivity entity.
// If the ArchivedTaskActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivedTaskActivityMutation) OldTeammateID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeammateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeammateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeammateID: %w", err)
	}
	return oldValue.TeammateID, nil
}

// ResetTeammateID resets all changes to the "teammate_id" field.
func (m *ArchivedTaskActivityMutation) ResetTeammateID() {
	m.teammate = nil
}

// SetWorkspaceID sets the "workspace_id" field.
func (m *ArchivedTaskActivityMutation) SetWorkspaceID(u ulid.ID) {
	m.workspace = &u
}

// WorkspaceID returns the value of the "workspace_id" field in the mutation.
func (m *ArchivedTaskActivityMutation) WorkspaceID() (r ulid.ID, exists bool) {
	v := m.workspace
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspaceID returns the old "workspace_id" field's value of the ArchivedTaskActivity entity.
// If the ArchivedTaskActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivedTaskActivityMutation) OldWorkspaceID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspaceID: %w", err)
	}
	return oldValue.WorkspaceID, nil
}

// ResetWorkspaceID resets all changes to the "workspace_id" field.
func (m *ArchivedTaskActivityMutation) ResetWorkspaceID() {
	m.workspace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ArchivedTaskActivityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArchivedTaskActivityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ArchivedTaskActivity entity.
// If the ArchivedTaskActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivedTaskActivityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArchivedTaskActivityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArchivedTaskActivityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArchivedTaskActivityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ArchivedTaskActivity entity.
// If the ArchivedTaskActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivedTaskActivityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArchivedTaskActivityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTeammate clears the "teammate" edge to the Teammate entity.
func (m *ArchivedTaskActivityMutation) ClearTeammate() {
	m.clearedteammate = true
}

// TeammateCleared reports if the "teammate" edge to the Teammate entity was cleared.
func (m *ArchivedTaskActivityMutation) TeammateCleared() bool {
	return m.clearedteammate
}

// TeammateIDs returns the "teammate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeammateID instead. It exists only for internal usage by the builders.
func (m *ArchivedTaskActivityMutation) TeammateIDs() (ids []ulid.ID) {
	if id := m.teammate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeammate resets all changes to the "teammate" edge.
func (m *ArchivedTaskActivityMutation) ResetTeammate() {
	m.teammate = nil
	m.clearedteammate = false
}

// ClearActivityType clears the "activityType" edge to the ActivityType entity.
func (m *ArchivedTaskActivityMutation) ClearActivityType() {
	m.clearedactivityType = true
}

// ActivityTypeCleared reports if the "activityType" edge to the ActivityType entity was cleared.
func (m *ArchivedTaskActivityMutation) ActivityTypeCleared() bool {
	return m.clearedactivityType
}

// ActivityTypeIDs returns the "activityType" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActivityTypeID instead. It exists only for internal usage by the builders.
func (m *ArchivedTaskActivityMutation) ActivityTypeIDs() (ids []ulid.ID) {
	if id := m.activityType; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivityType resets all changes to the "activityType" edge.
func (m *ArchivedTaskActivityMutation) ResetActivityType() {
	m.activityType = nil
	m.clearedactivityType = false
}

// ClearWorkspace clears the "workspace" edge to the Workspace entity.
func (m *ArchivedTaskActivityMutation) ClearWorkspace() {
	m.clearedworkspace = true
}

// WorkspaceCleared reports if the "workspace" edge to the Workspace entity was cleared.
func (m *ArchivedTaskActivityMutation) WorkspaceCleared() bool {
	return m.clearedworkspace
}

// WorkspaceIDs returns the "workspace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkspaceID instead. It exists only for internal usage by the builders.
func (m *ArchivedTaskActivityMutation) WorkspaceIDs() (ids []ulid.ID) {
	if id := m.workspace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkspace resets all changes to the "workspace" edge.
func (m *ArchivedTaskActivityMutation) ResetWorkspace() {
	m.workspace = nil
	m.clearedworkspace = false
}

// AddArchivedTaskActivityTaskIDs adds the "archivedTaskActivityTasks" edge to the ArchivedTaskActivityTask entity by ids.
func (m *ArchivedTaskActivityMutation) AddArchivedTaskActivityTaskIDs(ids ...ulid.ID) {
	if m.archivedTaskActivityTasks == nil {
		m.archivedTaskActivityTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.archivedTaskActivityTasks[ids[i]] = struct{}{}
	}
}

// ClearArchivedTaskActivityTasks clears the "archivedTaskActivityTasks" edge to the ArchivedTaskActivityTask entity.
func (m *ArchivedTaskActivityMutation) ClearArchivedTaskActivityTasks() {
	m.clearedarchivedTaskActivityTasks = true
}

// ArchivedTaskActivityTasksCleared reports if the "archivedTaskActivityTasks" edge to the ArchivedTaskActivityTask entity was cleared.
func (m *ArchivedTaskActivityMutation) ArchivedTaskActivityTasksCleared() bool {
	return m.clearedarchivedTaskActivityTasks
}

// RemoveArchivedTaskActivityTaskIDs removes the "archivedTaskActivityTasks" edge to the ArchivedTaskActivityTask entity by IDs.
func (m *ArchivedTaskActivityMutation) RemoveArchivedTaskActivityTaskIDs(ids ...ulid.ID) {
	if m.removedarchivedTaskActivityTasks == nil {
		m.removedarchivedTaskActivityTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.archivedTaskActivityTasks, ids[i])
		m.removedarchivedTaskActivityTasks[ids[i]] = struct{}{}
	}
}

// RemovedArchivedTaskActivityTasks returns the removed IDs of the "archivedTaskActivityTasks" edge to the ArchivedTaskActivityTask entity.
func (m *ArchivedTaskActivityMutation) RemovedArchivedTaskActivityTasksIDs() (ids []ulid.ID) {
	for id := range m.removedarchivedTaskActivityTasks {
		ids = append(ids, id)
	}
	return
}

// ArchivedTaskActivityTasksIDs returns the "archivedTaskActivityTasks" edge IDs in the mutation.
func (m *ArchivedTaskActivityMutation) ArchivedTaskActivityTasksIDs() (ids []ulid.ID) {
	for id := range m.archivedTaskActivityTasks {
		ids = append(ids, id)
	}
	return
}

// ResetArchivedTaskActivityTasks resets all changes to the "archivedTaskActivityTasks" edge.
func (m *ArchivedTaskActivityMutation) ResetArchivedTaskActivityTasks() {
	m.archivedTaskActivityTasks = nil
	m.clearedarchivedTaskActivityTasks = false
	m.removedarchivedTaskActivityTasks = nil
}

// Where appends a list predicates to the ArchivedTaskActivityMutation builder.
func (m *ArchivedTaskActivityMutation) Where(ps ...predicate.ArchivedTaskActivity) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ArchivedTaskActivityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ArchivedTaskActivity).
func (m *ArchivedTaskActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArchivedTaskActivityMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.activityType != nil {
		fields = append(fields, archivedtaskactivity.FieldActivityTypeID)
	}
	if m.teammate != nil {
		fields = append(fields, archivedtaskactivity.FieldTeammateID)
	}
	if m.workspace != nil {
		fields = append(fields, archivedtaskactivity.FieldWorkspaceID)
	}
	if m.created_at != nil {
		fields = append(fields, archivedtaskactivity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, archivedtaskactivity.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArchivedTaskActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case archivedtaskactivity.FieldActivityTypeID:
		return m.ActivityTypeID()
	case archivedtaskactivity.FieldTeammateID:
		return m.TeammateID()
	case archivedtaskactivity.FieldWorkspaceID:
		return m.WorkspaceID()
	case archivedtaskactivity.FieldCreatedAt:
		return m.CreatedAt()
	case archivedtaskactivity.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArchivedTaskActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case archivedtaskactivity.FieldActivityTypeID:
		return m.OldActivityTypeID(ctx)
	case archivedtaskactivity.FieldTeammateID:
		return m.OldTeammateID(ctx)
	case archivedtaskactivity.FieldWorkspaceID:
		return m.OldWorkspaceID(ctx)
	case archivedtaskactivity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case archivedtaskactivity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ArchivedTaskActivity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArchivedTaskActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case archivedtaskactivity.FieldActivityTypeID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityTypeID(v)
		return nil
	case archivedtaskactivity.FieldTeammateID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeammateID(v)
		return nil
	case archivedtaskactivity.FieldWorkspaceID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspaceID(v)
		return nil
	case archivedtaskactivity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case archivedtaskactivity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ArchivedTaskActivity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArchivedTaskActivityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArchivedTaskActivityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArchivedTaskActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ArchivedTaskActivity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArchivedTaskActivityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArchivedTaskActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArchivedTaskActivityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ArchivedTaskActivity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArchivedTaskActivityMutation) ResetField(name string) error {
	switch name {
	case archivedtaskactivity.FieldActivityTypeID:
		m.ResetActivityTypeID()
		return nil
	case archivedtaskactivity.FieldTeammateID:
		m.ResetTeammateID()
		return nil
	case archivedtaskactivity.FieldWorkspaceID:
		m.ResetWorkspaceID()
		return nil
	case archivedtaskactivity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case archivedtaskactivity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ArchivedTaskActivity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArchivedTaskActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.teammate != nil {
		edges = append(edges, archivedtaskactivity.EdgeTeammate)
	}
	if m.activityType != nil {
		edges = append(edges, archivedtaskactivity.EdgeActivityType)
	}
	if m.workspace != nil {
		edges = append(edges, archivedtaskactivity.EdgeWorkspace)
	}
	if m.archivedTaskActivityTasks != nil {
		edges = append(edges, archivedtaskactivity.EdgeArchivedTaskActivityTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArchivedTaskActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case archivedtaskactivity.EdgeTeammate:
		if id := m.teammate; id != nil {
			return []ent.Value{*id}
		}
	case archivedtaskactivity.EdgeActivityType:
		if id := m.activityType; id != nil {
			return []ent.Value{*id}
		}
	case archivedtaskactivity.EdgeWorkspace:
		if id := m.workspace; id != nil {
			return []ent.Value{*id}
		}
	case archivedtaskactivity.EdgeArchivedTaskActivityTasks:
		ids := make([]ent.Value, 0, len(m.archivedTaskActivityTasks))
		for id := range m.archivedTaskActivityTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArchivedTaskActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedarchivedTaskActivityTasks != nil {
		edges = append(edges, archivedtaskactivity.EdgeArchivedTaskActivityTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArchivedTaskActivityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case archivedtaskactivity.EdgeArchivedTaskActivityTasks:
		ids := make([]ent.Value, 0, len(m.removedarchivedTaskActivityTasks))
		for id := range m.removedarchivedTaskActivityTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArchivedTaskActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedteammate {
		edges = append(edges, archivedtaskactivity.EdgeTeammate)
	}
	if m.clearedactivityType {
		edges = append(edges, archivedtaskactivity.EdgeActivityType)
	}
	if m.clearedworkspace {
		edges = append(edges, archivedtaskactivity.EdgeWorkspace)
	}
	if m.clearedarchivedTaskActivityTasks {
		edges = append(edges, archivedtaskactivity.EdgeArchivedTaskActivityTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArchivedTaskActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case archivedtaskactivity.EdgeTeammate:
		return m.clearedteammate
	case archivedtaskactivity.EdgeActivityType:
		return m.clearedactivityType
	case archivedtaskactivity.EdgeWorkspace:
		return m.clearedworkspace
	case archivedtaskactivity.EdgeArchivedTaskActivityTasks:
		return m.clearedarchivedTaskActivityTasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArchivedTaskActivityMutation) ClearEdge(name string) error {
	switch name {
	case archivedtaskactivity.EdgeTeammate:
		m.ClearTeammate()
		return nil
	case archivedtaskactivity.EdgeActivityType:
		m.ClearActivityType()
		return nil
	case archivedtaskactivity.EdgeWorkspace:
		m.ClearWorkspace()
		return nil
	}
	return fmt.Errorf("unknown ArchivedTaskActivity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArchivedTaskActivityMutation) ResetEdge(name string) error {
	switch name {
	case archivedtaskactivity.EdgeTeammate:
		m.ResetTeammate()
		return nil
	case archivedtaskactivity.EdgeActivityType:
		m.ResetActivityType()
		return nil
	case archivedtaskactivity.EdgeWorkspace:
		m.ResetWorkspace()
		return nil
	case archivedtaskactivity.EdgeArchivedTaskActivityTasks:
		m.ResetArchivedTaskActivityTasks()
		return nil
	}
	return fmt.Errorf("unknown ArchivedTaskActivity edge %s", name)
}

// ArchivedTaskActivityTaskMutation represents an operation that mutates the ArchivedTaskActivityTask nodes in the graph.
type ArchivedTaskActivityTaskMutation struct {
	config
	op                          Op
	typ                         string
	id                          *ulid.ID
	created_at                  *time.Time
	updated_at                  *time.Time
	clearedFields               map[string]struct{}
	task                        *ulid.ID
	clearedtask                 bool
	archivedTaskActivity        *ulid.ID
	clearedarchivedTaskActivity bool
	done                        bool
	oldValue                    func(context.Context) (*ArchivedTaskActivityTask, error)
	predicates                  []predicate.ArchivedTaskActivityTask
}

var _ ent.Mutation = (*ArchivedTaskActivityTaskMutation)(nil)

// archivedtaskactivitytaskOption allows management of the mutation configuration using functional options.
type archivedtaskactivitytaskOption func(*ArchivedTaskActivityTaskMutation)

// newArchivedTaskActivityTaskMutation creates new mutation for the ArchivedTaskActivityTask entity.
func newArchivedTaskActivityTaskMutation(c config, op Op, opts ...archivedtaskactivitytaskOption) *ArchivedTaskActivityTaskMutation {
	m := &ArchivedTaskActivityTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeArchivedTaskActivityTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArchivedTaskActivityTaskID sets the ID field of the mutation.
func withArchivedTaskActivityTaskID(id ulid.ID) archivedtaskactivitytaskOption {
	return func(m *ArchivedTaskActivityTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *ArchivedTaskActivityTask
		)
		m.oldValue = func(ctx context.Context) (*ArchivedTaskActivityTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ArchivedTaskActivityTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArchivedTaskActivityTask sets the old ArchivedTaskActivityTask of the mutation.
func withArchivedTaskActivityTask(node *ArchivedTaskActivityTask) archivedtaskactivitytaskOption {
	return func(m *ArchivedTaskActivityTaskMutation) {
		m.oldValue = func(context.Context) (*ArchivedTaskActivityTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArchivedTaskActivityTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArchivedTaskActivityTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ArchivedTaskActivityTask entities.
func (m *ArchivedTaskActivityTaskMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArchivedTaskActivityTaskMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArchivedTaskActivityTaskMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ArchivedTaskActivityTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArchivedTaskActivityID sets the "archived_task_activity_id" field.
func (m *ArchivedTaskActivityTaskMutation) SetArchivedTaskActivityID(u ulid.ID) {
	m.archivedTaskActivity = &u
}

// ArchivedTaskActivityID returns the value of the "archived_task_activity_id" field in the mutation.
func (m *ArchivedTaskActivityTaskMutation) ArchivedTaskActivityID() (r ulid.ID, exists bool) {
	v := m.archivedTaskActivity
	if v == nil {
		return
	}
	return *v, true
}

// OldArchivedTaskActivityID returns the old "archived_task_activity_id" field's value of the ArchivedTaskActivityTask entity.
// If the ArchivedTaskActivityTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivedTaskActivityTaskMutation) OldArchivedTaskActivityID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchivedTaskActivityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchivedTaskActivityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchivedTaskActivityID: %w", err)
	}
	return oldValue.ArchivedTaskActivityID, nil
}

// ResetArchivedTaskActivityID resets all changes to the "archived_task_activity_id" field.
func (m *ArchivedTaskActivityTaskMutation) ResetArchivedTaskActivityID() {
	m.archivedTaskActivity = nil
}

// SetTaskID sets the "task_id" field.
func (m *ArchivedTaskActivityTaskMutation) SetTaskID(u ulid.ID) {
	m.task = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *ArchivedTaskActivityTaskMutation) TaskID() (r ulid.ID, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the ArchivedTaskActivityTask entity.
// If the ArchivedTaskActivityTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivedTaskActivityTaskMutation) OldTaskID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *ArchivedTaskActivityTaskMutation) ResetTaskID() {
	m.task = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ArchivedTaskActivityTaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArchivedTaskActivityTaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ArchivedTaskActivityTask entity.
// If the ArchivedTaskActivityTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivedTaskActivityTaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArchivedTaskActivityTaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArchivedTaskActivityTaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArchivedTaskActivityTaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ArchivedTaskActivityTask entity.
// If the ArchivedTaskActivityTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivedTaskActivityTaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArchivedTaskActivityTaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTask clears the "task" edge to the Task entity.
func (m *ArchivedTaskActivityTaskMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *ArchivedTaskActivityTaskMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *ArchivedTaskActivityTaskMutation) TaskIDs() (ids []ulid.ID) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *ArchivedTaskActivityTaskMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// ClearArchivedTaskActivity clears the "archivedTaskActivity" edge to the ArchivedTaskActivity entity.
func (m *ArchivedTaskActivityTaskMutation) ClearArchivedTaskActivity() {
	m.clearedarchivedTaskActivity = true
}

// ArchivedTaskActivityCleared reports if the "archivedTaskActivity" edge to the ArchivedTaskActivity entity was cleared.
func (m *ArchivedTaskActivityTaskMutation) ArchivedTaskActivityCleared() bool {
	return m.clearedarchivedTaskActivity
}

// ArchivedTaskActivityIDs returns the "archivedTaskActivity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArchivedTaskActivityID instead. It exists only for internal usage by the builders.
func (m *ArchivedTaskActivityTaskMutation) ArchivedTaskActivityIDs() (ids []ulid.ID) {
	if id := m.archivedTaskActivity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArchivedTaskActivity resets all changes to the "archivedTaskActivity" edge.
func (m *ArchivedTaskActivityTaskMutation) ResetArchivedTaskActivity() {
	m.archivedTaskActivity = nil
	m.clearedarchivedTaskActivity = false
}

// Where appends a list predicates to the ArchivedTaskActivityTaskMutation builder.
func (m *ArchivedTaskActivityTaskMutation) Where(ps ...predicate.ArchivedTaskActivityTask) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ArchivedTaskActivityTaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ArchivedTaskActivityTask).
func (m *ArchivedTaskActivityTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArchivedTaskActivityTaskMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.archivedTaskActivity != nil {
		fields = append(fields, archivedtaskactivitytask.FieldArchivedTaskActivityID)
	}
	if m.task != nil {
		fields = append(fields, archivedtaskactivitytask.FieldTaskID)
	}
	if m.created_at != nil {
		fields = append(fields, archivedtaskactivitytask.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, archivedtaskactivitytask.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArchivedTaskActivityTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case archivedtaskactivitytask.FieldArchivedTaskActivityID:
		return m.ArchivedTaskActivityID()
	case archivedtaskactivitytask.FieldTaskID:
		return m.TaskID()
	case archivedtaskactivitytask.FieldCreatedAt:
		return m.CreatedAt()
	case archivedtaskactivitytask.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArchivedTaskActivityTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case archivedtaskactivitytask.FieldArchivedTaskActivityID:
		return m.OldArchivedTaskActivityID(ctx)
	case archivedtaskactivitytask.FieldTaskID:
		return m.OldTaskID(ctx)
	case archivedtaskactivitytask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case archivedtaskactivitytask.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ArchivedTaskActivityTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArchivedTaskActivityTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case archivedtaskactivitytask.FieldArchivedTaskActivityID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchivedTaskActivityID(v)
		return nil
	case archivedtaskactivitytask.FieldTaskID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case archivedtaskactivitytask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case archivedtaskactivitytask.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ArchivedTaskActivityTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArchivedTaskActivityTaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArchivedTaskActivityTaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArchivedTaskActivityTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ArchivedTaskActivityTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArchivedTaskActivityTaskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArchivedTaskActivityTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArchivedTaskActivityTaskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ArchivedTaskActivityTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArchivedTaskActivityTaskMutation) ResetField(name string) error {
	switch name {
	case archivedtaskactivitytask.FieldArchivedTaskActivityID:
		m.ResetArchivedTaskActivityID()
		return nil
	case archivedtaskactivitytask.FieldTaskID:
		m.ResetTaskID()
		return nil
	case archivedtaskactivitytask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case archivedtaskactivitytask.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ArchivedTaskActivityTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArchivedTaskActivityTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.task != nil {
		edges = append(edges, archivedtaskactivitytask.EdgeTask)
	}
	if m.archivedTaskActivity != nil {
		edges = append(edges, archivedtaskactivitytask.EdgeArchivedTaskActivity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArchivedTaskActivityTaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case archivedtaskactivitytask.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case archivedtaskactivitytask.EdgeArchivedTaskActivity:
		if id := m.archivedTaskActivity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArchivedTaskActivityTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArchivedTaskActivityTaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArchivedTaskActivityTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtask {
		edges = append(edges, archivedtaskactivitytask.EdgeTask)
	}
	if m.clearedarchivedTaskActivity {
		edges = append(edges, archivedtaskactivitytask.EdgeArchivedTaskActivity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArchivedTaskActivityTaskMutation) EdgeCleared(name string) bool {
	switch name {
	case archivedtaskactivitytask.EdgeTask:
		return m.clearedtask
	case archivedtaskactivitytask.EdgeArchivedTaskActivity:
		return m.clearedarchivedTaskActivity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArchivedTaskActivityTaskMutation) ClearEdge(name string) error {
	switch name {
	case archivedtaskactivitytask.EdgeTask:
		m.ClearTask()
		return nil
	case archivedtaskactivitytask.EdgeArchivedTaskActivity:
		m.ClearArchivedTaskActivity()
		return nil
	}
	return fmt.Errorf("unknown ArchivedTaskActivityTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArchivedTaskActivityTaskMutation) ResetEdge(name string) error {
	switch name {
	case archivedtaskactivitytask.EdgeTask:
		m.ResetTask()
		return nil
	case archivedtaskactivitytask.EdgeArchivedTaskActivity:
		m.ResetArchivedTaskActivity()
		return nil
	}
	return fmt.Errorf("unknown ArchivedTaskActivityTask edge %s", name)
}

// ArchivedWorkspaceActivityMutation represents an operation that mutates the ArchivedWorkspaceActivity nodes in the graph.
type ArchivedWorkspaceActivityMutation struct {
	config
	op                                    Op
	typ                                   string
	id                                    *ulid.ID
	created_at                            *time.Time
	updated_at                            *time.Time
	clearedFields                         map[string]struct{}
	activityType                          *ulid.ID
	clearedactivityType                   bool
	workspace                             *ulid.ID
	clearedworkspace                      bool
	project                               *ulid.ID
	clearedproject                        bool
	teammate                              *ulid.ID
	clearedteammate                       bool
	archivedWorkspaceActivityTasks        map[ulid.ID]struct{}
	removedarchivedWorkspaceActivityTasks map[ulid.ID]struct{}
	clearedarchivedWorkspaceActivityTasks bool
	done                                  bool
	oldValue                              func(context.Context) (*ArchivedWorkspaceActivity, error)
	predicates                            []predicate.ArchivedWorkspaceActivity
}

var _ ent.Mutation = (*ArchivedWorkspaceActivityMutation)(nil)

// archivedworkspaceactivityOption allows management of the mutation configuration using functional options.
type archivedworkspaceactivityOption func(*ArchivedWorkspaceActivityMutation)

// newArchivedWorkspaceActivityMutation creates new mutation for the ArchivedWorkspaceActivity entity.
func newArchivedWorkspaceActivityMutation(c config, op Op, opts ...archivedworkspaceactivityOption) *ArchivedWorkspaceActivityMutation {
	m := &ArchivedWorkspaceActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeArchivedWorkspaceActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArchivedWorkspaceActivityID sets the ID field of the mutation.
func withArchivedWorkspaceActivityID(id ulid.ID) archivedworkspaceactivityOption {
	return func(m *ArchivedWorkspaceActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *ArchivedWorkspaceActivity
		)
		m.oldValue = func(ctx context.Context) (*ArchivedWorkspaceActivity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ArchivedWorkspaceActivity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArchivedWorkspaceActivity sets the old ArchivedWorkspaceActivity of the mutation.
func withArchivedWorkspaceActivity(node *ArchivedWorkspaceActivity) archivedworkspaceactivityOption {
	return func(m *ArchivedWorkspaceActivityMutation) {
		m.oldValue = func(context.Context) (*ArchivedWorkspaceActivity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArchivedWorkspaceActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArchivedWorkspaceActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ArchivedWorkspaceActivity entities.
func (m *ArchivedWorkspaceActivityMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArchivedWorkspaceActivityMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArchivedWorkspaceActivityMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ArchivedWorkspaceActivity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetActivityTypeID sets the "activity_type_id" field.
func (m *ArchivedWorkspaceActivityMutation) SetActivityTypeID(u ulid.ID) {
	m.activityType = &u
}

// ActivityTypeID returns the value of the "activity_type_id" field in the mutation.
func (m *ArchivedWorkspaceActivityMutation) ActivityTypeID() (r ulid.ID, exists bool) {
	v := m.activityType
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityTypeID returns the old "activity_type_id" field's value of the ArchivedWorkspaceActivity entity.
// If the ArchivedWorkspaceActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivedWorkspaceActivityMutation) OldActivityTypeID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivityTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivityTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityTypeID: %w", err)
	}
	return oldValue.ActivityTypeID, nil
}

// ResetActivityTypeID resets all changes to the "activity_type_id" field.
func (m *ArchivedWorkspaceActivityMutation) ResetActivityTypeID() {
	m.activityType = nil
}

// SetWorkspaceID sets the "workspace_id" field.
func (m *ArchivedWorkspaceActivityMutation) SetWorkspaceID(u ulid.ID) {
	m.workspace = &u
}

// WorkspaceID returns the value of the "workspace_id" field in the mutation.
func (m *ArchivedWorkspaceActivityMutation) WorkspaceID() (r ulid.ID, exists bool) {
	v := m.workspace
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspaceID returns the old "workspace_id" field's value of the ArchivedWorkspaceActivity entity.
// If the ArchivedWorkspaceActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivedWorkspaceActivityMutation) OldWorkspaceID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspaceID: %w", err)
	}
	return oldValue.WorkspaceID, nil
}

// ResetWorkspaceID resets all changes to the "workspace_id" field.
func (m *ArchivedWorkspaceActivityMutation) ResetWorkspaceID() {
	m.workspace = nil
}

// SetProjectID sets the "project_id" field.
func (m *ArchivedWorkspaceActivityMutation) SetProjectID(u ulid.ID) {
	m.project = &u
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ArchivedWorkspaceActivityMutation) ProjectID() (r ulid.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the ArchivedWorkspaceActivity entity.
// If the ArchivedWorkspaceActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivedWorkspaceActivityMutation) OldProjectID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ArchivedWorkspaceActivityMutation) ResetProjectID() {
	m.project = nil
}

// SetTeammateID sets the "teammate_id" field.
func (m *ArchivedWorkspaceActivityMutation) SetTeammateID(u ulid.ID) {
	m.teammate = &u
}

// TeammateID returns the value of the "teammate_id" field in the mutation.
func (m *ArchivedWorkspaceActivityMutation) TeammateID() (r ulid.ID, exists bool) {
	v := m.teammate
	if v == nil {
		return
	}
	return *v, true
}

// OldTeammateID returns the old "teammate_id" field's value of the ArchivedWorkspaceActivity entity.
// If the ArchivedWorkspaceActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivedWorkspaceActivityMutation) OldTeammateID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeammateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeammateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeammateID: %w", err)
	}
	return oldValue.TeammateID, nil
}

// ResetTeammateID resets all changes to the "teammate_id" field.
func (m *ArchivedWorkspaceActivityMutation) ResetTeammateID() {
	m.teammate = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ArchivedWorkspaceActivityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArchivedWorkspaceActivityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ArchivedWorkspaceActivity entity.
// If the ArchivedWorkspaceActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivedWorkspaceActivityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArchivedWorkspaceActivityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArchivedWorkspaceActivityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArchivedWorkspaceActivityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ArchivedWorkspaceActivity entity.
// If the ArchivedWorkspaceActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivedWorkspaceActivityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArchivedWorkspaceActivityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearActivityType clears the "activityType" edge to the ActivityType entity.
func (m *ArchivedWorkspaceActivityMutation) ClearActivityType() {
	m.clearedactivityType = true
}

// ActivityTypeCleared reports if the "activityType" edge to the ActivityType entity was cleared.
func (m *ArchivedWorkspaceActivityMutation) ActivityTypeCleared() bool {
	return m.clearedactivityType
}

// ActivityTypeIDs returns the "activityType" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActivityTypeID instead. It exists only for internal usage by the builders.
func (m *ArchivedWorkspaceActivityMutation) ActivityTypeIDs() (ids []ulid.ID) {
	if id := m.activityType; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivityType resets all changes to the "activityType" edge.
func (m *ArchivedWorkspaceActivityMutation) ResetActivityType() {
	m.activityType = nil
	m.clearedactivityType = false
}

// ClearWorkspace clears the "workspace" edge to the Workspace entity.
func (m *ArchivedWorkspaceActivityMutation) ClearWorkspace() {
	m.clearedworkspace = true
}

// WorkspaceCleared reports if the "workspace" edge to the Workspace entity was cleared.
func (m *ArchivedWorkspaceActivityMutation) WorkspaceCleared() bool {
	return m.clearedworkspace
}

// WorkspaceIDs returns the "workspace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkspaceID instead. It exists only for internal usage by the builders.
func (m *ArchivedWorkspaceActivityMutation) WorkspaceIDs() (ids []ulid.ID) {
	if id := m.workspace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkspace resets all changes to the "workspace" edge.
func (m *ArchivedWorkspaceActivityMutation) ResetWorkspace() {
	m.workspace = nil
	m.clearedworkspace = false
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ArchivedWorkspaceActivityMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ArchivedWorkspaceActivityMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ArchivedWorkspaceActivityMutation) ProjectIDs() (ids []ulid.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ArchivedWorkspaceActivityMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearTeammate clears the "teammate" edge to the Teammate entity.
func (m *ArchivedWorkspaceActivityMutation) ClearTeammate() {
	m.clearedteammate = true
}

// TeammateCleared reports if the "teammate" edge to the Teammate entity was cleared.
func (m *ArchivedWorkspaceActivityMutation) TeammateCleared() bool {
	return m.clearedteammate
}

// TeammateIDs returns the "teammate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeammateID instead. It exists only for internal usage by the builders.
func (m *ArchivedWorkspaceActivityMutation) TeammateIDs() (ids []ulid.ID) {
	if id := m.teammate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeammate resets all changes to the "teammate" edge.
func (m *ArchivedWorkspaceActivityMutation) ResetTeammate() {
	m.teammate = nil
	m.clearedteammate = false
}

// AddArchivedWorkspaceActivityTaskIDs adds the "archivedWorkspaceActivityTasks" edge to the ArchivedWorkspaceActivityTask entity by ids.
func (m *ArchivedWorkspaceActivityMutation) AddArchivedWorkspaceActivityTaskIDs(ids ...ulid.ID) {
	if m.archivedWorkspaceActivityTasks == nil {
		m.archivedWorkspaceActivityTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.archivedWorkspaceActivityTasks[ids[i]] = struct{}{}
	}
}

// ClearArchivedWorkspaceActivityTasks clears the "archivedWorkspaceActivityTasks" edge to the ArchivedWorkspaceActivityTask entity.
func (m *ArchivedWorkspaceActivityMutation) ClearArchivedWorkspaceActivityTasks() {
	m.clearedarchivedWorkspaceActivityTasks = true
}

// ArchivedWorkspaceActivityTasksCleared reports if the "archivedWorkspaceActivityTasks" edge to the ArchivedWorkspaceActivityTask entity was cleared.
func (m *ArchivedWorkspaceActivityMutation) ArchivedWorkspaceActivityTasksCleared() bool {
	return m.clearedarchivedWorkspaceActivityTasks
}

// RemoveArchivedWorkspaceActivityTaskIDs removes the "archivedWorkspaceActivityTasks" edge to the ArchivedWorkspaceActivityTask entity by IDs.
func (m *ArchivedWorkspaceActivityMutation) RemoveArchivedWorkspaceActivityTaskIDs(ids ...ulid.ID) {
	if m.removedarchivedWorkspaceActivityTasks == nil {
		m.removedarchivedWorkspaceActivityTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.archivedWorkspaceActivityTasks, ids[i])
		m.removedarchivedWorkspaceActivityTasks[ids[i]] = struct{}{}
	}
}

// RemovedArchivedWorkspaceActivityTasks returns the removed IDs of the "archivedWorkspaceActivityTasks" edge to the ArchivedWorkspaceActivityTask entity.
func (m *ArchivedWorkspaceActivityMutation) RemovedArchivedWorkspaceActivityTasksIDs() (ids []ulid.ID) {
	for id := range m.removedarchivedWorkspaceActivityTasks {
		ids = append(ids, id)
	}
	return
}

// ArchivedWorkspaceActivityTasksIDs returns the "archivedWorkspaceActivityTasks" edge IDs in the mutation.
func (m *ArchivedWorkspaceActivityMutation) ArchivedWorkspaceActivityTasksIDs() (ids []ulid.ID) {
	for id := range m.archivedWorkspaceActivityTasks {
		ids = append(ids, id)
	}
	return
}

// ResetArchivedWorkspaceActivityTasks resets all changes to the "archivedWorkspaceActivityTasks" edge.
func (m *ArchivedWorkspaceActivityMutation) ResetArchivedWorkspaceActivityTasks() {
	m.archivedWorkspaceActivityTasks = nil
	m.clearedarchivedWorkspaceActivityTasks = false
	m.removedarchivedWorkspaceActivityTasks = nil
}

// Where appends a list predicates to the ArchivedWorkspaceActivityMutation builder.
func (m *ArchivedWorkspaceActivityMutation) Where(ps ...predicate.ArchivedWorkspaceActivity) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ArchivedWorkspaceActivityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ArchivedWorkspaceActivity).
func (m *ArchivedWorkspaceActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArchivedWorkspaceActivityMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.activityType != nil {
		fields = append(fields, archivedworkspaceactivity.FieldActivityTypeID)
	}
	if m.workspace != nil {
		fields = append(fields, archivedworkspaceactivity.FieldWorkspaceID)
	}
	if m.project != nil {
		fields = append(fields, archivedworkspaceactivity.FieldProjectID)
	}
	if m.teammate != nil {
		fields = append(fields, archivedworkspaceactivity.FieldTeammateID)
	}
	if m.created_at != nil {
		fields = append(fields, archivedworkspaceactivity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, archivedworkspaceactivity.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArchivedWorkspaceActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case archivedworkspaceactivity.FieldActivityTypeID:
		return m.ActivityTypeID()
	case archivedworkspaceactivity.FieldWorkspaceID:
		return m.WorkspaceID()
	case archivedworkspaceactivity.FieldProjectID:
		return m.ProjectID()
	case archivedworkspaceactivity.FieldTeammateID:
		return m.TeammateID()
	case archivedworkspaceactivity.FieldCreatedAt:
		return m.CreatedAt()
	case archivedworkspaceactivity.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArchivedWorkspaceActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case archivedworkspaceactivity.FieldActivityTypeID:
		return m.OldActivityTypeID(ctx)
	case archivedworkspaceactivity.FieldWorkspaceID:
		return m.OldWorkspaceID(ctx)
	case archivedworkspaceactivity.FieldProjectID:
		return m.OldProjectID(ctx)
	case archivedworkspaceactivity.FieldTeammateID:
		return m.OldTeammateID(ctx)
	case archivedworkspaceactivity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case archivedworkspaceactivity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ArchivedWorkspaceActivity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArchivedWorkspaceActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case archivedworkspaceactivity.FieldActivityTypeID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityTypeID(v)
		return nil
	case archivedworkspaceactivity.FieldWorkspaceID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspaceID(v)
		return nil
	case archivedworkspaceactivity.FieldProjectID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case archivedworkspaceactivity.FieldTeammateID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeammateID(v)
		return nil
	case archivedworkspaceactivity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case archivedworkspaceactivity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ArchivedWorkspaceActivity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArchivedWorkspaceActivityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArchivedWorkspaceActivityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArchivedWorkspaceActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ArchivedWorkspaceActivity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArchivedWorkspaceActivityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArchivedWorkspaceActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArchivedWorkspaceActivityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ArchivedWorkspaceActivity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArchivedWorkspaceActivityMutation) ResetField(name string) error {
	switch name {
	case archivedworkspaceactivity.FieldActivityTypeID:
		m.ResetActivityTypeID()
		return nil
	case archivedworkspaceactivity.FieldWorkspaceID:
		m.ResetWorkspaceID()
		return nil
	case archivedworkspaceactivity.FieldProjectID:
		m.ResetProjectID()
		return nil
	case archivedworkspaceactivity.FieldTeammateID:
		m.ResetTeammateID()
		return nil
	case archivedworkspaceactivity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case archivedworkspaceactivity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ArchivedWorkspaceActivity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArchivedWorkspaceActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.activityType != nil {
		edges = append(edges, archivedworkspaceactivity.EdgeActivityType)
	}
	if m.workspace != nil {
		edges = append(edges, archivedworkspaceactivity.EdgeWorkspace)
	}
	if m.project != nil {
		edges = append(edges, archivedworkspaceactivity.EdgeProject)
	}
	if m.teammate != nil {
		edges = append(edges, archivedworkspaceactivity.EdgeTeammate)
	}
	if m.archivedWorkspaceActivityTasks != nil {
		edges = append(edges, archivedworkspaceactivity.EdgeArchivedWorkspaceActivityTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArchivedWorkspaceActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case archivedworkspaceactivity.EdgeActivityType:
		if id := m.activityType; id != nil {
			return []ent.Value{*id}
		}
	case archivedworkspaceactivity.EdgeWorkspace:
		if id := m.workspace; id != nil {
			return []ent.Value{*id}
		}
	case archivedworkspaceactivity.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case archivedworkspaceactivity.EdgeTeammate:
		if id := m.teammate; id != nil {
			return []ent.Value{*id}
		}
	case archivedworkspaceactivity.EdgeArchivedWorkspaceActivityTasks:
		ids := make([]ent.Value, 0, len(m.archivedWorkspaceActivityTasks))
		for id := range m.archivedWorkspaceActivityTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArchivedWorkspaceActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedarchivedWorkspaceActivityTasks != nil {
		edges = append(edges, archivedworkspaceactivity.EdgeArchivedWorkspaceActivityTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArchivedWorkspaceActivityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case archivedworkspaceactivity.EdgeArchivedWorkspaceActivityTasks:
		ids := make([]ent.Value, 0, len(m.removedarchivedWorkspaceActivityTasks))
		for id := range m.removedarchivedWorkspaceActivityTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArchivedWorkspaceActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedactivityType {
		edges = append(edges, archivedworkspaceactivity.EdgeActivityType)
	}
	if m.clearedworkspace {
		edges = append(edges, archivedworkspaceactivity.EdgeWorkspace)
	}
	if m.clearedproject {
		edges = append(edges, archivedworkspaceactivity.EdgeProject)
	}
	if m.clearedteammate {
		edges = append(edges, archivedworkspaceactivity.EdgeTeammate)
	}
	if m.clearedarchivedWorkspaceActivityTasks {
		edges = append(edges, archivedworkspaceactivity.EdgeArchivedWorkspaceActivityTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArchivedWorkspaceActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case archivedworkspaceactivity.EdgeActivityType:
		return m.clearedactivityType
	case archivedworkspaceactivity.EdgeWorkspace:
		return m.clearedworkspace
	case archivedworkspaceactivity.EdgeProject:
		return m.clearedproject
	case archivedworkspaceactivity.EdgeTeammate:
		return m.clearedteammate
	case archivedworkspaceactivity.EdgeArchivedWorkspaceActivityTasks:
		return m.clearedarchivedWorkspaceActivityTasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArchivedWorkspaceActivityMutation) ClearEdge(name string) error {
	switch name {
	case archivedworkspaceactivity.EdgeActivityType:
		m.ClearActivityType()
		return nil
	case archivedworkspaceactivity.EdgeWorkspace:
		m.ClearWorkspace()
		return nil
	case archivedworkspaceactivity.EdgeProject:
		m.ClearProject()
		return nil
	case archivedworkspaceactivity.EdgeTeammate:
		m.ClearTeammate()
		return nil
	}
	return fmt.Errorf("unknown ArchivedWorkspaceActivity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArchivedWorkspaceActivityMutation) ResetEdge(name string) error {
	switch name {
	case archivedworkspaceactivity.EdgeActivityType:
		m.ResetActivityType()
		return nil
	case archivedworkspaceactivity.EdgeWorkspace:
		m.ResetWorkspace()
		return nil
	case archivedworkspaceactivity.EdgeProject:
		m.ResetProject()
		return nil
	case archivedworkspaceactivity.EdgeTeammate:
		m.ResetTeammate()
		return nil
	case archivedworkspaceactivity.EdgeArchivedWorkspaceActivityTasks:
		m.ResetArchivedWorkspaceActivityTasks()
		return nil
	}
	return fmt.Errorf("unknown ArchivedWorkspaceActivity edge %s", name)
}

// ArchivedWorkspaceActivityTaskMutation represents an operation that mutates the ArchivedWorkspaceActivityTask nodes in the graph.
type ArchivedWorkspaceActivityTaskMutation struct {
	config
	op                               Op
	typ                              string
	id                               *ulid.ID
	created_at                       *time.Time
	updated_at                       *time.Time
	clearedFields                    map[string]struct{}
	task                             *ulid.ID
	clearedtask                      bool
	archivedWorkspaceActivity        *ulid.ID
	clearedarchivedWorkspaceActivity bool
	done                             bool
	oldValue                         func(context.Context) (*ArchivedWorkspaceActivityTask, error)
	predicates                       []predicate.ArchivedWorkspaceActivityTask
}

var _ ent.Mutation = (*ArchivedWorkspaceActivityTaskMutation)(nil)

// archivedworkspaceactivitytaskOption allows management of the mutation configuration using functional options.
type archivedworkspaceactivitytaskOption func(*ArchivedWorkspaceActivityTaskMutation)

// newArchivedWorkspaceActivityTaskMutation creates new mutation for the ArchivedWorkspaceActivityTask entity.
func newArchivedWorkspaceActivityTaskMutation(c config, op Op, opts ...archivedworkspaceactivitytaskOption) *ArchivedWorkspaceActivityTaskMutation {
	m := &ArchivedWorkspaceActivityTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeArchivedWorkspaceActivityTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArchivedWorkspaceActivityTaskID sets the ID field of the mutation.
func withArchivedWorkspaceActivityTaskID(id ulid.ID) archivedworkspaceactivitytaskOption {
	return func(m *ArchivedWorkspaceActivityTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *ArchivedWorkspaceActivityTask
		)
		m.oldValue = func(ctx context.Context) (*ArchivedWorkspaceActivityTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ArchivedWorkspaceActivityTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArchivedWorkspaceActivityTask sets the old ArchivedWorkspaceActivityTask of the mutation.
func withArchivedWorkspaceActivityTask(node *ArchivedWorkspaceActivityTask) archivedworkspaceactivitytaskOption {
	return func(m *ArchivedWorkspaceActivityTaskMutation) {
		m.oldValue = func(context.Context) (*ArchivedWorkspaceActivityTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArchivedWorkspaceActivityTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArchivedWorkspaceActivityTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ArchivedWorkspaceActivityTask entities.
func (m *ArchivedWorkspaceActivityTaskMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArchivedWorkspaceActivityTaskMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArchivedWorkspaceActivityTaskMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ArchivedWorkspaceActivityTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArchivedWorkspaceActivityID sets the "archived_workspace_activity_id" field.
func (m *ArchivedWorkspaceActivityTaskMutation) SetArchivedWorkspaceActivityID(u ulid.ID) {
	m.archivedWorkspaceActivity = &u
}

// ArchivedWorkspaceActivityID returns the value of the "archived_workspace_activity_id" field in the mutation.
func (m *ArchivedWorkspaceActivityTaskMutation) ArchivedWorkspaceActivityID() (r ulid.ID, exists bool) {
	v := m.archivedWorkspaceActivity
	if v == nil {
		return
	}
	return *v, true
}

// OldArchivedWorkspaceActivityID returns the old "archived_workspace_activity_id" field's value of the ArchivedWorkspaceActivityTask entity.
// If the ArchivedWorkspaceActivityTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivedWorkspaceActivityTaskMutation) OldArchivedWorkspaceActivityID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchivedWorkspaceActivityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchivedWorkspaceActivityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchivedWorkspaceActivityID: %w", err)
	}
	return oldValue.ArchivedWorkspaceActivityID, nil
}

// ResetArchivedWorkspaceActivityID resets all changes to the "archived_workspace_activity_id" field.
func (m *ArchivedWorkspaceActivityTaskMutation) ResetArchivedWorkspaceActivityID() {
	m.archivedWorkspaceActivity = nil
}

// SetTaskID sets the "task_id" field.
func (m *ArchivedWorkspaceActivityTaskMutation) SetTaskID(u ulid.ID) {
	m.task = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *ArchivedWorkspaceActivityTaskMutation) TaskID() (r ulid.ID, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the ArchivedWorkspaceActivityTask entity.
// If the ArchivedWorkspaceActivityTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivedWorkspaceActivityTaskMutation) OldTaskID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *ArchivedWorkspaceActivityTaskMutation) ResetTaskID() {
	m.task = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ArchivedWorkspaceActivityTaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArchivedWorkspaceActivityTaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ArchivedWorkspaceActivityTask entity.
// If the ArchivedWorkspaceActivityTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivedWorkspaceActivityTaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArchivedWorkspaceActivityTaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArchivedWorkspaceActivityTaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArchivedWorkspaceActivityTaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ArchivedWorkspaceActivityTask entity.
// If the ArchivedWorkspaceActivityTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArchivedWorkspaceActivityTaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArchivedWorkspaceActivityTaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTask clears the "task" edge to the Task entity.
func (m *ArchivedWorkspaceActivityTaskMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *ArchivedWorkspaceActivityTaskMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *ArchivedWorkspaceActivityTaskMutation) TaskIDs() (ids []ulid.ID) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *ArchivedWorkspaceActivityTaskMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// ClearArchivedWorkspaceActivity clears the "archivedWorkspaceActivity" edge to the ArchivedWorkspaceActivity entity.
func (m *ArchivedWorkspaceActivityTaskMutation) ClearArchivedWorkspaceActivity() {
	m.clearedarchivedWorkspaceActivity = true
}

// ArchivedWorkspaceActivityCleared reports if the "archivedWorkspaceActivity" edge to the ArchivedWorkspaceActivity entity was cleared.
func (m *ArchivedWorkspaceActivityTaskMutation) ArchivedWorkspaceActivityCleared() bool {
	return m.clearedarchivedWorkspaceActivity
}

// ArchivedWorkspaceActivityIDs returns the "archivedWorkspaceActivity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArchivedWorkspaceActivityID instead. It exists only for internal usage by the builders.
func (m *ArchivedWorkspaceActivityTaskMutation) ArchivedWorkspaceActivityIDs() (ids []ulid.ID) {
	if id := m.archivedWorkspaceActivity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArchivedWorkspaceActivity resets all changes to the "archivedWorkspaceActivity" edge.
func (m *ArchivedWorkspaceActivityTaskMutation) ResetArchivedWorkspaceActivity() {
	m.archivedWorkspaceActivity = nil
	m.clearedarchivedWorkspaceActivity = false
}

// Where appends a list predicates to the ArchivedWorkspaceActivityTaskMutation builder.
func (m *ArchivedWorkspaceActivityTaskMutation) Where(ps ...predicate.ArchivedWorkspaceActivityTask) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ArchivedWorkspaceActivityTaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ArchivedWorkspaceActivityTask).
func (m *ArchivedWorkspaceActivityTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArchivedWorkspaceActivityTaskMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.archivedWorkspaceActivity != nil {
		fields = append(fields, archivedworkspaceactivitytask.FieldArchivedWorkspaceActivityID)
	}
	if m.task != nil {
		fields = append(fields, archivedworkspaceactivitytask.FieldTaskID)
	}
	if m.created_at != nil {
		fields = append(fields, archivedworkspaceactivitytask.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, archivedworkspaceactivitytask.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArchivedWorkspaceActivityTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case archivedworkspaceactivitytask.FieldArchivedWorkspaceActivityID:
		return m.ArchivedWorkspaceActivityID()
	case archivedworkspaceactivitytask.FieldTaskID:
		return m.TaskID()
	case archivedworkspaceactivitytask.FieldCreatedAt:
		return m.CreatedAt()
	case archivedworkspaceactivitytask.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArchivedWorkspaceActivityTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case archivedworkspaceactivitytask.FieldArchivedWorkspaceActivityID:
		return m.OldArchivedWorkspaceActivityID(ctx)
	case archivedworkspaceactivitytask.FieldTaskID:
		return m.OldTaskID(ctx)
	case archivedworkspaceactivitytask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case archivedworkspaceactivitytask.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ArchivedWorkspaceActivityTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArchivedWorkspaceActivityTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case archivedworkspaceactivitytask.FieldArchivedWorkspaceActivityID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchivedWorkspaceActivityID(v)
		return nil
	case archivedworkspaceactivitytask.FieldTaskID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case archivedworkspaceactivitytask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case archivedworkspaceactivitytask.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ArchivedWorkspaceActivityTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArchivedWorkspaceActivityTaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArchivedWorkspaceActivityTaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArchivedWorkspaceActivityTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ArchivedWorkspaceActivityTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArchivedWorkspaceActivityTaskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArchivedWorkspaceActivityTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArchivedWorkspaceActivityTaskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ArchivedWorkspaceActivityTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArchivedWorkspaceActivityTaskMutation) ResetField(name string) error {
	switch name {
	case archivedworkspaceactivitytask.FieldArchivedWorkspaceActivityID:
		m.ResetArchivedWorkspaceActivityID()
		return nil
	case archivedworkspaceactivitytask.FieldTaskID:
		m.ResetTaskID()
		return nil
	case archivedworkspaceactivitytask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case archivedworkspaceactivitytask.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ArchivedWorkspaceActivityTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArchivedWorkspaceActivityTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.task != nil {
		edges = append(edges, archivedworkspaceactivitytask.EdgeTask)
	}
	if m.archivedWorkspaceActivity != nil {
		edges = append(edges, archivedworkspaceactivitytask.EdgeArchivedWorkspaceActivity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArchivedWorkspaceActivityTaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case archivedworkspaceactivitytask.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case archivedworkspaceactivitytask.EdgeArchivedWorkspaceActivity:
		if id := m.archivedWorkspaceActivity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArchivedWorkspaceActivityTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArchivedWorkspaceActivityTaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArchivedWorkspaceActivityTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtask {
		edges = append(edges, archivedworkspaceactivitytask.EdgeTask)
	}
	if m.clearedarchivedWorkspaceActivity {
		edges = append(edges, archivedworkspaceactivitytask.EdgeArchivedWorkspaceActivity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArchivedWorkspaceActivityTaskMutation) EdgeCleared(name string) bool {
	switch name {
	case archivedworkspaceactivitytask.EdgeTask:
		return m.clearedtask
	case archivedworkspaceactivitytask.EdgeArchivedWorkspaceActivity:
		return m.clearedarchivedWorkspaceActivity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArchivedWorkspaceActivityTaskMutation) ClearEdge(name string) error {
	switch name {
	case archivedworkspaceactivitytask.EdgeTask:
		m.ClearTask()
		return nil
	case archivedworkspaceactivitytask.EdgeArchivedWorkspaceActivity:
		m.ClearArchivedWorkspaceActivity()
		return nil
	}
	return fmt.Errorf("unknown ArchivedWorkspaceActivityTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArchivedWorkspaceActivityTaskMutation) ResetEdge(name string) error {
	switch name {
	case archivedworkspaceactivitytask.EdgeTask:
		m.ResetTask()
		return nil
	case archivedworkspaceactivitytask.EdgeArchivedWorkspaceActivity:
		m.ResetArchivedWorkspaceActivity()
		return nil
	}
	return fmt.Errorf("unknown ArchivedWorkspaceActivityTask edge %s", name)
}

// ColorMutation represents an operation that mutates the Color nodes in the graph.
type ColorMutation struct {
	config
	op                        Op
	typ                       string
	id                        *ulid.ID
	name                      *string
	color                     *string
	hex                       *string
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	projectBaseColors         map[ulid.ID]struct{}
	removedprojectBaseColors  map[ulid.ID]struct{}
	clearedprojectBaseColors  bool
	projectLightColors        map[ulid.ID]struct{}
	removedprojectLightColors map[ulid.ID]struct{}
	clearedprojectLightColors bool
	taskPriorities            map[ulid.ID]struct{}
	removedtaskPriorities     map[ulid.ID]struct{}
	clearedtaskPriorities     bool
	tags                      map[ulid.ID]struct{}
	removedtags               map[ulid.ID]struct{}
	clearedtags               bool
	done                      bool
	oldValue                  func(context.Context) (*Color, error)
	predicates                []predicate.Color
}

var _ ent.Mutation = (*ColorMutation)(nil)

// colorOption allows management of the mutation configuration using functional options.
type colorOption func(*ColorMutation)

// newColorMutation creates new mutation for the Color entity.
func newColorMutation(c config, op Op, opts ...colorOption) *ColorMutation {
	m := &ColorMutation{
		config:        c,
		op:            op,
		typ:           TypeColor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withColorID sets the ID field of the mutation.
func withColorID(id ulid.ID) colorOption {
	return func(m *ColorMutation) {
		var (
			err   error
			once  sync.Once
			value *Color
		)
		m.oldValue = func(ctx context.Context) (*Color, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Color.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withColor sets the old Color of the mutation.
func withColor(node *Color) colorOption {
	return func(m *ColorMutation) {
		m.oldValue = func(context.Context) (*Color, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ColorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ColorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Color entities.
func (m *ColorMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ColorMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ColorMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Color.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ColorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ColorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Color entity.
// If the Color object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ColorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ColorMutation) ResetName() {
	m.name = nil
}

// SetColor sets the "color" field.
func (m *ColorMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *ColorMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Color entity.
// If the Color object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ColorMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *ColorMutation) ResetColor() {
	m.color = nil
}

// SetHex sets the "hex" field.
func (m *ColorMutation) SetHex(s string) {
	m.hex = &s
}

// Hex returns the value of the "hex" field in the mutation.
func (m *ColorMutation) Hex() (r string, exists bool) {
	v := m.hex
	if v == nil {
		return
	}
	return *v, true
}

// OldHex returns the old "hex" field's value of the Color entity.
// If the Color object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ColorMutation) OldHex(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHex: %w", err)
	}
	return oldValue.Hex, nil
}

// ResetHex resets all changes to the "hex" field.
func (m *ColorMutation) ResetHex() {
	m.hex = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ColorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ColorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Color entity.
// If the Color object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ColorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ColorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ColorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ColorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Color entity.
// If the Color object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ColorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ColorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddProjectBaseColorIDs adds the "projectBaseColors" edge to the ProjectBaseColor entity by ids.
func (m *ColorMutation) AddProjectBaseColorIDs(ids ...ulid.ID) {
	if m.projectBaseColors == nil {
		m.projectBaseColors = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.projectBaseColors[ids[i]] = struct{}{}
	}
}

// ClearProjectBaseColors clears the "projectBaseColors" edge to the ProjectBaseColor entity.
func (m *ColorMutation) ClearProjectBaseColors() {
	m.clearedprojectBaseColors = true
}

// ProjectBaseColorsCleared reports if the "projectBaseColors" edge to the ProjectBaseColor entity was cleared.
func (m *ColorMutation) ProjectBaseColorsCleared() bool {
	return m.clearedprojectBaseColors
}

// RemoveProjectBaseColorIDs removes the "projectBaseColors" edge to the ProjectBaseColor entity by IDs.
func (m *ColorMutation) RemoveProjectBaseColorIDs(ids ...ulid.ID) {
	if m.removedprojectBaseColors == nil {
		m.removedprojectBaseColors = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.projectBaseColors, ids[i])
		m.removedprojectBaseColors[ids[i]] = struct{}{}
	}
}

// RemovedProjectBaseColors returns the removed IDs of the "projectBaseColors" edge to the ProjectBaseColor entity.
func (m *ColorMutation) RemovedProjectBaseColorsIDs() (ids []ulid.ID) {
	for id := range m.removedprojectBaseColors {
		ids = append(ids, id)
	}
	return
}

// ProjectBaseColorsIDs returns the "projectBaseColors" edge IDs in the mutation.
func (m *ColorMutation) ProjectBaseColorsIDs() (ids []ulid.ID) {
	for id := range m.projectBaseColors {
		ids = append(ids, id)
	}
	return
}

// ResetProjectBaseColors resets all changes to the "projectBaseColors" edge.
func (m *ColorMutation) ResetProjectBaseColors() {
	m.projectBaseColors = nil
	m.clearedprojectBaseColors = false
	m.removedprojectBaseColors = nil
}

// AddProjectLightColorIDs adds the "projectLightColors" edge to the ProjectLightColor entity by ids.
func (m *ColorMutation) AddProjectLightColorIDs(ids ...ulid.ID) {
	if m.projectLightColors == nil {
		m.projectLightColors = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.projectLightColors[ids[i]] = struct{}{}
	}
}

// ClearProjectLightColors clears the "projectLightColors" edge to the ProjectLightColor entity.
func (m *ColorMutation) ClearProjectLightColors() {
	m.clearedprojectLightColors = true
}

// ProjectLightColorsCleared reports if the "projectLightColors" edge to the ProjectLightColor entity was cleared.
func (m *ColorMutation) ProjectLightColorsCleared() bool {
	return m.clearedprojectLightColors
}

// RemoveProjectLightColorIDs removes the "projectLightColors" edge to the ProjectLightColor entity by IDs.
func (m *ColorMutation) RemoveProjectLightColorIDs(ids ...ulid.ID) {
	if m.removedprojectLightColors == nil {
		m.removedprojectLightColors = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.projectLightColors, ids[i])
		m.removedprojectLightColors[ids[i]] = struct{}{}
	}
}

// RemovedProjectLightColors returns the removed IDs of the "projectLightColors" edge to the ProjectLightColor entity.
func (m *ColorMutation) RemovedProjectLightColorsIDs() (ids []ulid.ID) {
	for id := range m.removedprojectLightColors {
		ids = append(ids, id)
	}
	return
}

// ProjectLightColorsIDs returns the "projectLightColors" edge IDs in the mutation.
func (m *ColorMutation) ProjectLightColorsIDs() (ids []ulid.ID) {
	for id := range m.projectLightColors {
		ids = append(ids, id)
	}
	return
}

// ResetProjectLightColors resets all changes to the "projectLightColors" edge.
func (m *ColorMutation) ResetProjectLightColors() {
	m.projectLightColors = nil
	m.clearedprojectLightColors = false
	m.removedprojectLightColors = nil
}

// AddTaskPriorityIDs adds the "taskPriorities" edge to the TaskPriority entity by ids.
func (m *ColorMutation) AddTaskPriorityIDs(ids ...ulid.ID) {
	if m.taskPriorities == nil {
		m.taskPriorities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.taskPriorities[ids[i]] = struct{}{}
	}
}

// ClearTaskPriorities clears the "taskPriorities" edge to the TaskPriority entity.
func (m *ColorMutation) ClearTaskPriorities() {
	m.clearedtaskPriorities = true
}

// TaskPrioritiesCleared reports if the "taskPriorities" edge to the TaskPriority entity was cleared.
func (m *ColorMutation) TaskPrioritiesCleared() bool {
	return m.clearedtaskPriorities
}

// RemoveTaskPriorityIDs removes the "taskPriorities" edge to the TaskPriority entity by IDs.
func (m *ColorMutation) RemoveTaskPriorityIDs(ids ...ulid.ID) {
	if m.removedtaskPriorities == nil {
		m.removedtaskPriorities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.taskPriorities, ids[i])
		m.removedtaskPriorities[ids[i]] = struct{}{}
	}
}

// RemovedTaskPriorities returns the removed IDs of the "taskPriorities" edge to the TaskPriority entity.
func (m *ColorMutation) RemovedTaskPrioritiesIDs() (ids []ulid.ID) {
	for id := range m.removedtaskPriorities {
		ids = append(ids, id)
	}
	return
}

// TaskPrioritiesIDs returns the "taskPriorities" edge IDs in the mutation.
func (m *ColorMutation) TaskPrioritiesIDs() (ids []ulid.ID) {
	for id := range m.taskPriorities {
		ids = append(ids, id)
	}
	return
}

// ResetTaskPriorities resets all changes to the "taskPriorities" edge.
func (m *ColorMutation) ResetTaskPriorities() {
	m.taskPriorities = nil
	m.clearedtaskPriorities = false
	m.removedtaskPriorities = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *ColorMutation) AddTagIDs(ids ...ulid.ID) {
	if m.tags == nil {
		m.tags = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *ColorMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *ColorMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *ColorMutation) RemoveTagIDs(ids ...ulid.ID) {
	if m.removedtags == nil {
		m.removedtags = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *ColorMutation) RemovedTagsIDs() (ids []ulid.ID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *ColorMutation) TagsIDs() (ids []ulid.ID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *ColorMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// Where appends a list predicates to the ColorMutation builder.
func (m *ColorMutation) Where(ps ...predicate.Color) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ColorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Color).
func (m *ColorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ColorMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, color.FieldName)
	}
	if m.color != nil {
		fields = append(fields, color.FieldColor)
	}
	if m.hex != nil {
		fields = append(fields, color.FieldHex)
	}
	if m.created_at != nil {
		fields = append(fields, color.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, color.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ColorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case color.FieldName:
		return m.Name()
	case color.FieldColor:
		return m.Color()
	case color.FieldHex:
		return m.Hex()
	case color.FieldCreatedAt:
		return m.CreatedAt()
	case color.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ColorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case color.FieldName:
		return m.OldName(ctx)
	case color.FieldColor:
		return m.OldColor(ctx)
	case color.FieldHex:
		return m.OldHex(ctx)
	case color.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case color.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Color field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ColorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case color.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case color.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case color.FieldHex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHex(v)
		return nil
	case color.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case color.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Color field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ColorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ColorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ColorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Color numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ColorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ColorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ColorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Color nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ColorMutation) ResetField(name string) error {
	switch name {
	case color.FieldName:
		m.ResetName()
		return nil
	case color.FieldColor:
		m.ResetColor()
		return nil
	case color.FieldHex:
		m.ResetHex()
		return nil
	case color.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case color.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Color field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ColorMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.projectBaseColors != nil {
		edges = append(edges, color.EdgeProjectBaseColors)
	}
	if m.projectLightColors != nil {
		edges = append(edges, color.EdgeProjectLightColors)
	}
	if m.taskPriorities != nil {
		edges = append(edges, color.EdgeTaskPriorities)
	}
	if m.tags != nil {
		edges = append(edges, color.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ColorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case color.EdgeProjectBaseColors:
		ids := make([]ent.Value, 0, len(m.projectBaseColors))
		for id := range m.projectBaseColors {
			ids = append(ids, id)
		}
		return ids
	case color.EdgeProjectLightColors:
		ids := make([]ent.Value, 0, len(m.projectLightColors))
		for id := range m.projectLightColors {
			ids = append(ids, id)
		}
		return ids
	case color.EdgeTaskPriorities:
		ids := make([]ent.Value, 0, len(m.taskPriorities))
		for id := range m.taskPriorities {
			ids = append(ids, id)
		}
		return ids
	case color.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ColorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedprojectBaseColors != nil {
		edges = append(edges, color.EdgeProjectBaseColors)
	}
	if m.removedprojectLightColors != nil {
		edges = append(edges, color.EdgeProjectLightColors)
	}
	if m.removedtaskPriorities != nil {
		edges = append(edges, color.EdgeTaskPriorities)
	}
	if m.removedtags != nil {
		edges = append(edges, color.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ColorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case color.EdgeProjectBaseColors:
		ids := make([]ent.Value, 0, len(m.removedprojectBaseColors))
		for id := range m.removedprojectBaseColors {
			ids = append(ids, id)
		}
		return ids
	case color.EdgeProjectLightColors:
		ids := make([]ent.Value, 0, len(m.removedprojectLightColors))
		for id := range m.removedprojectLightColors {
			ids = append(ids, id)
		}
		return ids
	case color.EdgeTaskPriorities:
		ids := make([]ent.Value, 0, len(m.removedtaskPriorities))
		for id := range m.removedtaskPriorities {
			ids = append(ids, id)
		}
		return ids
	case color.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ColorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedprojectBaseColors {
		edges = append(edges, color.EdgeProjectBaseColors)
	}
	if m.clearedprojectLightColors {
		edges = append(edges, color.EdgeProjectLightColors)
	}
	if m.clearedtaskPriorities {
		edges = append(edges, color.EdgeTaskPriorities)
	}
	if m.clearedtags {
		edges = append(edges, color.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ColorMutation) EdgeCleared(name string) bool {
	switch name {
	case color.EdgeProjectBaseColors:
		return m.clearedprojectBaseColors
	case color.EdgeProjectLightColors:
		return m.clearedprojectLightColors
	case color.EdgeTaskPriorities:
		return m.clearedtaskPriorities
	case color.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ColorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Color unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ColorMutation) ResetEdge(name string) error {
	switch name {
	case color.EdgeProjectBaseColors:
		m.ResetProjectBaseColors()
		return nil
	case color.EdgeProjectLightColors:
		m.ResetProjectLightColors()
		return nil
	case color.EdgeTaskPriorities:
		m.ResetTaskPriorities()
		return nil
	case color.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Color edge %s", name)
}

// DeletedTaskMutation represents an operation that mutates the DeletedTask nodes in the graph.
type DeletedTaskMutation struct {
	config
	op               Op
	typ              string
	id               *ulid.ID
	task_section_id  *ulid.ID
	task_join_id     *ulid.ID
	task_type        *deletedtask.TaskType
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	task             *ulid.ID
	clearedtask      bool
	workspace        *ulid.ID
	clearedworkspace bool
	done             bool
	oldValue         func(context.Context) (*DeletedTask, error)
	predicates       []predicate.DeletedTask
}

var _ ent.Mutation = (*DeletedTaskMutation)(nil)

// deletedtaskOption allows management of the mutation configuration using functional options.
type deletedtaskOption func(*DeletedTaskMutation)

// newDeletedTaskMutation creates new mutation for the DeletedTask entity.
func newDeletedTaskMutation(c config, op Op, opts ...deletedtaskOption) *DeletedTaskMutation {
	m := &DeletedTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeDeletedTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeletedTaskID sets the ID field of the mutation.
func withDeletedTaskID(id ulid.ID) deletedtaskOption {
	return func(m *DeletedTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *DeletedTask
		)
		m.oldValue = func(ctx context.Context) (*DeletedTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeletedTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeletedTask sets the old DeletedTask of the mutation.
func withDeletedTask(node *DeletedTask) deletedtaskOption {
	return func(m *DeletedTaskMutation) {
		m.oldValue = func(context.Context) (*DeletedTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeletedTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeletedTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeletedTask entities.
func (m *DeletedTaskMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeletedTaskMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeletedTaskMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeletedTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTaskID sets the "task_id" field.
func (m *DeletedTaskMutation) SetTaskID(u ulid.ID) {
	m.task = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *DeletedTaskMutation) TaskID() (r ulid.ID, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the DeletedTask entity.
// If the DeletedTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeletedTaskMutation) OldTaskID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *DeletedTaskMutation) ResetTaskID() {
	m.task = nil
}

// SetWorkspaceID sets the "workspace_id" field.
func (m *DeletedTaskMutation) SetWorkspaceID(u ulid.ID) {
	m.workspace = &u
}

// WorkspaceID returns the value of the "workspace_id" field in the mutation.
func (m *DeletedTaskMutation) WorkspaceID() (r ulid.ID, exists bool) {
	v := m.workspace
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspaceID returns the old "workspace_id" field's value of the DeletedTask entity.
// If the DeletedTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeletedTaskMutation) OldWorkspaceID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspaceID: %w", err)
	}
	return oldValue.WorkspaceID, nil
}

// ResetWorkspaceID resets all changes to the "workspace_id" field.
func (m *DeletedTaskMutation) ResetWorkspaceID() {
	m.workspace = nil
}

// SetTaskSectionID sets the "task_section_id" field.
func (m *DeletedTaskMutation) SetTaskSectionID(u ulid.ID) {
	m.task_section_id = &u
}

// TaskSectionID returns the value of the "task_section_id" field in the mutation.
func (m *DeletedTaskMutation) TaskSectionID() (r ulid.ID, exists bool) {
	v := m.task_section_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskSectionID returns the old "task_section_id" field's value of the DeletedTask entity.
// If the DeletedTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeletedTaskMutation) OldTaskSectionID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskSectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskSectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskSectionID: %w", err)
	}
	return oldValue.TaskSectionID, nil
}

// ResetTaskSectionID resets all changes to the "task_section_id" field.
func (m *DeletedTaskMutation) ResetTaskSectionID() {
	m.task_section_id = nil
}

// SetTaskJoinID sets the "task_join_id" field.
func (m *DeletedTaskMutation) SetTaskJoinID(u ulid.ID) {
	m.task_join_id = &u
}

// TaskJoinID returns the value of the "task_join_id" field in the mutation.
func (m *DeletedTaskMutation) TaskJoinID() (r ulid.ID, exists bool) {
	v := m.task_join_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskJoinID returns the old "task_join_id" field's value of the DeletedTask entity.
// If the DeletedTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeletedTaskMutation) OldTaskJoinID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskJoinID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskJoinID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskJoinID: %w", err)
	}
	return oldValue.TaskJoinID, nil
}

// ResetTaskJoinID resets all changes to the "task_join_id" field.
func (m *DeletedTaskMutation) ResetTaskJoinID() {
	m.task_join_id = nil
}

// SetTaskType sets the "task_type" field.
func (m *DeletedTaskMutation) SetTaskType(dt deletedtask.TaskType) {
	m.task_type = &dt
}

// TaskType returns the value of the "task_type" field in the mutation.
func (m *DeletedTaskMutation) TaskType() (r deletedtask.TaskType, exists bool) {
	v := m.task_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskType returns the old "task_type" field's value of the DeletedTask entity.
// If the DeletedTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeletedTaskMutation) OldTaskType(ctx context.Context) (v deletedtask.TaskType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskType: %w", err)
	}
	return oldValue.TaskType, nil
}

// ResetTaskType resets all changes to the "task_type" field.
func (m *DeletedTaskMutation) ResetTaskType() {
	m.task_type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeletedTaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeletedTaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeletedTask entity.
// If the DeletedTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeletedTaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeletedTaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeletedTaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeletedTaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeletedTask entity.
// If the DeletedTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeletedTaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeletedTaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTask clears the "task" edge to the Task entity.
func (m *DeletedTaskMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *DeletedTaskMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *DeletedTaskMutation) TaskIDs() (ids []ulid.ID) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *DeletedTaskMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// ClearWorkspace clears the "workspace" edge to the Workspace entity.
func (m *DeletedTaskMutation) ClearWorkspace() {
	m.clearedworkspace = true
}

// WorkspaceCleared reports if the "workspace" edge to the Workspace entity was cleared.
func (m *DeletedTaskMutation) WorkspaceCleared() bool {
	return m.clearedworkspace
}

// WorkspaceIDs returns the "workspace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkspaceID instead. It exists only for internal usage by the builders.
func (m *DeletedTaskMutation) WorkspaceIDs() (ids []ulid.ID) {
	if id := m.workspace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkspace resets all changes to the "workspace" edge.
func (m *DeletedTaskMutation) ResetWorkspace() {
	m.workspace = nil
	m.clearedworkspace = false
}

// Where appends a list predicates to the DeletedTaskMutation builder.
func (m *DeletedTaskMutation) Where(ps ...predicate.DeletedTask) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DeletedTaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DeletedTask).
func (m *DeletedTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeletedTaskMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.task != nil {
		fields = append(fields, deletedtask.FieldTaskID)
	}
	if m.workspace != nil {
		fields = append(fields, deletedtask.FieldWorkspaceID)
	}
	if m.task_section_id != nil {
		fields = append(fields, deletedtask.FieldTaskSectionID)
	}
	if m.task_join_id != nil {
		fields = append(fields, deletedtask.FieldTaskJoinID)
	}
	if m.task_type != nil {
		fields = append(fields, deletedtask.FieldTaskType)
	}
	if m.created_at != nil {
		fields = append(fields, deletedtask.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, deletedtask.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeletedTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deletedtask.FieldTaskID:
		return m.TaskID()
	case deletedtask.FieldWorkspaceID:
		return m.WorkspaceID()
	case deletedtask.FieldTaskSectionID:
		return m.TaskSectionID()
	case deletedtask.FieldTaskJoinID:
		return m.TaskJoinID()
	case deletedtask.FieldTaskType:
		return m.TaskType()
	case deletedtask.FieldCreatedAt:
		return m.CreatedAt()
	case deletedtask.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeletedTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deletedtask.FieldTaskID:
		return m.OldTaskID(ctx)
	case deletedtask.FieldWorkspaceID:
		return m.OldWorkspaceID(ctx)
	case deletedtask.FieldTaskSectionID:
		return m.OldTaskSectionID(ctx)
	case deletedtask.FieldTaskJoinID:
		return m.OldTaskJoinID(ctx)
	case deletedtask.FieldTaskType:
		return m.OldTaskType(ctx)
	case deletedtask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deletedtask.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DeletedTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeletedTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deletedtask.FieldTaskID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case deletedtask.FieldWorkspaceID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspaceID(v)
		return nil
	case deletedtask.FieldTaskSectionID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskSectionID(v)
		return nil
	case deletedtask.FieldTaskJoinID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskJoinID(v)
		return nil
	case deletedtask.FieldTaskType:
		v, ok := value.(deletedtask.TaskType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskType(v)
		return nil
	case deletedtask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deletedtask.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DeletedTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeletedTaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeletedTaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeletedTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeletedTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeletedTaskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeletedTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeletedTaskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeletedTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeletedTaskMutation) ResetField(name string) error {
	switch name {
	case deletedtask.FieldTaskID:
		m.ResetTaskID()
		return nil
	case deletedtask.FieldWorkspaceID:
		m.ResetWorkspaceID()
		return nil
	case deletedtask.FieldTaskSectionID:
		m.ResetTaskSectionID()
		return nil
	case deletedtask.FieldTaskJoinID:
		m.ResetTaskJoinID()
		return nil
	case deletedtask.FieldTaskType:
		m.ResetTaskType()
		return nil
	case deletedtask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deletedtask.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown DeletedTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeletedTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.task != nil {
		edges = append(edges, deletedtask.EdgeTask)
	}
	if m.workspace != nil {
		edges = append(edges, deletedtask.EdgeWorkspace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeletedTaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deletedtask.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case deletedtask.EdgeWorkspace:
		if id := m.workspace; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeletedTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeletedTaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeletedTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtask {
		edges = append(edges, deletedtask.EdgeTask)
	}
	if m.clearedworkspace {
		edges = append(edges, deletedtask.EdgeWorkspace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeletedTaskMutation) EdgeCleared(name string) bool {
	switch name {
	case deletedtask.EdgeTask:
		return m.clearedtask
	case deletedtask.EdgeWorkspace:
		return m.clearedworkspace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeletedTaskMutation) ClearEdge(name string) error {
	switch name {
	case deletedtask.EdgeTask:
		m.ClearTask()
		return nil
	case deletedtask.EdgeWorkspace:
		m.ClearWorkspace()
		return nil
	}
	return fmt.Errorf("unknown DeletedTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeletedTaskMutation) ResetEdge(name string) error {
	switch name {
	case deletedtask.EdgeTask:
		m.ResetTask()
		return nil
	case deletedtask.EdgeWorkspace:
		m.ResetWorkspace()
		return nil
	}
	return fmt.Errorf("unknown DeletedTask edge %s", name)
}

// FavoriteProjectMutation represents an operation that mutates the FavoriteProject nodes in the graph.
type FavoriteProjectMutation struct {
	config
	op              Op
	typ             string
	id              *ulid.ID
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	project         *ulid.ID
	clearedproject  bool
	teammate        *ulid.ID
	clearedteammate bool
	done            bool
	oldValue        func(context.Context) (*FavoriteProject, error)
	predicates      []predicate.FavoriteProject
}

var _ ent.Mutation = (*FavoriteProjectMutation)(nil)

// favoriteprojectOption allows management of the mutation configuration using functional options.
type favoriteprojectOption func(*FavoriteProjectMutation)

// newFavoriteProjectMutation creates new mutation for the FavoriteProject entity.
func newFavoriteProjectMutation(c config, op Op, opts ...favoriteprojectOption) *FavoriteProjectMutation {
	m := &FavoriteProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeFavoriteProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFavoriteProjectID sets the ID field of the mutation.
func withFavoriteProjectID(id ulid.ID) favoriteprojectOption {
	return func(m *FavoriteProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *FavoriteProject
		)
		m.oldValue = func(ctx context.Context) (*FavoriteProject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FavoriteProject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFavoriteProject sets the old FavoriteProject of the mutation.
func withFavoriteProject(node *FavoriteProject) favoriteprojectOption {
	return func(m *FavoriteProjectMutation) {
		m.oldValue = func(context.Context) (*FavoriteProject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FavoriteProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FavoriteProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FavoriteProject entities.
func (m *FavoriteProjectMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FavoriteProjectMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FavoriteProjectMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FavoriteProject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectID sets the "project_id" field.
func (m *FavoriteProjectMutation) SetProjectID(u ulid.ID) {
	m.project = &u
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *FavoriteProjectMutation) ProjectID() (r ulid.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the FavoriteProject entity.
// If the FavoriteProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FavoriteProjectMutation) OldProjectID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *FavoriteProjectMutation) ResetProjectID() {
	m.project = nil
}

// SetTeammateID sets the "teammate_id" field.
func (m *FavoriteProjectMutation) SetTeammateID(u ulid.ID) {
	m.teammate = &u
}

// TeammateID returns the value of the "teammate_id" field in the mutation.
func (m *FavoriteProjectMutation) TeammateID() (r ulid.ID, exists bool) {
	v := m.teammate
	if v == nil {
		return
	}
	return *v, true
}

// OldTeammateID returns the old "teammate_id" field's value of the FavoriteProject entity.
// If the FavoriteProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FavoriteProjectMutation) OldTeammateID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeammateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeammateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeammateID: %w", err)
	}
	return oldValue.TeammateID, nil
}

// ResetTeammateID resets all changes to the "teammate_id" field.
func (m *FavoriteProjectMutation) ResetTeammateID() {
	m.teammate = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FavoriteProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FavoriteProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FavoriteProject entity.
// If the FavoriteProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FavoriteProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FavoriteProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FavoriteProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FavoriteProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FavoriteProject entity.
// If the FavoriteProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FavoriteProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FavoriteProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *FavoriteProjectMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *FavoriteProjectMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *FavoriteProjectMutation) ProjectIDs() (ids []ulid.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *FavoriteProjectMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearTeammate clears the "teammate" edge to the Teammate entity.
func (m *FavoriteProjectMutation) ClearTeammate() {
	m.clearedteammate = true
}

// TeammateCleared reports if the "teammate" edge to the Teammate entity was cleared.
func (m *FavoriteProjectMutation) TeammateCleared() bool {
	return m.clearedteammate
}

// TeammateIDs returns the "teammate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeammateID instead. It exists only for internal usage by the builders.
func (m *FavoriteProjectMutation) TeammateIDs() (ids []ulid.ID) {
	if id := m.teammate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeammate resets all changes to the "teammate" edge.
func (m *FavoriteProjectMutation) ResetTeammate() {
	m.teammate = nil
	m.clearedteammate = false
}

// Where appends a list predicates to the FavoriteProjectMutation builder.
func (m *FavoriteProjectMutation) Where(ps ...predicate.FavoriteProject) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FavoriteProjectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FavoriteProject).
func (m *FavoriteProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FavoriteProjectMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.project != nil {
		fields = append(fields, favoriteproject.FieldProjectID)
	}
	if m.teammate != nil {
		fields = append(fields, favoriteproject.FieldTeammateID)
	}
	if m.created_at != nil {
		fields = append(fields, favoriteproject.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, favoriteproject.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FavoriteProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case favoriteproject.FieldProjectID:
		return m.ProjectID()
	case favoriteproject.FieldTeammateID:
		return m.TeammateID()
	case favoriteproject.FieldCreatedAt:
		return m.CreatedAt()
	case favoriteproject.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FavoriteProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case favoriteproject.FieldProjectID:
		return m.OldProjectID(ctx)
	case favoriteproject.FieldTeammateID:
		return m.OldTeammateID(ctx)
	case favoriteproject.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case favoriteproject.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FavoriteProject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FavoriteProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case favoriteproject.FieldProjectID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case favoriteproject.FieldTeammateID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeammateID(v)
		return nil
	case favoriteproject.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case favoriteproject.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FavoriteProject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FavoriteProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FavoriteProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FavoriteProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FavoriteProject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FavoriteProjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FavoriteProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FavoriteProjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FavoriteProject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FavoriteProjectMutation) ResetField(name string) error {
	switch name {
	case favoriteproject.FieldProjectID:
		m.ResetProjectID()
		return nil
	case favoriteproject.FieldTeammateID:
		m.ResetTeammateID()
		return nil
	case favoriteproject.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case favoriteproject.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown FavoriteProject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FavoriteProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, favoriteproject.EdgeProject)
	}
	if m.teammate != nil {
		edges = append(edges, favoriteproject.EdgeTeammate)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FavoriteProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case favoriteproject.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case favoriteproject.EdgeTeammate:
		if id := m.teammate; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FavoriteProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FavoriteProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FavoriteProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, favoriteproject.EdgeProject)
	}
	if m.clearedteammate {
		edges = append(edges, favoriteproject.EdgeTeammate)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FavoriteProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case favoriteproject.EdgeProject:
		return m.clearedproject
	case favoriteproject.EdgeTeammate:
		return m.clearedteammate
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FavoriteProjectMutation) ClearEdge(name string) error {
	switch name {
	case favoriteproject.EdgeProject:
		m.ClearProject()
		return nil
	case favoriteproject.EdgeTeammate:
		m.ClearTeammate()
		return nil
	}
	return fmt.Errorf("unknown FavoriteProject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FavoriteProjectMutation) ResetEdge(name string) error {
	switch name {
	case favoriteproject.EdgeProject:
		m.ResetProject()
		return nil
	case favoriteproject.EdgeTeammate:
		m.ResetTeammate()
		return nil
	}
	return fmt.Errorf("unknown FavoriteProject edge %s", name)
}

// FavoriteWorkspaceMutation represents an operation that mutates the FavoriteWorkspace nodes in the graph.
type FavoriteWorkspaceMutation struct {
	config
	op               Op
	typ              string
	id               *ulid.ID
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	workspace        *ulid.ID
	clearedworkspace bool
	teammate         *ulid.ID
	clearedteammate  bool
	done             bool
	oldValue         func(context.Context) (*FavoriteWorkspace, error)
	predicates       []predicate.FavoriteWorkspace
}

var _ ent.Mutation = (*FavoriteWorkspaceMutation)(nil)

// favoriteworkspaceOption allows management of the mutation configuration using functional options.
type favoriteworkspaceOption func(*FavoriteWorkspaceMutation)

// newFavoriteWorkspaceMutation creates new mutation for the FavoriteWorkspace entity.
func newFavoriteWorkspaceMutation(c config, op Op, opts ...favoriteworkspaceOption) *FavoriteWorkspaceMutation {
	m := &FavoriteWorkspaceMutation{
		config:        c,
		op:            op,
		typ:           TypeFavoriteWorkspace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFavoriteWorkspaceID sets the ID field of the mutation.
func withFavoriteWorkspaceID(id ulid.ID) favoriteworkspaceOption {
	return func(m *FavoriteWorkspaceMutation) {
		var (
			err   error
			once  sync.Once
			value *FavoriteWorkspace
		)
		m.oldValue = func(ctx context.Context) (*FavoriteWorkspace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FavoriteWorkspace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFavoriteWorkspace sets the old FavoriteWorkspace of the mutation.
func withFavoriteWorkspace(node *FavoriteWorkspace) favoriteworkspaceOption {
	return func(m *FavoriteWorkspaceMutation) {
		m.oldValue = func(context.Context) (*FavoriteWorkspace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FavoriteWorkspaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FavoriteWorkspaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FavoriteWorkspace entities.
func (m *FavoriteWorkspaceMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FavoriteWorkspaceMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FavoriteWorkspaceMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FavoriteWorkspace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkspaceID sets the "workspace_id" field.
func (m *FavoriteWorkspaceMutation) SetWorkspaceID(u ulid.ID) {
	m.workspace = &u
}

// WorkspaceID returns the value of the "workspace_id" field in the mutation.
func (m *FavoriteWorkspaceMutation) WorkspaceID() (r ulid.ID, exists bool) {
	v := m.workspace
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspaceID returns the old "workspace_id" field's value of the FavoriteWorkspace entity.
// If the FavoriteWorkspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FavoriteWorkspaceMutation) OldWorkspaceID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspaceID: %w", err)
	}
	return oldValue.WorkspaceID, nil
}

// ResetWorkspaceID resets all changes to the "workspace_id" field.
func (m *FavoriteWorkspaceMutation) ResetWorkspaceID() {
	m.workspace = nil
}

// SetTeammateID sets the "teammate_id" field.
func (m *FavoriteWorkspaceMutation) SetTeammateID(u ulid.ID) {
	m.teammate = &u
}

// TeammateID returns the value of the "teammate_id" field in the mutation.
func (m *FavoriteWorkspaceMutation) TeammateID() (r ulid.ID, exists bool) {
	v := m.teammate
	if v == nil {
		return
	}
	return *v, true
}

// OldTeammateID returns the old "teammate_id" field's value of the FavoriteWorkspace entity.
// If the FavoriteWorkspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FavoriteWorkspaceMutation) OldTeammateID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeammateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeammateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeammateID: %w", err)
	}
	return oldValue.TeammateID, nil
}

// ResetTeammateID resets all changes to the "teammate_id" field.
func (m *FavoriteWorkspaceMutation) ResetTeammateID() {
	m.teammate = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FavoriteWorkspaceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FavoriteWorkspaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FavoriteWorkspace entity.
// If the FavoriteWorkspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FavoriteWorkspaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FavoriteWorkspaceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FavoriteWorkspaceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FavoriteWorkspaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FavoriteWorkspace entity.
// If the FavoriteWorkspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FavoriteWorkspaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FavoriteWorkspaceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearWorkspace clears the "workspace" edge to the Workspace entity.
func (m *FavoriteWorkspaceMutation) ClearWorkspace() {
	m.clearedworkspace = true
}

// WorkspaceCleared reports if the "workspace" edge to the Workspace entity was cleared.
func (m *FavoriteWorkspaceMutation) WorkspaceCleared() bool {
	return m.clearedworkspace
}

// WorkspaceIDs returns the "workspace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkspaceID instead. It exists only for internal usage by the builders.
func (m *FavoriteWorkspaceMutation) WorkspaceIDs() (ids []ulid.ID) {
	if id := m.workspace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkspace resets all changes to the "workspace" edge.
func (m *FavoriteWorkspaceMutation) ResetWorkspace() {
	m.workspace = nil
	m.clearedworkspace = false
}

// ClearTeammate clears the "teammate" edge to the Teammate entity.
func (m *FavoriteWorkspaceMutation) ClearTeammate() {
	m.clearedteammate = true
}

// TeammateCleared reports if the "teammate" edge to the Teammate entity was cleared.
func (m *FavoriteWorkspaceMutation) TeammateCleared() bool {
	return m.clearedteammate
}

// TeammateIDs returns the "teammate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeammateID instead. It exists only for internal usage by the builders.
func (m *FavoriteWorkspaceMutation) TeammateIDs() (ids []ulid.ID) {
	if id := m.teammate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeammate resets all changes to the "teammate" edge.
func (m *FavoriteWorkspaceMutation) ResetTeammate() {
	m.teammate = nil
	m.clearedteammate = false
}

// Where appends a list predicates to the FavoriteWorkspaceMutation builder.
func (m *FavoriteWorkspaceMutation) Where(ps ...predicate.FavoriteWorkspace) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FavoriteWorkspaceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FavoriteWorkspace).
func (m *FavoriteWorkspaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FavoriteWorkspaceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.workspace != nil {
		fields = append(fields, favoriteworkspace.FieldWorkspaceID)
	}
	if m.teammate != nil {
		fields = append(fields, favoriteworkspace.FieldTeammateID)
	}
	if m.created_at != nil {
		fields = append(fields, favoriteworkspace.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, favoriteworkspace.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FavoriteWorkspaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case favoriteworkspace.FieldWorkspaceID:
		return m.WorkspaceID()
	case favoriteworkspace.FieldTeammateID:
		return m.TeammateID()
	case favoriteworkspace.FieldCreatedAt:
		return m.CreatedAt()
	case favoriteworkspace.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FavoriteWorkspaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case favoriteworkspace.FieldWorkspaceID:
		return m.OldWorkspaceID(ctx)
	case favoriteworkspace.FieldTeammateID:
		return m.OldTeammateID(ctx)
	case favoriteworkspace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case favoriteworkspace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FavoriteWorkspace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FavoriteWorkspaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case favoriteworkspace.FieldWorkspaceID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspaceID(v)
		return nil
	case favoriteworkspace.FieldTeammateID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeammateID(v)
		return nil
	case favoriteworkspace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case favoriteworkspace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FavoriteWorkspace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FavoriteWorkspaceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FavoriteWorkspaceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FavoriteWorkspaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FavoriteWorkspace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FavoriteWorkspaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FavoriteWorkspaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FavoriteWorkspaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FavoriteWorkspace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FavoriteWorkspaceMutation) ResetField(name string) error {
	switch name {
	case favoriteworkspace.FieldWorkspaceID:
		m.ResetWorkspaceID()
		return nil
	case favoriteworkspace.FieldTeammateID:
		m.ResetTeammateID()
		return nil
	case favoriteworkspace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case favoriteworkspace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown FavoriteWorkspace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FavoriteWorkspaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.workspace != nil {
		edges = append(edges, favoriteworkspace.EdgeWorkspace)
	}
	if m.teammate != nil {
		edges = append(edges, favoriteworkspace.EdgeTeammate)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FavoriteWorkspaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case favoriteworkspace.EdgeWorkspace:
		if id := m.workspace; id != nil {
			return []ent.Value{*id}
		}
	case favoriteworkspace.EdgeTeammate:
		if id := m.teammate; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FavoriteWorkspaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FavoriteWorkspaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FavoriteWorkspaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedworkspace {
		edges = append(edges, favoriteworkspace.EdgeWorkspace)
	}
	if m.clearedteammate {
		edges = append(edges, favoriteworkspace.EdgeTeammate)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FavoriteWorkspaceMutation) EdgeCleared(name string) bool {
	switch name {
	case favoriteworkspace.EdgeWorkspace:
		return m.clearedworkspace
	case favoriteworkspace.EdgeTeammate:
		return m.clearedteammate
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FavoriteWorkspaceMutation) ClearEdge(name string) error {
	switch name {
	case favoriteworkspace.EdgeWorkspace:
		m.ClearWorkspace()
		return nil
	case favoriteworkspace.EdgeTeammate:
		m.ClearTeammate()
		return nil
	}
	return fmt.Errorf("unknown FavoriteWorkspace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FavoriteWorkspaceMutation) ResetEdge(name string) error {
	switch name {
	case favoriteworkspace.EdgeWorkspace:
		m.ResetWorkspace()
		return nil
	case favoriteworkspace.EdgeTeammate:
		m.ResetTeammate()
		return nil
	}
	return fmt.Errorf("unknown FavoriteWorkspace edge %s", name)
}

// FileTypeMutation represents an operation that mutates the FileType nodes in the graph.
type FileTypeMutation struct {
	config
	op               Op
	typ              string
	id               *ulid.ID
	name             *string
	type_code        *filetype.TypeCode
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	taskFiles        map[ulid.ID]struct{}
	removedtaskFiles map[ulid.ID]struct{}
	clearedtaskFiles bool
	done             bool
	oldValue         func(context.Context) (*FileType, error)
	predicates       []predicate.FileType
}

var _ ent.Mutation = (*FileTypeMutation)(nil)

// filetypeOption allows management of the mutation configuration using functional options.
type filetypeOption func(*FileTypeMutation)

// newFileTypeMutation creates new mutation for the FileType entity.
func newFileTypeMutation(c config, op Op, opts ...filetypeOption) *FileTypeMutation {
	m := &FileTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeFileType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileTypeID sets the ID field of the mutation.
func withFileTypeID(id ulid.ID) filetypeOption {
	return func(m *FileTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *FileType
		)
		m.oldValue = func(ctx context.Context) (*FileType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileType sets the old FileType of the mutation.
func withFileType(node *FileType) filetypeOption {
	return func(m *FileTypeMutation) {
		m.oldValue = func(context.Context) (*FileType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FileType entities.
func (m *FileTypeMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileTypeMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileTypeMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FileType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *FileTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FileTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FileType entity.
// If the FileType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FileTypeMutation) ResetName() {
	m.name = nil
}

// SetTypeCode sets the "type_code" field.
func (m *FileTypeMutation) SetTypeCode(fc filetype.TypeCode) {
	m.type_code = &fc
}

// TypeCode returns the value of the "type_code" field in the mutation.
func (m *FileTypeMutation) TypeCode() (r filetype.TypeCode, exists bool) {
	v := m.type_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeCode returns the old "type_code" field's value of the FileType entity.
// If the FileType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileTypeMutation) OldTypeCode(ctx context.Context) (v filetype.TypeCode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeCode: %w", err)
	}
	return oldValue.TypeCode, nil
}

// ResetTypeCode resets all changes to the "type_code" field.
func (m *FileTypeMutation) ResetTypeCode() {
	m.type_code = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FileTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FileType entity.
// If the FileType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FileType entity.
// If the FileType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddTaskFileIDs adds the "taskFiles" edge to the TaskFile entity by ids.
func (m *FileTypeMutation) AddTaskFileIDs(ids ...ulid.ID) {
	if m.taskFiles == nil {
		m.taskFiles = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.taskFiles[ids[i]] = struct{}{}
	}
}

// ClearTaskFiles clears the "taskFiles" edge to the TaskFile entity.
func (m *FileTypeMutation) ClearTaskFiles() {
	m.clearedtaskFiles = true
}

// TaskFilesCleared reports if the "taskFiles" edge to the TaskFile entity was cleared.
func (m *FileTypeMutation) TaskFilesCleared() bool {
	return m.clearedtaskFiles
}

// RemoveTaskFileIDs removes the "taskFiles" edge to the TaskFile entity by IDs.
func (m *FileTypeMutation) RemoveTaskFileIDs(ids ...ulid.ID) {
	if m.removedtaskFiles == nil {
		m.removedtaskFiles = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.taskFiles, ids[i])
		m.removedtaskFiles[ids[i]] = struct{}{}
	}
}

// RemovedTaskFiles returns the removed IDs of the "taskFiles" edge to the TaskFile entity.
func (m *FileTypeMutation) RemovedTaskFilesIDs() (ids []ulid.ID) {
	for id := range m.removedtaskFiles {
		ids = append(ids, id)
	}
	return
}

// TaskFilesIDs returns the "taskFiles" edge IDs in the mutation.
func (m *FileTypeMutation) TaskFilesIDs() (ids []ulid.ID) {
	for id := range m.taskFiles {
		ids = append(ids, id)
	}
	return
}

// ResetTaskFiles resets all changes to the "taskFiles" edge.
func (m *FileTypeMutation) ResetTaskFiles() {
	m.taskFiles = nil
	m.clearedtaskFiles = false
	m.removedtaskFiles = nil
}

// Where appends a list predicates to the FileTypeMutation builder.
func (m *FileTypeMutation) Where(ps ...predicate.FileType) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FileTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FileType).
func (m *FileTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, filetype.FieldName)
	}
	if m.type_code != nil {
		fields = append(fields, filetype.FieldTypeCode)
	}
	if m.created_at != nil {
		fields = append(fields, filetype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, filetype.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filetype.FieldName:
		return m.Name()
	case filetype.FieldTypeCode:
		return m.TypeCode()
	case filetype.FieldCreatedAt:
		return m.CreatedAt()
	case filetype.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filetype.FieldName:
		return m.OldName(ctx)
	case filetype.FieldTypeCode:
		return m.OldTypeCode(ctx)
	case filetype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case filetype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FileType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filetype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case filetype.FieldTypeCode:
		v, ok := value.(filetype.TypeCode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeCode(v)
		return nil
	case filetype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case filetype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FileType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FileType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FileType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileTypeMutation) ResetField(name string) error {
	switch name {
	case filetype.FieldName:
		m.ResetName()
		return nil
	case filetype.FieldTypeCode:
		m.ResetTypeCode()
		return nil
	case filetype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case filetype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown FileType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.taskFiles != nil {
		edges = append(edges, filetype.EdgeTaskFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case filetype.EdgeTaskFiles:
		ids := make([]ent.Value, 0, len(m.taskFiles))
		for id := range m.taskFiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtaskFiles != nil {
		edges = append(edges, filetype.EdgeTaskFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case filetype.EdgeTaskFiles:
		ids := make([]ent.Value, 0, len(m.removedtaskFiles))
		for id := range m.removedtaskFiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtaskFiles {
		edges = append(edges, filetype.EdgeTaskFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case filetype.EdgeTaskFiles:
		return m.clearedtaskFiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown FileType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileTypeMutation) ResetEdge(name string) error {
	switch name {
	case filetype.EdgeTaskFiles:
		m.ResetTaskFiles()
		return nil
	}
	return fmt.Errorf("unknown FileType edge %s", name)
}

// IconMutation represents an operation that mutates the Icon nodes in the graph.
type IconMutation struct {
	config
	op                  Op
	typ                 string
	id                  *ulid.ID
	name                *string
	icon                *string
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	projectIcons        map[ulid.ID]struct{}
	removedprojectIcons map[ulid.ID]struct{}
	clearedprojectIcons bool
	done                bool
	oldValue            func(context.Context) (*Icon, error)
	predicates          []predicate.Icon
}

var _ ent.Mutation = (*IconMutation)(nil)

// iconOption allows management of the mutation configuration using functional options.
type iconOption func(*IconMutation)

// newIconMutation creates new mutation for the Icon entity.
func newIconMutation(c config, op Op, opts ...iconOption) *IconMutation {
	m := &IconMutation{
		config:        c,
		op:            op,
		typ:           TypeIcon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIconID sets the ID field of the mutation.
func withIconID(id ulid.ID) iconOption {
	return func(m *IconMutation) {
		var (
			err   error
			once  sync.Once
			value *Icon
		)
		m.oldValue = func(ctx context.Context) (*Icon, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Icon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIcon sets the old Icon of the mutation.
func withIcon(node *Icon) iconOption {
	return func(m *IconMutation) {
		m.oldValue = func(context.Context) (*Icon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IconMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IconMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Icon entities.
func (m *IconMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IconMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IconMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Icon.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *IconMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IconMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Icon entity.
// If the Icon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IconMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IconMutation) ResetName() {
	m.name = nil
}

// SetIcon sets the "icon" field.
func (m *IconMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *IconMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Icon entity.
// If the Icon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IconMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ResetIcon resets all changes to the "icon" field.
func (m *IconMutation) ResetIcon() {
	m.icon = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IconMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IconMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Icon entity.
// If the Icon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IconMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IconMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IconMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IconMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Icon entity.
// If the Icon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IconMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IconMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddProjectIconIDs adds the "projectIcons" edge to the ProjectIcon entity by ids.
func (m *IconMutation) AddProjectIconIDs(ids ...ulid.ID) {
	if m.projectIcons == nil {
		m.projectIcons = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.projectIcons[ids[i]] = struct{}{}
	}
}

// ClearProjectIcons clears the "projectIcons" edge to the ProjectIcon entity.
func (m *IconMutation) ClearProjectIcons() {
	m.clearedprojectIcons = true
}

// ProjectIconsCleared reports if the "projectIcons" edge to the ProjectIcon entity was cleared.
func (m *IconMutation) ProjectIconsCleared() bool {
	return m.clearedprojectIcons
}

// RemoveProjectIconIDs removes the "projectIcons" edge to the ProjectIcon entity by IDs.
func (m *IconMutation) RemoveProjectIconIDs(ids ...ulid.ID) {
	if m.removedprojectIcons == nil {
		m.removedprojectIcons = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.projectIcons, ids[i])
		m.removedprojectIcons[ids[i]] = struct{}{}
	}
}

// RemovedProjectIcons returns the removed IDs of the "projectIcons" edge to the ProjectIcon entity.
func (m *IconMutation) RemovedProjectIconsIDs() (ids []ulid.ID) {
	for id := range m.removedprojectIcons {
		ids = append(ids, id)
	}
	return
}

// ProjectIconsIDs returns the "projectIcons" edge IDs in the mutation.
func (m *IconMutation) ProjectIconsIDs() (ids []ulid.ID) {
	for id := range m.projectIcons {
		ids = append(ids, id)
	}
	return
}

// ResetProjectIcons resets all changes to the "projectIcons" edge.
func (m *IconMutation) ResetProjectIcons() {
	m.projectIcons = nil
	m.clearedprojectIcons = false
	m.removedprojectIcons = nil
}

// Where appends a list predicates to the IconMutation builder.
func (m *IconMutation) Where(ps ...predicate.Icon) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *IconMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Icon).
func (m *IconMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IconMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, icon.FieldName)
	}
	if m.icon != nil {
		fields = append(fields, icon.FieldIcon)
	}
	if m.created_at != nil {
		fields = append(fields, icon.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, icon.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IconMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case icon.FieldName:
		return m.Name()
	case icon.FieldIcon:
		return m.Icon()
	case icon.FieldCreatedAt:
		return m.CreatedAt()
	case icon.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IconMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case icon.FieldName:
		return m.OldName(ctx)
	case icon.FieldIcon:
		return m.OldIcon(ctx)
	case icon.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case icon.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Icon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IconMutation) SetField(name string, value ent.Value) error {
	switch name {
	case icon.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case icon.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case icon.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case icon.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Icon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IconMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IconMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IconMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Icon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IconMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IconMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IconMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Icon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IconMutation) ResetField(name string) error {
	switch name {
	case icon.FieldName:
		m.ResetName()
		return nil
	case icon.FieldIcon:
		m.ResetIcon()
		return nil
	case icon.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case icon.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Icon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IconMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.projectIcons != nil {
		edges = append(edges, icon.EdgeProjectIcons)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IconMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case icon.EdgeProjectIcons:
		ids := make([]ent.Value, 0, len(m.projectIcons))
		for id := range m.projectIcons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IconMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprojectIcons != nil {
		edges = append(edges, icon.EdgeProjectIcons)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IconMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case icon.EdgeProjectIcons:
		ids := make([]ent.Value, 0, len(m.removedprojectIcons))
		for id := range m.removedprojectIcons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IconMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprojectIcons {
		edges = append(edges, icon.EdgeProjectIcons)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IconMutation) EdgeCleared(name string) bool {
	switch name {
	case icon.EdgeProjectIcons:
		return m.clearedprojectIcons
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IconMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Icon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IconMutation) ResetEdge(name string) error {
	switch name {
	case icon.EdgeProjectIcons:
		m.ResetProjectIcons()
		return nil
	}
	return fmt.Errorf("unknown Icon edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *ulid.ID
	name                               *string
	description                        *map[string]interface{}
	description_title                  *string
	due_date                           *time.Time
	created_at                         *time.Time
	updated_at                         *time.Time
	clearedFields                      map[string]struct{}
	workspace                          *ulid.ID
	clearedworkspace                   bool
	projectBaseColor                   *ulid.ID
	clearedprojectBaseColor            bool
	projectLightColor                  *ulid.ID
	clearedprojectLightColor           bool
	projectIcon                        *ulid.ID
	clearedprojectIcon                 bool
	teammate                           *ulid.ID
	clearedteammate                    bool
	projectTeammates                   map[ulid.ID]struct{}
	removedprojectTeammates            map[ulid.ID]struct{}
	clearedprojectTeammates            bool
	favoriteProjects                   map[ulid.ID]struct{}
	removedfavoriteProjects            map[ulid.ID]struct{}
	clearedfavoriteProjects            bool
	projectTaskColumns                 map[ulid.ID]struct{}
	removedprojectTaskColumns          map[ulid.ID]struct{}
	clearedprojectTaskColumns          bool
	projectTaskListStatuses            map[ulid.ID]struct{}
	removedprojectTaskListStatuses     map[ulid.ID]struct{}
	clearedprojectTaskListStatuses     bool
	projectTaskSections                map[ulid.ID]struct{}
	removedprojectTaskSections         map[ulid.ID]struct{}
	clearedprojectTaskSections         bool
	projectTasks                       map[ulid.ID]struct{}
	removedprojectTasks                map[ulid.ID]struct{}
	clearedprojectTasks                bool
	taskFiles                          map[ulid.ID]struct{}
	removedtaskFiles                   map[ulid.ID]struct{}
	clearedtaskFiles                   bool
	workspaceActivities                map[ulid.ID]struct{}
	removedworkspaceActivities         map[ulid.ID]struct{}
	clearedworkspaceActivities         bool
	archivedWorkspaceActivities        map[ulid.ID]struct{}
	removedarchivedWorkspaceActivities map[ulid.ID]struct{}
	clearedarchivedWorkspaceActivities bool
	done                               bool
	oldValue                           func(context.Context) (*Project, error)
	predicates                         []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id ulid.ID) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Project entities.
func (m *ProjectMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkspaceID sets the "workspace_id" field.
func (m *ProjectMutation) SetWorkspaceID(u ulid.ID) {
	m.workspace = &u
}

// WorkspaceID returns the value of the "workspace_id" field in the mutation.
func (m *ProjectMutation) WorkspaceID() (r ulid.ID, exists bool) {
	v := m.workspace
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspaceID returns the old "workspace_id" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldWorkspaceID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspaceID: %w", err)
	}
	return oldValue.WorkspaceID, nil
}

// ResetWorkspaceID resets all changes to the "workspace_id" field.
func (m *ProjectMutation) ResetWorkspaceID() {
	m.workspace = nil
}

// SetProjectBaseColorID sets the "project_base_color_id" field.
func (m *ProjectMutation) SetProjectBaseColorID(u ulid.ID) {
	m.projectBaseColor = &u
}

// ProjectBaseColorID returns the value of the "project_base_color_id" field in the mutation.
func (m *ProjectMutation) ProjectBaseColorID() (r ulid.ID, exists bool) {
	v := m.projectBaseColor
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectBaseColorID returns the old "project_base_color_id" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldProjectBaseColorID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectBaseColorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectBaseColorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectBaseColorID: %w", err)
	}
	return oldValue.ProjectBaseColorID, nil
}

// ResetProjectBaseColorID resets all changes to the "project_base_color_id" field.
func (m *ProjectMutation) ResetProjectBaseColorID() {
	m.projectBaseColor = nil
}

// SetProjectLightColorID sets the "project_light_color_id" field.
func (m *ProjectMutation) SetProjectLightColorID(u ulid.ID) {
	m.projectLightColor = &u
}

// ProjectLightColorID returns the value of the "project_light_color_id" field in the mutation.
func (m *ProjectMutation) ProjectLightColorID() (r ulid.ID, exists bool) {
	v := m.projectLightColor
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectLightColorID returns the old "project_light_color_id" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldProjectLightColorID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectLightColorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectLightColorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectLightColorID: %w", err)
	}
	return oldValue.ProjectLightColorID, nil
}

// ResetProjectLightColorID resets all changes to the "project_light_color_id" field.
func (m *ProjectMutation) ResetProjectLightColorID() {
	m.projectLightColor = nil
}

// SetProjectIconID sets the "project_icon_id" field.
func (m *ProjectMutation) SetProjectIconID(u ulid.ID) {
	m.projectIcon = &u
}

// ProjectIconID returns the value of the "project_icon_id" field in the mutation.
func (m *ProjectMutation) ProjectIconID() (r ulid.ID, exists bool) {
	v := m.projectIcon
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectIconID returns the old "project_icon_id" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldProjectIconID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectIconID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectIconID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectIconID: %w", err)
	}
	return oldValue.ProjectIconID, nil
}

// ResetProjectIconID resets all changes to the "project_icon_id" field.
func (m *ProjectMutation) ResetProjectIconID() {
	m.projectIcon = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ProjectMutation) SetCreatedBy(u ulid.ID) {
	m.teammate = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProjectMutation) CreatedBy() (r ulid.ID, exists bool) {
	v := m.teammate
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedBy(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProjectMutation) ResetCreatedBy() {
	m.teammate = nil
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProjectMutation) SetDescription(value map[string]interface{}) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMutation) Description() (r map[string]interface{}, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
}

// SetDescriptionTitle sets the "description_title" field.
func (m *ProjectMutation) SetDescriptionTitle(s string) {
	m.description_title = &s
}

// DescriptionTitle returns the value of the "description_title" field in the mutation.
func (m *ProjectMutation) DescriptionTitle() (r string, exists bool) {
	v := m.description_title
	if v == nil {
		return
	}
	return *v, true
}

// OldDescriptionTitle returns the old "description_title" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescriptionTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescriptionTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescriptionTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescriptionTitle: %w", err)
	}
	return oldValue.DescriptionTitle, nil
}

// ResetDescriptionTitle resets all changes to the "description_title" field.
func (m *ProjectMutation) ResetDescriptionTitle() {
	m.description_title = nil
}

// SetDueDate sets the "due_date" field.
func (m *ProjectMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *ProjectMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDueDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ClearDueDate clears the value of the "due_date" field.
func (m *ProjectMutation) ClearDueDate() {
	m.due_date = nil
	m.clearedFields[project.FieldDueDate] = struct{}{}
}

// DueDateCleared returns if the "due_date" field was cleared in this mutation.
func (m *ProjectMutation) DueDateCleared() bool {
	_, ok := m.clearedFields[project.FieldDueDate]
	return ok
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *ProjectMutation) ResetDueDate() {
	m.due_date = nil
	delete(m.clearedFields, project.FieldDueDate)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearWorkspace clears the "workspace" edge to the Workspace entity.
func (m *ProjectMutation) ClearWorkspace() {
	m.clearedworkspace = true
}

// WorkspaceCleared reports if the "workspace" edge to the Workspace entity was cleared.
func (m *ProjectMutation) WorkspaceCleared() bool {
	return m.clearedworkspace
}

// WorkspaceIDs returns the "workspace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkspaceID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) WorkspaceIDs() (ids []ulid.ID) {
	if id := m.workspace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkspace resets all changes to the "workspace" edge.
func (m *ProjectMutation) ResetWorkspace() {
	m.workspace = nil
	m.clearedworkspace = false
}

// ClearProjectBaseColor clears the "projectBaseColor" edge to the ProjectBaseColor entity.
func (m *ProjectMutation) ClearProjectBaseColor() {
	m.clearedprojectBaseColor = true
}

// ProjectBaseColorCleared reports if the "projectBaseColor" edge to the ProjectBaseColor entity was cleared.
func (m *ProjectMutation) ProjectBaseColorCleared() bool {
	return m.clearedprojectBaseColor
}

// ProjectBaseColorIDs returns the "projectBaseColor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectBaseColorID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) ProjectBaseColorIDs() (ids []ulid.ID) {
	if id := m.projectBaseColor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProjectBaseColor resets all changes to the "projectBaseColor" edge.
func (m *ProjectMutation) ResetProjectBaseColor() {
	m.projectBaseColor = nil
	m.clearedprojectBaseColor = false
}

// ClearProjectLightColor clears the "projectLightColor" edge to the ProjectLightColor entity.
func (m *ProjectMutation) ClearProjectLightColor() {
	m.clearedprojectLightColor = true
}

// ProjectLightColorCleared reports if the "projectLightColor" edge to the ProjectLightColor entity was cleared.
func (m *ProjectMutation) ProjectLightColorCleared() bool {
	return m.clearedprojectLightColor
}

// ProjectLightColorIDs returns the "projectLightColor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectLightColorID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) ProjectLightColorIDs() (ids []ulid.ID) {
	if id := m.projectLightColor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProjectLightColor resets all changes to the "projectLightColor" edge.
func (m *ProjectMutation) ResetProjectLightColor() {
	m.projectLightColor = nil
	m.clearedprojectLightColor = false
}

// ClearProjectIcon clears the "projectIcon" edge to the ProjectIcon entity.
func (m *ProjectMutation) ClearProjectIcon() {
	m.clearedprojectIcon = true
}

// ProjectIconCleared reports if the "projectIcon" edge to the ProjectIcon entity was cleared.
func (m *ProjectMutation) ProjectIconCleared() bool {
	return m.clearedprojectIcon
}

// ProjectIconIDs returns the "projectIcon" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectIconID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) ProjectIconIDs() (ids []ulid.ID) {
	if id := m.projectIcon; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProjectIcon resets all changes to the "projectIcon" edge.
func (m *ProjectMutation) ResetProjectIcon() {
	m.projectIcon = nil
	m.clearedprojectIcon = false
}

// SetTeammateID sets the "teammate" edge to the Teammate entity by id.
func (m *ProjectMutation) SetTeammateID(id ulid.ID) {
	m.teammate = &id
}

// ClearTeammate clears the "teammate" edge to the Teammate entity.
func (m *ProjectMutation) ClearTeammate() {
	m.clearedteammate = true
}

// TeammateCleared reports if the "teammate" edge to the Teammate entity was cleared.
func (m *ProjectMutation) TeammateCleared() bool {
	return m.clearedteammate
}

// TeammateID returns the "teammate" edge ID in the mutation.
func (m *ProjectMutation) TeammateID() (id ulid.ID, exists bool) {
	if m.teammate != nil {
		return *m.teammate, true
	}
	return
}

// TeammateIDs returns the "teammate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeammateID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) TeammateIDs() (ids []ulid.ID) {
	if id := m.teammate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeammate resets all changes to the "teammate" edge.
func (m *ProjectMutation) ResetTeammate() {
	m.teammate = nil
	m.clearedteammate = false
}

// AddProjectTeammateIDs adds the "projectTeammates" edge to the ProjectTeammate entity by ids.
func (m *ProjectMutation) AddProjectTeammateIDs(ids ...ulid.ID) {
	if m.projectTeammates == nil {
		m.projectTeammates = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.projectTeammates[ids[i]] = struct{}{}
	}
}

// ClearProjectTeammates clears the "projectTeammates" edge to the ProjectTeammate entity.
func (m *ProjectMutation) ClearProjectTeammates() {
	m.clearedprojectTeammates = true
}

// ProjectTeammatesCleared reports if the "projectTeammates" edge to the ProjectTeammate entity was cleared.
func (m *ProjectMutation) ProjectTeammatesCleared() bool {
	return m.clearedprojectTeammates
}

// RemoveProjectTeammateIDs removes the "projectTeammates" edge to the ProjectTeammate entity by IDs.
func (m *ProjectMutation) RemoveProjectTeammateIDs(ids ...ulid.ID) {
	if m.removedprojectTeammates == nil {
		m.removedprojectTeammates = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.projectTeammates, ids[i])
		m.removedprojectTeammates[ids[i]] = struct{}{}
	}
}

// RemovedProjectTeammates returns the removed IDs of the "projectTeammates" edge to the ProjectTeammate entity.
func (m *ProjectMutation) RemovedProjectTeammatesIDs() (ids []ulid.ID) {
	for id := range m.removedprojectTeammates {
		ids = append(ids, id)
	}
	return
}

// ProjectTeammatesIDs returns the "projectTeammates" edge IDs in the mutation.
func (m *ProjectMutation) ProjectTeammatesIDs() (ids []ulid.ID) {
	for id := range m.projectTeammates {
		ids = append(ids, id)
	}
	return
}

// ResetProjectTeammates resets all changes to the "projectTeammates" edge.
func (m *ProjectMutation) ResetProjectTeammates() {
	m.projectTeammates = nil
	m.clearedprojectTeammates = false
	m.removedprojectTeammates = nil
}

// AddFavoriteProjectIDs adds the "favoriteProjects" edge to the FavoriteProject entity by ids.
func (m *ProjectMutation) AddFavoriteProjectIDs(ids ...ulid.ID) {
	if m.favoriteProjects == nil {
		m.favoriteProjects = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.favoriteProjects[ids[i]] = struct{}{}
	}
}

// ClearFavoriteProjects clears the "favoriteProjects" edge to the FavoriteProject entity.
func (m *ProjectMutation) ClearFavoriteProjects() {
	m.clearedfavoriteProjects = true
}

// FavoriteProjectsCleared reports if the "favoriteProjects" edge to the FavoriteProject entity was cleared.
func (m *ProjectMutation) FavoriteProjectsCleared() bool {
	return m.clearedfavoriteProjects
}

// RemoveFavoriteProjectIDs removes the "favoriteProjects" edge to the FavoriteProject entity by IDs.
func (m *ProjectMutation) RemoveFavoriteProjectIDs(ids ...ulid.ID) {
	if m.removedfavoriteProjects == nil {
		m.removedfavoriteProjects = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.favoriteProjects, ids[i])
		m.removedfavoriteProjects[ids[i]] = struct{}{}
	}
}

// RemovedFavoriteProjects returns the removed IDs of the "favoriteProjects" edge to the FavoriteProject entity.
func (m *ProjectMutation) RemovedFavoriteProjectsIDs() (ids []ulid.ID) {
	for id := range m.removedfavoriteProjects {
		ids = append(ids, id)
	}
	return
}

// FavoriteProjectsIDs returns the "favoriteProjects" edge IDs in the mutation.
func (m *ProjectMutation) FavoriteProjectsIDs() (ids []ulid.ID) {
	for id := range m.favoriteProjects {
		ids = append(ids, id)
	}
	return
}

// ResetFavoriteProjects resets all changes to the "favoriteProjects" edge.
func (m *ProjectMutation) ResetFavoriteProjects() {
	m.favoriteProjects = nil
	m.clearedfavoriteProjects = false
	m.removedfavoriteProjects = nil
}

// AddProjectTaskColumnIDs adds the "projectTaskColumns" edge to the ProjectTaskColumn entity by ids.
func (m *ProjectMutation) AddProjectTaskColumnIDs(ids ...ulid.ID) {
	if m.projectTaskColumns == nil {
		m.projectTaskColumns = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.projectTaskColumns[ids[i]] = struct{}{}
	}
}

// ClearProjectTaskColumns clears the "projectTaskColumns" edge to the ProjectTaskColumn entity.
func (m *ProjectMutation) ClearProjectTaskColumns() {
	m.clearedprojectTaskColumns = true
}

// ProjectTaskColumnsCleared reports if the "projectTaskColumns" edge to the ProjectTaskColumn entity was cleared.
func (m *ProjectMutation) ProjectTaskColumnsCleared() bool {
	return m.clearedprojectTaskColumns
}

// RemoveProjectTaskColumnIDs removes the "projectTaskColumns" edge to the ProjectTaskColumn entity by IDs.
func (m *ProjectMutation) RemoveProjectTaskColumnIDs(ids ...ulid.ID) {
	if m.removedprojectTaskColumns == nil {
		m.removedprojectTaskColumns = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.projectTaskColumns, ids[i])
		m.removedprojectTaskColumns[ids[i]] = struct{}{}
	}
}

// RemovedProjectTaskColumns returns the removed IDs of the "projectTaskColumns" edge to the ProjectTaskColumn entity.
func (m *ProjectMutation) RemovedProjectTaskColumnsIDs() (ids []ulid.ID) {
	for id := range m.removedprojectTaskColumns {
		ids = append(ids, id)
	}
	return
}

// ProjectTaskColumnsIDs returns the "projectTaskColumns" edge IDs in the mutation.
func (m *ProjectMutation) ProjectTaskColumnsIDs() (ids []ulid.ID) {
	for id := range m.projectTaskColumns {
		ids = append(ids, id)
	}
	return
}

// ResetProjectTaskColumns resets all changes to the "projectTaskColumns" edge.
func (m *ProjectMutation) ResetProjectTaskColumns() {
	m.projectTaskColumns = nil
	m.clearedprojectTaskColumns = false
	m.removedprojectTaskColumns = nil
}

// AddProjectTaskListStatuseIDs adds the "projectTaskListStatuses" edge to the ProjectTaskListStatus entity by ids.
func (m *ProjectMutation) AddProjectTaskListStatuseIDs(ids ...ulid.ID) {
	if m.projectTaskListStatuses == nil {
		m.projectTaskListStatuses = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.projectTaskListStatuses[ids[i]] = struct{}{}
	}
}

// ClearProjectTaskListStatuses clears the "projectTaskListStatuses" edge to the ProjectTaskListStatus entity.
func (m *ProjectMutation) ClearProjectTaskListStatuses() {
	m.clearedprojectTaskListStatuses = true
}

// ProjectTaskListStatusesCleared reports if the "projectTaskListStatuses" edge to the ProjectTaskListStatus entity was cleared.
func (m *ProjectMutation) ProjectTaskListStatusesCleared() bool {
	return m.clearedprojectTaskListStatuses
}

// RemoveProjectTaskListStatuseIDs removes the "projectTaskListStatuses" edge to the ProjectTaskListStatus entity by IDs.
func (m *ProjectMutation) RemoveProjectTaskListStatuseIDs(ids ...ulid.ID) {
	if m.removedprojectTaskListStatuses == nil {
		m.removedprojectTaskListStatuses = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.projectTaskListStatuses, ids[i])
		m.removedprojectTaskListStatuses[ids[i]] = struct{}{}
	}
}

// RemovedProjectTaskListStatuses returns the removed IDs of the "projectTaskListStatuses" edge to the ProjectTaskListStatus entity.
func (m *ProjectMutation) RemovedProjectTaskListStatusesIDs() (ids []ulid.ID) {
	for id := range m.removedprojectTaskListStatuses {
		ids = append(ids, id)
	}
	return
}

// ProjectTaskListStatusesIDs returns the "projectTaskListStatuses" edge IDs in the mutation.
func (m *ProjectMutation) ProjectTaskListStatusesIDs() (ids []ulid.ID) {
	for id := range m.projectTaskListStatuses {
		ids = append(ids, id)
	}
	return
}

// ResetProjectTaskListStatuses resets all changes to the "projectTaskListStatuses" edge.
func (m *ProjectMutation) ResetProjectTaskListStatuses() {
	m.projectTaskListStatuses = nil
	m.clearedprojectTaskListStatuses = false
	m.removedprojectTaskListStatuses = nil
}

// AddProjectTaskSectionIDs adds the "projectTaskSections" edge to the ProjectTaskSection entity by ids.
func (m *ProjectMutation) AddProjectTaskSectionIDs(ids ...ulid.ID) {
	if m.projectTaskSections == nil {
		m.projectTaskSections = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.projectTaskSections[ids[i]] = struct{}{}
	}
}

// ClearProjectTaskSections clears the "projectTaskSections" edge to the ProjectTaskSection entity.
func (m *ProjectMutation) ClearProjectTaskSections() {
	m.clearedprojectTaskSections = true
}

// ProjectTaskSectionsCleared reports if the "projectTaskSections" edge to the ProjectTaskSection entity was cleared.
func (m *ProjectMutation) ProjectTaskSectionsCleared() bool {
	return m.clearedprojectTaskSections
}

// RemoveProjectTaskSectionIDs removes the "projectTaskSections" edge to the ProjectTaskSection entity by IDs.
func (m *ProjectMutation) RemoveProjectTaskSectionIDs(ids ...ulid.ID) {
	if m.removedprojectTaskSections == nil {
		m.removedprojectTaskSections = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.projectTaskSections, ids[i])
		m.removedprojectTaskSections[ids[i]] = struct{}{}
	}
}

// RemovedProjectTaskSections returns the removed IDs of the "projectTaskSections" edge to the ProjectTaskSection entity.
func (m *ProjectMutation) RemovedProjectTaskSectionsIDs() (ids []ulid.ID) {
	for id := range m.removedprojectTaskSections {
		ids = append(ids, id)
	}
	return
}

// ProjectTaskSectionsIDs returns the "projectTaskSections" edge IDs in the mutation.
func (m *ProjectMutation) ProjectTaskSectionsIDs() (ids []ulid.ID) {
	for id := range m.projectTaskSections {
		ids = append(ids, id)
	}
	return
}

// ResetProjectTaskSections resets all changes to the "projectTaskSections" edge.
func (m *ProjectMutation) ResetProjectTaskSections() {
	m.projectTaskSections = nil
	m.clearedprojectTaskSections = false
	m.removedprojectTaskSections = nil
}

// AddProjectTaskIDs adds the "projectTasks" edge to the ProjectTask entity by ids.
func (m *ProjectMutation) AddProjectTaskIDs(ids ...ulid.ID) {
	if m.projectTasks == nil {
		m.projectTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.projectTasks[ids[i]] = struct{}{}
	}
}

// ClearProjectTasks clears the "projectTasks" edge to the ProjectTask entity.
func (m *ProjectMutation) ClearProjectTasks() {
	m.clearedprojectTasks = true
}

// ProjectTasksCleared reports if the "projectTasks" edge to the ProjectTask entity was cleared.
func (m *ProjectMutation) ProjectTasksCleared() bool {
	return m.clearedprojectTasks
}

// RemoveProjectTaskIDs removes the "projectTasks" edge to the ProjectTask entity by IDs.
func (m *ProjectMutation) RemoveProjectTaskIDs(ids ...ulid.ID) {
	if m.removedprojectTasks == nil {
		m.removedprojectTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.projectTasks, ids[i])
		m.removedprojectTasks[ids[i]] = struct{}{}
	}
}

// RemovedProjectTasks returns the removed IDs of the "projectTasks" edge to the ProjectTask entity.
func (m *ProjectMutation) RemovedProjectTasksIDs() (ids []ulid.ID) {
	for id := range m.removedprojectTasks {
		ids = append(ids, id)
	}
	return
}

// ProjectTasksIDs returns the "projectTasks" edge IDs in the mutation.
func (m *ProjectMutation) ProjectTasksIDs() (ids []ulid.ID) {
	for id := range m.projectTasks {
		ids = append(ids, id)
	}
	return
}

// ResetProjectTasks resets all changes to the "projectTasks" edge.
func (m *ProjectMutation) ResetProjectTasks() {
	m.projectTasks = nil
	m.clearedprojectTasks = false
	m.removedprojectTasks = nil
}

// AddTaskFileIDs adds the "taskFiles" edge to the TaskFile entity by ids.
func (m *ProjectMutation) AddTaskFileIDs(ids ...ulid.ID) {
	if m.taskFiles == nil {
		m.taskFiles = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.taskFiles[ids[i]] = struct{}{}
	}
}

// ClearTaskFiles clears the "taskFiles" edge to the TaskFile entity.
func (m *ProjectMutation) ClearTaskFiles() {
	m.clearedtaskFiles = true
}

// TaskFilesCleared reports if the "taskFiles" edge to the TaskFile entity was cleared.
func (m *ProjectMutation) TaskFilesCleared() bool {
	return m.clearedtaskFiles
}

// RemoveTaskFileIDs removes the "taskFiles" edge to the TaskFile entity by IDs.
func (m *ProjectMutation) RemoveTaskFileIDs(ids ...ulid.ID) {
	if m.removedtaskFiles == nil {
		m.removedtaskFiles = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.taskFiles, ids[i])
		m.removedtaskFiles[ids[i]] = struct{}{}
	}
}

// RemovedTaskFiles returns the removed IDs of the "taskFiles" edge to the TaskFile entity.
func (m *ProjectMutation) RemovedTaskFilesIDs() (ids []ulid.ID) {
	for id := range m.removedtaskFiles {
		ids = append(ids, id)
	}
	return
}

// TaskFilesIDs returns the "taskFiles" edge IDs in the mutation.
func (m *ProjectMutation) TaskFilesIDs() (ids []ulid.ID) {
	for id := range m.taskFiles {
		ids = append(ids, id)
	}
	return
}

// ResetTaskFiles resets all changes to the "taskFiles" edge.
func (m *ProjectMutation) ResetTaskFiles() {
	m.taskFiles = nil
	m.clearedtaskFiles = false
	m.removedtaskFiles = nil
}

// AddWorkspaceActivityIDs adds the "workspaceActivities" edge to the WorkspaceActivity entity by ids.
func (m *ProjectMutation) AddWorkspaceActivityIDs(ids ...ulid.ID) {
	if m.workspaceActivities == nil {
		m.workspaceActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.workspaceActivities[ids[i]] = struct{}{}
	}
}

// ClearWorkspaceActivities clears the "workspaceActivities" edge to the WorkspaceActivity entity.
func (m *ProjectMutation) ClearWorkspaceActivities() {
	m.clearedworkspaceActivities = true
}

// WorkspaceActivitiesCleared reports if the "workspaceActivities" edge to the WorkspaceActivity entity was cleared.
func (m *ProjectMutation) WorkspaceActivitiesCleared() bool {
	return m.clearedworkspaceActivities
}

// RemoveWorkspaceActivityIDs removes the "workspaceActivities" edge to the WorkspaceActivity entity by IDs.
func (m *ProjectMutation) RemoveWorkspaceActivityIDs(ids ...ulid.ID) {
	if m.removedworkspaceActivities == nil {
		m.removedworkspaceActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.workspaceActivities, ids[i])
		m.removedworkspaceActivities[ids[i]] = struct{}{}
	}
}

// RemovedWorkspaceActivities returns the removed IDs of the "workspaceActivities" edge to the WorkspaceActivity entity.
func (m *ProjectMutation) RemovedWorkspaceActivitiesIDs() (ids []ulid.ID) {
	for id := range m.removedworkspaceActivities {
		ids = append(ids, id)
	}
	return
}

// WorkspaceActivitiesIDs returns the "workspaceActivities" edge IDs in the mutation.
func (m *ProjectMutation) WorkspaceActivitiesIDs() (ids []ulid.ID) {
	for id := range m.workspaceActivities {
		ids = append(ids, id)
	}
	return
}

// ResetWorkspaceActivities resets all changes to the "workspaceActivities" edge.
func (m *ProjectMutation) ResetWorkspaceActivities() {
	m.workspaceActivities = nil
	m.clearedworkspaceActivities = false
	m.removedworkspaceActivities = nil
}

// AddArchivedWorkspaceActivityIDs adds the "archivedWorkspaceActivities" edge to the ArchivedWorkspaceActivity entity by ids.
func (m *ProjectMutation) AddArchivedWorkspaceActivityIDs(ids ...ulid.ID) {
	if m.archivedWorkspaceActivities == nil {
		m.archivedWorkspaceActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.archivedWorkspaceActivities[ids[i]] = struct{}{}
	}
}

// ClearArchivedWorkspaceActivities clears the "archivedWorkspaceActivities" edge to the ArchivedWorkspaceActivity entity.
func (m *ProjectMutation) ClearArchivedWorkspaceActivities() {
	m.clearedarchivedWorkspaceActivities = true
}

// ArchivedWorkspaceActivitiesCleared reports if the "archivedWorkspaceActivities" edge to the ArchivedWorkspaceActivity entity was cleared.
func (m *ProjectMutation) ArchivedWorkspaceActivitiesCleared() bool {
	return m.clearedarchivedWorkspaceActivities
}

// RemoveArchivedWorkspaceActivityIDs removes the "archivedWorkspaceActivities" edge to the ArchivedWorkspaceActivity entity by IDs.
func (m *ProjectMutation) RemoveArchivedWorkspaceActivityIDs(ids ...ulid.ID) {
	if m.removedarchivedWorkspaceActivities == nil {
		m.removedarchivedWorkspaceActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.archivedWorkspaceActivities, ids[i])
		m.removedarchivedWorkspaceActivities[ids[i]] = struct{}{}
	}
}

// RemovedArchivedWorkspaceActivities returns the removed IDs of the "archivedWorkspaceActivities" edge to the ArchivedWorkspaceActivity entity.
func (m *ProjectMutation) RemovedArchivedWorkspaceActivitiesIDs() (ids []ulid.ID) {
	for id := range m.removedarchivedWorkspaceActivities {
		ids = append(ids, id)
	}
	return
}

// ArchivedWorkspaceActivitiesIDs returns the "archivedWorkspaceActivities" edge IDs in the mutation.
func (m *ProjectMutation) ArchivedWorkspaceActivitiesIDs() (ids []ulid.ID) {
	for id := range m.archivedWorkspaceActivities {
		ids = append(ids, id)
	}
	return
}

// ResetArchivedWorkspaceActivities resets all changes to the "archivedWorkspaceActivities" edge.
func (m *ProjectMutation) ResetArchivedWorkspaceActivities() {
	m.archivedWorkspaceActivities = nil
	m.clearedarchivedWorkspaceActivities = false
	m.removedarchivedWorkspaceActivities = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.workspace != nil {
		fields = append(fields, project.FieldWorkspaceID)
	}
	if m.projectBaseColor != nil {
		fields = append(fields, project.FieldProjectBaseColorID)
	}
	if m.projectLightColor != nil {
		fields = append(fields, project.FieldProjectLightColorID)
	}
	if m.projectIcon != nil {
		fields = append(fields, project.FieldProjectIconID)
	}
	if m.teammate != nil {
		fields = append(fields, project.FieldCreatedBy)
	}
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	if m.description_title != nil {
		fields = append(fields, project.FieldDescriptionTitle)
	}
	if m.due_date != nil {
		fields = append(fields, project.FieldDueDate)
	}
	if m.created_at != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, project.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldWorkspaceID:
		return m.WorkspaceID()
	case project.FieldProjectBaseColorID:
		return m.ProjectBaseColorID()
	case project.FieldProjectLightColorID:
		return m.ProjectLightColorID()
	case project.FieldProjectIconID:
		return m.ProjectIconID()
	case project.FieldCreatedBy:
		return m.CreatedBy()
	case project.FieldName:
		return m.Name()
	case project.FieldDescription:
		return m.Description()
	case project.FieldDescriptionTitle:
		return m.DescriptionTitle()
	case project.FieldDueDate:
		return m.DueDate()
	case project.FieldCreatedAt:
		return m.CreatedAt()
	case project.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldWorkspaceID:
		return m.OldWorkspaceID(ctx)
	case project.FieldProjectBaseColorID:
		return m.OldProjectBaseColorID(ctx)
	case project.FieldProjectLightColorID:
		return m.OldProjectLightColorID(ctx)
	case project.FieldProjectIconID:
		return m.OldProjectIconID(ctx)
	case project.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	case project.FieldDescriptionTitle:
		return m.OldDescriptionTitle(ctx)
	case project.FieldDueDate:
		return m.OldDueDate(ctx)
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case project.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldWorkspaceID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspaceID(v)
		return nil
	case project.FieldProjectBaseColorID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectBaseColorID(v)
		return nil
	case project.FieldProjectLightColorID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectLightColorID(v)
		return nil
	case project.FieldProjectIconID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectIconID(v)
		return nil
	case project.FieldCreatedBy:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case project.FieldDescriptionTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescriptionTitle(v)
		return nil
	case project.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case project.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldDueDate) {
		fields = append(fields, project.FieldDueDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldDueDate:
		m.ClearDueDate()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldWorkspaceID:
		m.ResetWorkspaceID()
		return nil
	case project.FieldProjectBaseColorID:
		m.ResetProjectBaseColorID()
		return nil
	case project.FieldProjectLightColorID:
		m.ResetProjectLightColorID()
		return nil
	case project.FieldProjectIconID:
		m.ResetProjectIconID()
		return nil
	case project.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	case project.FieldDescriptionTitle:
		m.ResetDescriptionTitle()
		return nil
	case project.FieldDueDate:
		m.ResetDueDate()
		return nil
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case project.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 14)
	if m.workspace != nil {
		edges = append(edges, project.EdgeWorkspace)
	}
	if m.projectBaseColor != nil {
		edges = append(edges, project.EdgeProjectBaseColor)
	}
	if m.projectLightColor != nil {
		edges = append(edges, project.EdgeProjectLightColor)
	}
	if m.projectIcon != nil {
		edges = append(edges, project.EdgeProjectIcon)
	}
	if m.teammate != nil {
		edges = append(edges, project.EdgeTeammate)
	}
	if m.projectTeammates != nil {
		edges = append(edges, project.EdgeProjectTeammates)
	}
	if m.favoriteProjects != nil {
		edges = append(edges, project.EdgeFavoriteProjects)
	}
	if m.projectTaskColumns != nil {
		edges = append(edges, project.EdgeProjectTaskColumns)
	}
	if m.projectTaskListStatuses != nil {
		edges = append(edges, project.EdgeProjectTaskListStatuses)
	}
	if m.projectTaskSections != nil {
		edges = append(edges, project.EdgeProjectTaskSections)
	}
	if m.projectTasks != nil {
		edges = append(edges, project.EdgeProjectTasks)
	}
	if m.taskFiles != nil {
		edges = append(edges, project.EdgeTaskFiles)
	}
	if m.workspaceActivities != nil {
		edges = append(edges, project.EdgeWorkspaceActivities)
	}
	if m.archivedWorkspaceActivities != nil {
		edges = append(edges, project.EdgeArchivedWorkspaceActivities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeWorkspace:
		if id := m.workspace; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeProjectBaseColor:
		if id := m.projectBaseColor; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeProjectLightColor:
		if id := m.projectLightColor; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeProjectIcon:
		if id := m.projectIcon; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeTeammate:
		if id := m.teammate; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeProjectTeammates:
		ids := make([]ent.Value, 0, len(m.projectTeammates))
		for id := range m.projectTeammates {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeFavoriteProjects:
		ids := make([]ent.Value, 0, len(m.favoriteProjects))
		for id := range m.favoriteProjects {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeProjectTaskColumns:
		ids := make([]ent.Value, 0, len(m.projectTaskColumns))
		for id := range m.projectTaskColumns {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeProjectTaskListStatuses:
		ids := make([]ent.Value, 0, len(m.projectTaskListStatuses))
		for id := range m.projectTaskListStatuses {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeProjectTaskSections:
		ids := make([]ent.Value, 0, len(m.projectTaskSections))
		for id := range m.projectTaskSections {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeProjectTasks:
		ids := make([]ent.Value, 0, len(m.projectTasks))
		for id := range m.projectTasks {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTaskFiles:
		ids := make([]ent.Value, 0, len(m.taskFiles))
		for id := range m.taskFiles {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeWorkspaceActivities:
		ids := make([]ent.Value, 0, len(m.workspaceActivities))
		for id := range m.workspaceActivities {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeArchivedWorkspaceActivities:
		ids := make([]ent.Value, 0, len(m.archivedWorkspaceActivities))
		for id := range m.archivedWorkspaceActivities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 14)
	if m.removedprojectTeammates != nil {
		edges = append(edges, project.EdgeProjectTeammates)
	}
	if m.removedfavoriteProjects != nil {
		edges = append(edges, project.EdgeFavoriteProjects)
	}
	if m.removedprojectTaskColumns != nil {
		edges = append(edges, project.EdgeProjectTaskColumns)
	}
	if m.removedprojectTaskListStatuses != nil {
		edges = append(edges, project.EdgeProjectTaskListStatuses)
	}
	if m.removedprojectTaskSections != nil {
		edges = append(edges, project.EdgeProjectTaskSections)
	}
	if m.removedprojectTasks != nil {
		edges = append(edges, project.EdgeProjectTasks)
	}
	if m.removedtaskFiles != nil {
		edges = append(edges, project.EdgeTaskFiles)
	}
	if m.removedworkspaceActivities != nil {
		edges = append(edges, project.EdgeWorkspaceActivities)
	}
	if m.removedarchivedWorkspaceActivities != nil {
		edges = append(edges, project.EdgeArchivedWorkspaceActivities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeProjectTeammates:
		ids := make([]ent.Value, 0, len(m.removedprojectTeammates))
		for id := range m.removedprojectTeammates {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeFavoriteProjects:
		ids := make([]ent.Value, 0, len(m.removedfavoriteProjects))
		for id := range m.removedfavoriteProjects {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeProjectTaskColumns:
		ids := make([]ent.Value, 0, len(m.removedprojectTaskColumns))
		for id := range m.removedprojectTaskColumns {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeProjectTaskListStatuses:
		ids := make([]ent.Value, 0, len(m.removedprojectTaskListStatuses))
		for id := range m.removedprojectTaskListStatuses {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeProjectTaskSections:
		ids := make([]ent.Value, 0, len(m.removedprojectTaskSections))
		for id := range m.removedprojectTaskSections {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeProjectTasks:
		ids := make([]ent.Value, 0, len(m.removedprojectTasks))
		for id := range m.removedprojectTasks {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTaskFiles:
		ids := make([]ent.Value, 0, len(m.removedtaskFiles))
		for id := range m.removedtaskFiles {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeWorkspaceActivities:
		ids := make([]ent.Value, 0, len(m.removedworkspaceActivities))
		for id := range m.removedworkspaceActivities {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeArchivedWorkspaceActivities:
		ids := make([]ent.Value, 0, len(m.removedarchivedWorkspaceActivities))
		for id := range m.removedarchivedWorkspaceActivities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 14)
	if m.clearedworkspace {
		edges = append(edges, project.EdgeWorkspace)
	}
	if m.clearedprojectBaseColor {
		edges = append(edges, project.EdgeProjectBaseColor)
	}
	if m.clearedprojectLightColor {
		edges = append(edges, project.EdgeProjectLightColor)
	}
	if m.clearedprojectIcon {
		edges = append(edges, project.EdgeProjectIcon)
	}
	if m.clearedteammate {
		edges = append(edges, project.EdgeTeammate)
	}
	if m.clearedprojectTeammates {
		edges = append(edges, project.EdgeProjectTeammates)
	}
	if m.clearedfavoriteProjects {
		edges = append(edges, project.EdgeFavoriteProjects)
	}
	if m.clearedprojectTaskColumns {
		edges = append(edges, project.EdgeProjectTaskColumns)
	}
	if m.clearedprojectTaskListStatuses {
		edges = append(edges, project.EdgeProjectTaskListStatuses)
	}
	if m.clearedprojectTaskSections {
		edges = append(edges, project.EdgeProjectTaskSections)
	}
	if m.clearedprojectTasks {
		edges = append(edges, project.EdgeProjectTasks)
	}
	if m.clearedtaskFiles {
		edges = append(edges, project.EdgeTaskFiles)
	}
	if m.clearedworkspaceActivities {
		edges = append(edges, project.EdgeWorkspaceActivities)
	}
	if m.clearedarchivedWorkspaceActivities {
		edges = append(edges, project.EdgeArchivedWorkspaceActivities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeWorkspace:
		return m.clearedworkspace
	case project.EdgeProjectBaseColor:
		return m.clearedprojectBaseColor
	case project.EdgeProjectLightColor:
		return m.clearedprojectLightColor
	case project.EdgeProjectIcon:
		return m.clearedprojectIcon
	case project.EdgeTeammate:
		return m.clearedteammate
	case project.EdgeProjectTeammates:
		return m.clearedprojectTeammates
	case project.EdgeFavoriteProjects:
		return m.clearedfavoriteProjects
	case project.EdgeProjectTaskColumns:
		return m.clearedprojectTaskColumns
	case project.EdgeProjectTaskListStatuses:
		return m.clearedprojectTaskListStatuses
	case project.EdgeProjectTaskSections:
		return m.clearedprojectTaskSections
	case project.EdgeProjectTasks:
		return m.clearedprojectTasks
	case project.EdgeTaskFiles:
		return m.clearedtaskFiles
	case project.EdgeWorkspaceActivities:
		return m.clearedworkspaceActivities
	case project.EdgeArchivedWorkspaceActivities:
		return m.clearedarchivedWorkspaceActivities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	case project.EdgeWorkspace:
		m.ClearWorkspace()
		return nil
	case project.EdgeProjectBaseColor:
		m.ClearProjectBaseColor()
		return nil
	case project.EdgeProjectLightColor:
		m.ClearProjectLightColor()
		return nil
	case project.EdgeProjectIcon:
		m.ClearProjectIcon()
		return nil
	case project.EdgeTeammate:
		m.ClearTeammate()
		return nil
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeWorkspace:
		m.ResetWorkspace()
		return nil
	case project.EdgeProjectBaseColor:
		m.ResetProjectBaseColor()
		return nil
	case project.EdgeProjectLightColor:
		m.ResetProjectLightColor()
		return nil
	case project.EdgeProjectIcon:
		m.ResetProjectIcon()
		return nil
	case project.EdgeTeammate:
		m.ResetTeammate()
		return nil
	case project.EdgeProjectTeammates:
		m.ResetProjectTeammates()
		return nil
	case project.EdgeFavoriteProjects:
		m.ResetFavoriteProjects()
		return nil
	case project.EdgeProjectTaskColumns:
		m.ResetProjectTaskColumns()
		return nil
	case project.EdgeProjectTaskListStatuses:
		m.ResetProjectTaskListStatuses()
		return nil
	case project.EdgeProjectTaskSections:
		m.ResetProjectTaskSections()
		return nil
	case project.EdgeProjectTasks:
		m.ResetProjectTasks()
		return nil
	case project.EdgeTaskFiles:
		m.ResetTaskFiles()
		return nil
	case project.EdgeWorkspaceActivities:
		m.ResetWorkspaceActivities()
		return nil
	case project.EdgeArchivedWorkspaceActivities:
		m.ResetArchivedWorkspaceActivities()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// ProjectBaseColorMutation represents an operation that mutates the ProjectBaseColor nodes in the graph.
type ProjectBaseColorMutation struct {
	config
	op              Op
	typ             string
	id              *ulid.ID
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	projects        map[ulid.ID]struct{}
	removedprojects map[ulid.ID]struct{}
	clearedprojects bool
	color           *ulid.ID
	clearedcolor    bool
	done            bool
	oldValue        func(context.Context) (*ProjectBaseColor, error)
	predicates      []predicate.ProjectBaseColor
}

var _ ent.Mutation = (*ProjectBaseColorMutation)(nil)

// projectbasecolorOption allows management of the mutation configuration using functional options.
type projectbasecolorOption func(*ProjectBaseColorMutation)

// newProjectBaseColorMutation creates new mutation for the ProjectBaseColor entity.
func newProjectBaseColorMutation(c config, op Op, opts ...projectbasecolorOption) *ProjectBaseColorMutation {
	m := &ProjectBaseColorMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectBaseColor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectBaseColorID sets the ID field of the mutation.
func withProjectBaseColorID(id ulid.ID) projectbasecolorOption {
	return func(m *ProjectBaseColorMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectBaseColor
		)
		m.oldValue = func(ctx context.Context) (*ProjectBaseColor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectBaseColor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectBaseColor sets the old ProjectBaseColor of the mutation.
func withProjectBaseColor(node *ProjectBaseColor) projectbasecolorOption {
	return func(m *ProjectBaseColorMutation) {
		m.oldValue = func(context.Context) (*ProjectBaseColor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectBaseColorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectBaseColorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProjectBaseColor entities.
func (m *ProjectBaseColorMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectBaseColorMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectBaseColorMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectBaseColor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetColorID sets the "color_id" field.
func (m *ProjectBaseColorMutation) SetColorID(u ulid.ID) {
	m.color = &u
}

// ColorID returns the value of the "color_id" field in the mutation.
func (m *ProjectBaseColorMutation) ColorID() (r ulid.ID, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColorID returns the old "color_id" field's value of the ProjectBaseColor entity.
// If the ProjectBaseColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectBaseColorMutation) OldColorID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColorID: %w", err)
	}
	return oldValue.ColorID, nil
}

// ResetColorID resets all changes to the "color_id" field.
func (m *ProjectBaseColorMutation) ResetColorID() {
	m.color = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectBaseColorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectBaseColorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectBaseColor entity.
// If the ProjectBaseColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectBaseColorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectBaseColorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectBaseColorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectBaseColorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProjectBaseColor entity.
// If the ProjectBaseColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectBaseColorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectBaseColorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *ProjectBaseColorMutation) AddProjectIDs(ids ...ulid.ID) {
	if m.projects == nil {
		m.projects = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *ProjectBaseColorMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *ProjectBaseColorMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *ProjectBaseColorMutation) RemoveProjectIDs(ids ...ulid.ID) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *ProjectBaseColorMutation) RemovedProjectsIDs() (ids []ulid.ID) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *ProjectBaseColorMutation) ProjectsIDs() (ids []ulid.ID) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *ProjectBaseColorMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// ClearColor clears the "color" edge to the Color entity.
func (m *ProjectBaseColorMutation) ClearColor() {
	m.clearedcolor = true
}

// ColorCleared reports if the "color" edge to the Color entity was cleared.
func (m *ProjectBaseColorMutation) ColorCleared() bool {
	return m.clearedcolor
}

// ColorIDs returns the "color" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ColorID instead. It exists only for internal usage by the builders.
func (m *ProjectBaseColorMutation) ColorIDs() (ids []ulid.ID) {
	if id := m.color; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetColor resets all changes to the "color" edge.
func (m *ProjectBaseColorMutation) ResetColor() {
	m.color = nil
	m.clearedcolor = false
}

// Where appends a list predicates to the ProjectBaseColorMutation builder.
func (m *ProjectBaseColorMutation) Where(ps ...predicate.ProjectBaseColor) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProjectBaseColorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProjectBaseColor).
func (m *ProjectBaseColorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectBaseColorMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.color != nil {
		fields = append(fields, projectbasecolor.FieldColorID)
	}
	if m.created_at != nil {
		fields = append(fields, projectbasecolor.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, projectbasecolor.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectBaseColorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectbasecolor.FieldColorID:
		return m.ColorID()
	case projectbasecolor.FieldCreatedAt:
		return m.CreatedAt()
	case projectbasecolor.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectBaseColorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectbasecolor.FieldColorID:
		return m.OldColorID(ctx)
	case projectbasecolor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case projectbasecolor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectBaseColor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectBaseColorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectbasecolor.FieldColorID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColorID(v)
		return nil
	case projectbasecolor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case projectbasecolor.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectBaseColor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectBaseColorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectBaseColorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectBaseColorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectBaseColor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectBaseColorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectBaseColorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectBaseColorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProjectBaseColor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectBaseColorMutation) ResetField(name string) error {
	switch name {
	case projectbasecolor.FieldColorID:
		m.ResetColorID()
		return nil
	case projectbasecolor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case projectbasecolor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProjectBaseColor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectBaseColorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.projects != nil {
		edges = append(edges, projectbasecolor.EdgeProjects)
	}
	if m.color != nil {
		edges = append(edges, projectbasecolor.EdgeColor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectBaseColorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectbasecolor.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case projectbasecolor.EdgeColor:
		if id := m.color; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectBaseColorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedprojects != nil {
		edges = append(edges, projectbasecolor.EdgeProjects)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectBaseColorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case projectbasecolor.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectBaseColorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedprojects {
		edges = append(edges, projectbasecolor.EdgeProjects)
	}
	if m.clearedcolor {
		edges = append(edges, projectbasecolor.EdgeColor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectBaseColorMutation) EdgeCleared(name string) bool {
	switch name {
	case projectbasecolor.EdgeProjects:
		return m.clearedprojects
	case projectbasecolor.EdgeColor:
		return m.clearedcolor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectBaseColorMutation) ClearEdge(name string) error {
	switch name {
	case projectbasecolor.EdgeColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown ProjectBaseColor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectBaseColorMutation) ResetEdge(name string) error {
	switch name {
	case projectbasecolor.EdgeProjects:
		m.ResetProjects()
		return nil
	case projectbasecolor.EdgeColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown ProjectBaseColor edge %s", name)
}

// ProjectIconMutation represents an operation that mutates the ProjectIcon nodes in the graph.
type ProjectIconMutation struct {
	config
	op              Op
	typ             string
	id              *ulid.ID
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	projects        map[ulid.ID]struct{}
	removedprojects map[ulid.ID]struct{}
	clearedprojects bool
	icon            *ulid.ID
	clearedicon     bool
	done            bool
	oldValue        func(context.Context) (*ProjectIcon, error)
	predicates      []predicate.ProjectIcon
}

var _ ent.Mutation = (*ProjectIconMutation)(nil)

// projecticonOption allows management of the mutation configuration using functional options.
type projecticonOption func(*ProjectIconMutation)

// newProjectIconMutation creates new mutation for the ProjectIcon entity.
func newProjectIconMutation(c config, op Op, opts ...projecticonOption) *ProjectIconMutation {
	m := &ProjectIconMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectIcon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectIconID sets the ID field of the mutation.
func withProjectIconID(id ulid.ID) projecticonOption {
	return func(m *ProjectIconMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectIcon
		)
		m.oldValue = func(ctx context.Context) (*ProjectIcon, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectIcon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectIcon sets the old ProjectIcon of the mutation.
func withProjectIcon(node *ProjectIcon) projecticonOption {
	return func(m *ProjectIconMutation) {
		m.oldValue = func(context.Context) (*ProjectIcon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectIconMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectIconMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProjectIcon entities.
func (m *ProjectIconMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectIconMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectIconMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectIcon.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIconID sets the "icon_id" field.
func (m *ProjectIconMutation) SetIconID(u ulid.ID) {
	m.icon = &u
}

// IconID returns the value of the "icon_id" field in the mutation.
func (m *ProjectIconMutation) IconID() (r ulid.ID, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIconID returns the old "icon_id" field's value of the ProjectIcon entity.
// If the ProjectIcon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectIconMutation) OldIconID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconID: %w", err)
	}
	return oldValue.IconID, nil
}

// ResetIconID resets all changes to the "icon_id" field.
func (m *ProjectIconMutation) ResetIconID() {
	m.icon = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectIconMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectIconMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectIcon entity.
// If the ProjectIcon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectIconMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectIconMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectIconMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectIconMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProjectIcon entity.
// If the ProjectIcon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectIconMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectIconMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *ProjectIconMutation) AddProjectIDs(ids ...ulid.ID) {
	if m.projects == nil {
		m.projects = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *ProjectIconMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *ProjectIconMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *ProjectIconMutation) RemoveProjectIDs(ids ...ulid.ID) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *ProjectIconMutation) RemovedProjectsIDs() (ids []ulid.ID) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *ProjectIconMutation) ProjectsIDs() (ids []ulid.ID) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *ProjectIconMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// ClearIcon clears the "icon" edge to the Icon entity.
func (m *ProjectIconMutation) ClearIcon() {
	m.clearedicon = true
}

// IconCleared reports if the "icon" edge to the Icon entity was cleared.
func (m *ProjectIconMutation) IconCleared() bool {
	return m.clearedicon
}

// IconIDs returns the "icon" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IconID instead. It exists only for internal usage by the builders.
func (m *ProjectIconMutation) IconIDs() (ids []ulid.ID) {
	if id := m.icon; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIcon resets all changes to the "icon" edge.
func (m *ProjectIconMutation) ResetIcon() {
	m.icon = nil
	m.clearedicon = false
}

// Where appends a list predicates to the ProjectIconMutation builder.
func (m *ProjectIconMutation) Where(ps ...predicate.ProjectIcon) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProjectIconMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProjectIcon).
func (m *ProjectIconMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectIconMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.icon != nil {
		fields = append(fields, projecticon.FieldIconID)
	}
	if m.created_at != nil {
		fields = append(fields, projecticon.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, projecticon.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectIconMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projecticon.FieldIconID:
		return m.IconID()
	case projecticon.FieldCreatedAt:
		return m.CreatedAt()
	case projecticon.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectIconMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projecticon.FieldIconID:
		return m.OldIconID(ctx)
	case projecticon.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case projecticon.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectIcon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectIconMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projecticon.FieldIconID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconID(v)
		return nil
	case projecticon.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case projecticon.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectIcon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectIconMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectIconMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectIconMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectIcon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectIconMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectIconMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectIconMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProjectIcon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectIconMutation) ResetField(name string) error {
	switch name {
	case projecticon.FieldIconID:
		m.ResetIconID()
		return nil
	case projecticon.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case projecticon.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProjectIcon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectIconMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.projects != nil {
		edges = append(edges, projecticon.EdgeProjects)
	}
	if m.icon != nil {
		edges = append(edges, projecticon.EdgeIcon)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectIconMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projecticon.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case projecticon.EdgeIcon:
		if id := m.icon; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectIconMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedprojects != nil {
		edges = append(edges, projecticon.EdgeProjects)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectIconMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case projecticon.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectIconMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedprojects {
		edges = append(edges, projecticon.EdgeProjects)
	}
	if m.clearedicon {
		edges = append(edges, projecticon.EdgeIcon)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectIconMutation) EdgeCleared(name string) bool {
	switch name {
	case projecticon.EdgeProjects:
		return m.clearedprojects
	case projecticon.EdgeIcon:
		return m.clearedicon
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectIconMutation) ClearEdge(name string) error {
	switch name {
	case projecticon.EdgeIcon:
		m.ClearIcon()
		return nil
	}
	return fmt.Errorf("unknown ProjectIcon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectIconMutation) ResetEdge(name string) error {
	switch name {
	case projecticon.EdgeProjects:
		m.ResetProjects()
		return nil
	case projecticon.EdgeIcon:
		m.ResetIcon()
		return nil
	}
	return fmt.Errorf("unknown ProjectIcon edge %s", name)
}

// ProjectLightColorMutation represents an operation that mutates the ProjectLightColor nodes in the graph.
type ProjectLightColorMutation struct {
	config
	op              Op
	typ             string
	id              *ulid.ID
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	projects        map[ulid.ID]struct{}
	removedprojects map[ulid.ID]struct{}
	clearedprojects bool
	color           *ulid.ID
	clearedcolor    bool
	done            bool
	oldValue        func(context.Context) (*ProjectLightColor, error)
	predicates      []predicate.ProjectLightColor
}

var _ ent.Mutation = (*ProjectLightColorMutation)(nil)

// projectlightcolorOption allows management of the mutation configuration using functional options.
type projectlightcolorOption func(*ProjectLightColorMutation)

// newProjectLightColorMutation creates new mutation for the ProjectLightColor entity.
func newProjectLightColorMutation(c config, op Op, opts ...projectlightcolorOption) *ProjectLightColorMutation {
	m := &ProjectLightColorMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectLightColor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectLightColorID sets the ID field of the mutation.
func withProjectLightColorID(id ulid.ID) projectlightcolorOption {
	return func(m *ProjectLightColorMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectLightColor
		)
		m.oldValue = func(ctx context.Context) (*ProjectLightColor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectLightColor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectLightColor sets the old ProjectLightColor of the mutation.
func withProjectLightColor(node *ProjectLightColor) projectlightcolorOption {
	return func(m *ProjectLightColorMutation) {
		m.oldValue = func(context.Context) (*ProjectLightColor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectLightColorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectLightColorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProjectLightColor entities.
func (m *ProjectLightColorMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectLightColorMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectLightColorMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectLightColor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetColorID sets the "color_id" field.
func (m *ProjectLightColorMutation) SetColorID(u ulid.ID) {
	m.color = &u
}

// ColorID returns the value of the "color_id" field in the mutation.
func (m *ProjectLightColorMutation) ColorID() (r ulid.ID, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColorID returns the old "color_id" field's value of the ProjectLightColor entity.
// If the ProjectLightColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectLightColorMutation) OldColorID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColorID: %w", err)
	}
	return oldValue.ColorID, nil
}

// ResetColorID resets all changes to the "color_id" field.
func (m *ProjectLightColorMutation) ResetColorID() {
	m.color = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectLightColorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectLightColorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectLightColor entity.
// If the ProjectLightColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectLightColorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectLightColorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectLightColorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectLightColorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProjectLightColor entity.
// If the ProjectLightColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectLightColorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectLightColorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *ProjectLightColorMutation) AddProjectIDs(ids ...ulid.ID) {
	if m.projects == nil {
		m.projects = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *ProjectLightColorMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *ProjectLightColorMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *ProjectLightColorMutation) RemoveProjectIDs(ids ...ulid.ID) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *ProjectLightColorMutation) RemovedProjectsIDs() (ids []ulid.ID) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *ProjectLightColorMutation) ProjectsIDs() (ids []ulid.ID) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *ProjectLightColorMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// ClearColor clears the "color" edge to the Color entity.
func (m *ProjectLightColorMutation) ClearColor() {
	m.clearedcolor = true
}

// ColorCleared reports if the "color" edge to the Color entity was cleared.
func (m *ProjectLightColorMutation) ColorCleared() bool {
	return m.clearedcolor
}

// ColorIDs returns the "color" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ColorID instead. It exists only for internal usage by the builders.
func (m *ProjectLightColorMutation) ColorIDs() (ids []ulid.ID) {
	if id := m.color; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetColor resets all changes to the "color" edge.
func (m *ProjectLightColorMutation) ResetColor() {
	m.color = nil
	m.clearedcolor = false
}

// Where appends a list predicates to the ProjectLightColorMutation builder.
func (m *ProjectLightColorMutation) Where(ps ...predicate.ProjectLightColor) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProjectLightColorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProjectLightColor).
func (m *ProjectLightColorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectLightColorMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.color != nil {
		fields = append(fields, projectlightcolor.FieldColorID)
	}
	if m.created_at != nil {
		fields = append(fields, projectlightcolor.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, projectlightcolor.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectLightColorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectlightcolor.FieldColorID:
		return m.ColorID()
	case projectlightcolor.FieldCreatedAt:
		return m.CreatedAt()
	case projectlightcolor.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectLightColorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectlightcolor.FieldColorID:
		return m.OldColorID(ctx)
	case projectlightcolor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case projectlightcolor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectLightColor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectLightColorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectlightcolor.FieldColorID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColorID(v)
		return nil
	case projectlightcolor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case projectlightcolor.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectLightColor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectLightColorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectLightColorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectLightColorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectLightColor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectLightColorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectLightColorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectLightColorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProjectLightColor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectLightColorMutation) ResetField(name string) error {
	switch name {
	case projectlightcolor.FieldColorID:
		m.ResetColorID()
		return nil
	case projectlightcolor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case projectlightcolor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProjectLightColor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectLightColorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.projects != nil {
		edges = append(edges, projectlightcolor.EdgeProjects)
	}
	if m.color != nil {
		edges = append(edges, projectlightcolor.EdgeColor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectLightColorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectlightcolor.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case projectlightcolor.EdgeColor:
		if id := m.color; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectLightColorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedprojects != nil {
		edges = append(edges, projectlightcolor.EdgeProjects)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectLightColorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case projectlightcolor.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectLightColorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedprojects {
		edges = append(edges, projectlightcolor.EdgeProjects)
	}
	if m.clearedcolor {
		edges = append(edges, projectlightcolor.EdgeColor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectLightColorMutation) EdgeCleared(name string) bool {
	switch name {
	case projectlightcolor.EdgeProjects:
		return m.clearedprojects
	case projectlightcolor.EdgeColor:
		return m.clearedcolor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectLightColorMutation) ClearEdge(name string) error {
	switch name {
	case projectlightcolor.EdgeColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown ProjectLightColor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectLightColorMutation) ResetEdge(name string) error {
	switch name {
	case projectlightcolor.EdgeProjects:
		m.ResetProjects()
		return nil
	case projectlightcolor.EdgeColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown ProjectLightColor edge %s", name)
}

// ProjectTaskMutation represents an operation that mutates the ProjectTask nodes in the graph.
type ProjectTaskMutation struct {
	config
	op                        Op
	typ                       string
	id                        *ulid.ID
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	project                   *ulid.ID
	clearedproject            bool
	task                      *ulid.ID
	clearedtask               bool
	projectTaskSection        *ulid.ID
	clearedprojectTaskSection bool
	done                      bool
	oldValue                  func(context.Context) (*ProjectTask, error)
	predicates                []predicate.ProjectTask
}

var _ ent.Mutation = (*ProjectTaskMutation)(nil)

// projecttaskOption allows management of the mutation configuration using functional options.
type projecttaskOption func(*ProjectTaskMutation)

// newProjectTaskMutation creates new mutation for the ProjectTask entity.
func newProjectTaskMutation(c config, op Op, opts ...projecttaskOption) *ProjectTaskMutation {
	m := &ProjectTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectTaskID sets the ID field of the mutation.
func withProjectTaskID(id ulid.ID) projecttaskOption {
	return func(m *ProjectTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectTask
		)
		m.oldValue = func(ctx context.Context) (*ProjectTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectTask sets the old ProjectTask of the mutation.
func withProjectTask(node *ProjectTask) projecttaskOption {
	return func(m *ProjectTaskMutation) {
		m.oldValue = func(context.Context) (*ProjectTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProjectTask entities.
func (m *ProjectTaskMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectTaskMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectTaskMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectID sets the "project_id" field.
func (m *ProjectTaskMutation) SetProjectID(u ulid.ID) {
	m.project = &u
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ProjectTaskMutation) ProjectID() (r ulid.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldProjectID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ProjectTaskMutation) ResetProjectID() {
	m.project = nil
}

// SetTaskID sets the "task_id" field.
func (m *ProjectTaskMutation) SetTaskID(u ulid.ID) {
	m.task = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *ProjectTaskMutation) TaskID() (r ulid.ID, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldTaskID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *ProjectTaskMutation) ResetTaskID() {
	m.task = nil
}

// SetProjectTaskSectionID sets the "project_task_section_id" field.
func (m *ProjectTaskMutation) SetProjectTaskSectionID(u ulid.ID) {
	m.projectTaskSection = &u
}

// ProjectTaskSectionID returns the value of the "project_task_section_id" field in the mutation.
func (m *ProjectTaskMutation) ProjectTaskSectionID() (r ulid.ID, exists bool) {
	v := m.projectTaskSection
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectTaskSectionID returns the old "project_task_section_id" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldProjectTaskSectionID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectTaskSectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectTaskSectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectTaskSectionID: %w", err)
	}
	return oldValue.ProjectTaskSectionID, nil
}

// ResetProjectTaskSectionID resets all changes to the "project_task_section_id" field.
func (m *ProjectTaskMutation) ResetProjectTaskSectionID() {
	m.projectTaskSection = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectTaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectTaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectTaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectTaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectTaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProjectTask entity.
// If the ProjectTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectTaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectTaskMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectTaskMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectTaskMutation) ProjectIDs() (ids []ulid.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectTaskMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearTask clears the "task" edge to the Task entity.
func (m *ProjectTaskMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *ProjectTaskMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *ProjectTaskMutation) TaskIDs() (ids []ulid.ID) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *ProjectTaskMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// ClearProjectTaskSection clears the "projectTaskSection" edge to the ProjectTaskSection entity.
func (m *ProjectTaskMutation) ClearProjectTaskSection() {
	m.clearedprojectTaskSection = true
}

// ProjectTaskSectionCleared reports if the "projectTaskSection" edge to the ProjectTaskSection entity was cleared.
func (m *ProjectTaskMutation) ProjectTaskSectionCleared() bool {
	return m.clearedprojectTaskSection
}

// ProjectTaskSectionIDs returns the "projectTaskSection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectTaskSectionID instead. It exists only for internal usage by the builders.
func (m *ProjectTaskMutation) ProjectTaskSectionIDs() (ids []ulid.ID) {
	if id := m.projectTaskSection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProjectTaskSection resets all changes to the "projectTaskSection" edge.
func (m *ProjectTaskMutation) ResetProjectTaskSection() {
	m.projectTaskSection = nil
	m.clearedprojectTaskSection = false
}

// Where appends a list predicates to the ProjectTaskMutation builder.
func (m *ProjectTaskMutation) Where(ps ...predicate.ProjectTask) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProjectTaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProjectTask).
func (m *ProjectTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectTaskMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.project != nil {
		fields = append(fields, projecttask.FieldProjectID)
	}
	if m.task != nil {
		fields = append(fields, projecttask.FieldTaskID)
	}
	if m.projectTaskSection != nil {
		fields = append(fields, projecttask.FieldProjectTaskSectionID)
	}
	if m.created_at != nil {
		fields = append(fields, projecttask.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, projecttask.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projecttask.FieldProjectID:
		return m.ProjectID()
	case projecttask.FieldTaskID:
		return m.TaskID()
	case projecttask.FieldProjectTaskSectionID:
		return m.ProjectTaskSectionID()
	case projecttask.FieldCreatedAt:
		return m.CreatedAt()
	case projecttask.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projecttask.FieldProjectID:
		return m.OldProjectID(ctx)
	case projecttask.FieldTaskID:
		return m.OldTaskID(ctx)
	case projecttask.FieldProjectTaskSectionID:
		return m.OldProjectTaskSectionID(ctx)
	case projecttask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case projecttask.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projecttask.FieldProjectID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case projecttask.FieldTaskID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case projecttask.FieldProjectTaskSectionID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectTaskSectionID(v)
		return nil
	case projecttask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case projecttask.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectTaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectTaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectTaskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectTaskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProjectTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectTaskMutation) ResetField(name string) error {
	switch name {
	case projecttask.FieldProjectID:
		m.ResetProjectID()
		return nil
	case projecttask.FieldTaskID:
		m.ResetTaskID()
		return nil
	case projecttask.FieldProjectTaskSectionID:
		m.ResetProjectTaskSectionID()
		return nil
	case projecttask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case projecttask.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProjectTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.project != nil {
		edges = append(edges, projecttask.EdgeProject)
	}
	if m.task != nil {
		edges = append(edges, projecttask.EdgeTask)
	}
	if m.projectTaskSection != nil {
		edges = append(edges, projecttask.EdgeProjectTaskSection)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectTaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projecttask.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case projecttask.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case projecttask.EdgeProjectTaskSection:
		if id := m.projectTaskSection; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectTaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproject {
		edges = append(edges, projecttask.EdgeProject)
	}
	if m.clearedtask {
		edges = append(edges, projecttask.EdgeTask)
	}
	if m.clearedprojectTaskSection {
		edges = append(edges, projecttask.EdgeProjectTaskSection)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectTaskMutation) EdgeCleared(name string) bool {
	switch name {
	case projecttask.EdgeProject:
		return m.clearedproject
	case projecttask.EdgeTask:
		return m.clearedtask
	case projecttask.EdgeProjectTaskSection:
		return m.clearedprojectTaskSection
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectTaskMutation) ClearEdge(name string) error {
	switch name {
	case projecttask.EdgeProject:
		m.ClearProject()
		return nil
	case projecttask.EdgeTask:
		m.ClearTask()
		return nil
	case projecttask.EdgeProjectTaskSection:
		m.ClearProjectTaskSection()
		return nil
	}
	return fmt.Errorf("unknown ProjectTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectTaskMutation) ResetEdge(name string) error {
	switch name {
	case projecttask.EdgeProject:
		m.ResetProject()
		return nil
	case projecttask.EdgeTask:
		m.ResetTask()
		return nil
	case projecttask.EdgeProjectTaskSection:
		m.ResetProjectTaskSection()
		return nil
	}
	return fmt.Errorf("unknown ProjectTask edge %s", name)
}

// ProjectTaskColumnMutation represents an operation that mutates the ProjectTaskColumn nodes in the graph.
type ProjectTaskColumnMutation struct {
	config
	op                Op
	typ               string
	id                *ulid.ID
	width             *string
	disabled          *bool
	customizable      *bool
	_order            *int
	add_order         *int
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	project           *ulid.ID
	clearedproject    bool
	taskColumn        *ulid.ID
	clearedtaskColumn bool
	done              bool
	oldValue          func(context.Context) (*ProjectTaskColumn, error)
	predicates        []predicate.ProjectTaskColumn
}

var _ ent.Mutation = (*ProjectTaskColumnMutation)(nil)

// projecttaskcolumnOption allows management of the mutation configuration using functional options.
type projecttaskcolumnOption func(*ProjectTaskColumnMutation)

// newProjectTaskColumnMutation creates new mutation for the ProjectTaskColumn entity.
func newProjectTaskColumnMutation(c config, op Op, opts ...projecttaskcolumnOption) *ProjectTaskColumnMutation {
	m := &ProjectTaskColumnMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectTaskColumn,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectTaskColumnID sets the ID field of the mutation.
func withProjectTaskColumnID(id ulid.ID) projecttaskcolumnOption {
	return func(m *ProjectTaskColumnMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectTaskColumn
		)
		m.oldValue = func(ctx context.Context) (*ProjectTaskColumn, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectTaskColumn.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectTaskColumn sets the old ProjectTaskColumn of the mutation.
func withProjectTaskColumn(node *ProjectTaskColumn) projecttaskcolumnOption {
	return func(m *ProjectTaskColumnMutation) {
		m.oldValue = func(context.Context) (*ProjectTaskColumn, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectTaskColumnMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectTaskColumnMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProjectTaskColumn entities.
func (m *ProjectTaskColumnMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectTaskColumnMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectTaskColumnMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectTaskColumn.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectID sets the "project_id" field.
func (m *ProjectTaskColumnMutation) SetProjectID(u ulid.ID) {
	m.project = &u
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ProjectTaskColumnMutation) ProjectID() (r ulid.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the ProjectTaskColumn entity.
// If the ProjectTaskColumn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskColumnMutation) OldProjectID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ProjectTaskColumnMutation) ResetProjectID() {
	m.project = nil
}

// SetTaskColumnID sets the "task_column_id" field.
func (m *ProjectTaskColumnMutation) SetTaskColumnID(u ulid.ID) {
	m.taskColumn = &u
}

// TaskColumnID returns the value of the "task_column_id" field in the mutation.
func (m *ProjectTaskColumnMutation) TaskColumnID() (r ulid.ID, exists bool) {
	v := m.taskColumn
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskColumnID returns the old "task_column_id" field's value of the ProjectTaskColumn entity.
// If the ProjectTaskColumn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskColumnMutation) OldTaskColumnID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskColumnID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskColumnID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskColumnID: %w", err)
	}
	return oldValue.TaskColumnID, nil
}

// ResetTaskColumnID resets all changes to the "task_column_id" field.
func (m *ProjectTaskColumnMutation) ResetTaskColumnID() {
	m.taskColumn = nil
}

// SetWidth sets the "width" field.
func (m *ProjectTaskColumnMutation) SetWidth(s string) {
	m.width = &s
}

// Width returns the value of the "width" field in the mutation.
func (m *ProjectTaskColumnMutation) Width() (r string, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the ProjectTaskColumn entity.
// If the ProjectTaskColumn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskColumnMutation) OldWidth(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// ResetWidth resets all changes to the "width" field.
func (m *ProjectTaskColumnMutation) ResetWidth() {
	m.width = nil
}

// SetDisabled sets the "disabled" field.
func (m *ProjectTaskColumnMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *ProjectTaskColumnMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the ProjectTaskColumn entity.
// If the ProjectTaskColumn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskColumnMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *ProjectTaskColumnMutation) ResetDisabled() {
	m.disabled = nil
}

// SetCustomizable sets the "customizable" field.
func (m *ProjectTaskColumnMutation) SetCustomizable(b bool) {
	m.customizable = &b
}

// Customizable returns the value of the "customizable" field in the mutation.
func (m *ProjectTaskColumnMutation) Customizable() (r bool, exists bool) {
	v := m.customizable
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomizable returns the old "customizable" field's value of the ProjectTaskColumn entity.
// If the ProjectTaskColumn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskColumnMutation) OldCustomizable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomizable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomizable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomizable: %w", err)
	}
	return oldValue.Customizable, nil
}

// ResetCustomizable resets all changes to the "customizable" field.
func (m *ProjectTaskColumnMutation) ResetCustomizable() {
	m.customizable = nil
}

// SetOrder sets the "order" field.
func (m *ProjectTaskColumnMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *ProjectTaskColumnMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the ProjectTaskColumn entity.
// If the ProjectTaskColumn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskColumnMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *ProjectTaskColumnMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *ProjectTaskColumnMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *ProjectTaskColumnMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectTaskColumnMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectTaskColumnMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectTaskColumn entity.
// If the ProjectTaskColumn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskColumnMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectTaskColumnMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectTaskColumnMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectTaskColumnMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProjectTaskColumn entity.
// If the ProjectTaskColumn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskColumnMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectTaskColumnMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectTaskColumnMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectTaskColumnMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectTaskColumnMutation) ProjectIDs() (ids []ulid.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectTaskColumnMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearTaskColumn clears the "taskColumn" edge to the TaskColumn entity.
func (m *ProjectTaskColumnMutation) ClearTaskColumn() {
	m.clearedtaskColumn = true
}

// TaskColumnCleared reports if the "taskColumn" edge to the TaskColumn entity was cleared.
func (m *ProjectTaskColumnMutation) TaskColumnCleared() bool {
	return m.clearedtaskColumn
}

// TaskColumnIDs returns the "taskColumn" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskColumnID instead. It exists only for internal usage by the builders.
func (m *ProjectTaskColumnMutation) TaskColumnIDs() (ids []ulid.ID) {
	if id := m.taskColumn; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTaskColumn resets all changes to the "taskColumn" edge.
func (m *ProjectTaskColumnMutation) ResetTaskColumn() {
	m.taskColumn = nil
	m.clearedtaskColumn = false
}

// Where appends a list predicates to the ProjectTaskColumnMutation builder.
func (m *ProjectTaskColumnMutation) Where(ps ...predicate.ProjectTaskColumn) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProjectTaskColumnMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProjectTaskColumn).
func (m *ProjectTaskColumnMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectTaskColumnMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.project != nil {
		fields = append(fields, projecttaskcolumn.FieldProjectID)
	}
	if m.taskColumn != nil {
		fields = append(fields, projecttaskcolumn.FieldTaskColumnID)
	}
	if m.width != nil {
		fields = append(fields, projecttaskcolumn.FieldWidth)
	}
	if m.disabled != nil {
		fields = append(fields, projecttaskcolumn.FieldDisabled)
	}
	if m.customizable != nil {
		fields = append(fields, projecttaskcolumn.FieldCustomizable)
	}
	if m._order != nil {
		fields = append(fields, projecttaskcolumn.FieldOrder)
	}
	if m.created_at != nil {
		fields = append(fields, projecttaskcolumn.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, projecttaskcolumn.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectTaskColumnMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projecttaskcolumn.FieldProjectID:
		return m.ProjectID()
	case projecttaskcolumn.FieldTaskColumnID:
		return m.TaskColumnID()
	case projecttaskcolumn.FieldWidth:
		return m.Width()
	case projecttaskcolumn.FieldDisabled:
		return m.Disabled()
	case projecttaskcolumn.FieldCustomizable:
		return m.Customizable()
	case projecttaskcolumn.FieldOrder:
		return m.Order()
	case projecttaskcolumn.FieldCreatedAt:
		return m.CreatedAt()
	case projecttaskcolumn.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectTaskColumnMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projecttaskcolumn.FieldProjectID:
		return m.OldProjectID(ctx)
	case projecttaskcolumn.FieldTaskColumnID:
		return m.OldTaskColumnID(ctx)
	case projecttaskcolumn.FieldWidth:
		return m.OldWidth(ctx)
	case projecttaskcolumn.FieldDisabled:
		return m.OldDisabled(ctx)
	case projecttaskcolumn.FieldCustomizable:
		return m.OldCustomizable(ctx)
	case projecttaskcolumn.FieldOrder:
		return m.OldOrder(ctx)
	case projecttaskcolumn.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case projecttaskcolumn.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectTaskColumn field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTaskColumnMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projecttaskcolumn.FieldProjectID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case projecttaskcolumn.FieldTaskColumnID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskColumnID(v)
		return nil
	case projecttaskcolumn.FieldWidth:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case projecttaskcolumn.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case projecttaskcolumn.FieldCustomizable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomizable(v)
		return nil
	case projecttaskcolumn.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case projecttaskcolumn.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case projecttaskcolumn.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectTaskColumn field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectTaskColumnMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, projecttaskcolumn.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectTaskColumnMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case projecttaskcolumn.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTaskColumnMutation) AddField(name string, value ent.Value) error {
	switch name {
	case projecttaskcolumn.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectTaskColumn numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectTaskColumnMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectTaskColumnMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectTaskColumnMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProjectTaskColumn nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectTaskColumnMutation) ResetField(name string) error {
	switch name {
	case projecttaskcolumn.FieldProjectID:
		m.ResetProjectID()
		return nil
	case projecttaskcolumn.FieldTaskColumnID:
		m.ResetTaskColumnID()
		return nil
	case projecttaskcolumn.FieldWidth:
		m.ResetWidth()
		return nil
	case projecttaskcolumn.FieldDisabled:
		m.ResetDisabled()
		return nil
	case projecttaskcolumn.FieldCustomizable:
		m.ResetCustomizable()
		return nil
	case projecttaskcolumn.FieldOrder:
		m.ResetOrder()
		return nil
	case projecttaskcolumn.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case projecttaskcolumn.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProjectTaskColumn field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectTaskColumnMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, projecttaskcolumn.EdgeProject)
	}
	if m.taskColumn != nil {
		edges = append(edges, projecttaskcolumn.EdgeTaskColumn)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectTaskColumnMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projecttaskcolumn.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case projecttaskcolumn.EdgeTaskColumn:
		if id := m.taskColumn; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectTaskColumnMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectTaskColumnMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectTaskColumnMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, projecttaskcolumn.EdgeProject)
	}
	if m.clearedtaskColumn {
		edges = append(edges, projecttaskcolumn.EdgeTaskColumn)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectTaskColumnMutation) EdgeCleared(name string) bool {
	switch name {
	case projecttaskcolumn.EdgeProject:
		return m.clearedproject
	case projecttaskcolumn.EdgeTaskColumn:
		return m.clearedtaskColumn
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectTaskColumnMutation) ClearEdge(name string) error {
	switch name {
	case projecttaskcolumn.EdgeProject:
		m.ClearProject()
		return nil
	case projecttaskcolumn.EdgeTaskColumn:
		m.ClearTaskColumn()
		return nil
	}
	return fmt.Errorf("unknown ProjectTaskColumn unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectTaskColumnMutation) ResetEdge(name string) error {
	switch name {
	case projecttaskcolumn.EdgeProject:
		m.ResetProject()
		return nil
	case projecttaskcolumn.EdgeTaskColumn:
		m.ResetTaskColumn()
		return nil
	}
	return fmt.Errorf("unknown ProjectTaskColumn edge %s", name)
}

// ProjectTaskListStatusMutation represents an operation that mutates the ProjectTaskListStatus nodes in the graph.
type ProjectTaskListStatusMutation struct {
	config
	op                             Op
	typ                            string
	id                             *ulid.ID
	created_at                     *time.Time
	updated_at                     *time.Time
	clearedFields                  map[string]struct{}
	project                        *ulid.ID
	clearedproject                 bool
	taskListCompletedStatus        *ulid.ID
	clearedtaskListCompletedStatus bool
	taskListSortStatus             *ulid.ID
	clearedtaskListSortStatus      bool
	done                           bool
	oldValue                       func(context.Context) (*ProjectTaskListStatus, error)
	predicates                     []predicate.ProjectTaskListStatus
}

var _ ent.Mutation = (*ProjectTaskListStatusMutation)(nil)

// projecttaskliststatusOption allows management of the mutation configuration using functional options.
type projecttaskliststatusOption func(*ProjectTaskListStatusMutation)

// newProjectTaskListStatusMutation creates new mutation for the ProjectTaskListStatus entity.
func newProjectTaskListStatusMutation(c config, op Op, opts ...projecttaskliststatusOption) *ProjectTaskListStatusMutation {
	m := &ProjectTaskListStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectTaskListStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectTaskListStatusID sets the ID field of the mutation.
func withProjectTaskListStatusID(id ulid.ID) projecttaskliststatusOption {
	return func(m *ProjectTaskListStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectTaskListStatus
		)
		m.oldValue = func(ctx context.Context) (*ProjectTaskListStatus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectTaskListStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectTaskListStatus sets the old ProjectTaskListStatus of the mutation.
func withProjectTaskListStatus(node *ProjectTaskListStatus) projecttaskliststatusOption {
	return func(m *ProjectTaskListStatusMutation) {
		m.oldValue = func(context.Context) (*ProjectTaskListStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectTaskListStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectTaskListStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProjectTaskListStatus entities.
func (m *ProjectTaskListStatusMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectTaskListStatusMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectTaskListStatusMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectTaskListStatus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectID sets the "project_id" field.
func (m *ProjectTaskListStatusMutation) SetProjectID(u ulid.ID) {
	m.project = &u
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ProjectTaskListStatusMutation) ProjectID() (r ulid.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the ProjectTaskListStatus entity.
// If the ProjectTaskListStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskListStatusMutation) OldProjectID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ProjectTaskListStatusMutation) ResetProjectID() {
	m.project = nil
}

// SetTaskListCompletedStatusID sets the "task_list_completed_status_id" field.
func (m *ProjectTaskListStatusMutation) SetTaskListCompletedStatusID(u ulid.ID) {
	m.taskListCompletedStatus = &u
}

// TaskListCompletedStatusID returns the value of the "task_list_completed_status_id" field in the mutation.
func (m *ProjectTaskListStatusMutation) TaskListCompletedStatusID() (r ulid.ID, exists bool) {
	v := m.taskListCompletedStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskListCompletedStatusID returns the old "task_list_completed_status_id" field's value of the ProjectTaskListStatus entity.
// If the ProjectTaskListStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskListStatusMutation) OldTaskListCompletedStatusID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskListCompletedStatusID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskListCompletedStatusID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskListCompletedStatusID: %w", err)
	}
	return oldValue.TaskListCompletedStatusID, nil
}

// ResetTaskListCompletedStatusID resets all changes to the "task_list_completed_status_id" field.
func (m *ProjectTaskListStatusMutation) ResetTaskListCompletedStatusID() {
	m.taskListCompletedStatus = nil
}

// SetTaskListSortStatusID sets the "task_list_sort_status_id" field.
func (m *ProjectTaskListStatusMutation) SetTaskListSortStatusID(u ulid.ID) {
	m.taskListSortStatus = &u
}

// TaskListSortStatusID returns the value of the "task_list_sort_status_id" field in the mutation.
func (m *ProjectTaskListStatusMutation) TaskListSortStatusID() (r ulid.ID, exists bool) {
	v := m.taskListSortStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskListSortStatusID returns the old "task_list_sort_status_id" field's value of the ProjectTaskListStatus entity.
// If the ProjectTaskListStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskListStatusMutation) OldTaskListSortStatusID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskListSortStatusID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskListSortStatusID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskListSortStatusID: %w", err)
	}
	return oldValue.TaskListSortStatusID, nil
}

// ResetTaskListSortStatusID resets all changes to the "task_list_sort_status_id" field.
func (m *ProjectTaskListStatusMutation) ResetTaskListSortStatusID() {
	m.taskListSortStatus = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectTaskListStatusMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectTaskListStatusMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectTaskListStatus entity.
// If the ProjectTaskListStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskListStatusMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectTaskListStatusMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectTaskListStatusMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectTaskListStatusMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProjectTaskListStatus entity.
// If the ProjectTaskListStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskListStatusMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectTaskListStatusMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectTaskListStatusMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectTaskListStatusMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectTaskListStatusMutation) ProjectIDs() (ids []ulid.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectTaskListStatusMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearTaskListCompletedStatus clears the "taskListCompletedStatus" edge to the TaskListCompletedStatus entity.
func (m *ProjectTaskListStatusMutation) ClearTaskListCompletedStatus() {
	m.clearedtaskListCompletedStatus = true
}

// TaskListCompletedStatusCleared reports if the "taskListCompletedStatus" edge to the TaskListCompletedStatus entity was cleared.
func (m *ProjectTaskListStatusMutation) TaskListCompletedStatusCleared() bool {
	return m.clearedtaskListCompletedStatus
}

// TaskListCompletedStatusIDs returns the "taskListCompletedStatus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskListCompletedStatusID instead. It exists only for internal usage by the builders.
func (m *ProjectTaskListStatusMutation) TaskListCompletedStatusIDs() (ids []ulid.ID) {
	if id := m.taskListCompletedStatus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTaskListCompletedStatus resets all changes to the "taskListCompletedStatus" edge.
func (m *ProjectTaskListStatusMutation) ResetTaskListCompletedStatus() {
	m.taskListCompletedStatus = nil
	m.clearedtaskListCompletedStatus = false
}

// ClearTaskListSortStatus clears the "taskListSortStatus" edge to the TaskListSortStatus entity.
func (m *ProjectTaskListStatusMutation) ClearTaskListSortStatus() {
	m.clearedtaskListSortStatus = true
}

// TaskListSortStatusCleared reports if the "taskListSortStatus" edge to the TaskListSortStatus entity was cleared.
func (m *ProjectTaskListStatusMutation) TaskListSortStatusCleared() bool {
	return m.clearedtaskListSortStatus
}

// TaskListSortStatusIDs returns the "taskListSortStatus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskListSortStatusID instead. It exists only for internal usage by the builders.
func (m *ProjectTaskListStatusMutation) TaskListSortStatusIDs() (ids []ulid.ID) {
	if id := m.taskListSortStatus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTaskListSortStatus resets all changes to the "taskListSortStatus" edge.
func (m *ProjectTaskListStatusMutation) ResetTaskListSortStatus() {
	m.taskListSortStatus = nil
	m.clearedtaskListSortStatus = false
}

// Where appends a list predicates to the ProjectTaskListStatusMutation builder.
func (m *ProjectTaskListStatusMutation) Where(ps ...predicate.ProjectTaskListStatus) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProjectTaskListStatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProjectTaskListStatus).
func (m *ProjectTaskListStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectTaskListStatusMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.project != nil {
		fields = append(fields, projecttaskliststatus.FieldProjectID)
	}
	if m.taskListCompletedStatus != nil {
		fields = append(fields, projecttaskliststatus.FieldTaskListCompletedStatusID)
	}
	if m.taskListSortStatus != nil {
		fields = append(fields, projecttaskliststatus.FieldTaskListSortStatusID)
	}
	if m.created_at != nil {
		fields = append(fields, projecttaskliststatus.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, projecttaskliststatus.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectTaskListStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projecttaskliststatus.FieldProjectID:
		return m.ProjectID()
	case projecttaskliststatus.FieldTaskListCompletedStatusID:
		return m.TaskListCompletedStatusID()
	case projecttaskliststatus.FieldTaskListSortStatusID:
		return m.TaskListSortStatusID()
	case projecttaskliststatus.FieldCreatedAt:
		return m.CreatedAt()
	case projecttaskliststatus.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectTaskListStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projecttaskliststatus.FieldProjectID:
		return m.OldProjectID(ctx)
	case projecttaskliststatus.FieldTaskListCompletedStatusID:
		return m.OldTaskListCompletedStatusID(ctx)
	case projecttaskliststatus.FieldTaskListSortStatusID:
		return m.OldTaskListSortStatusID(ctx)
	case projecttaskliststatus.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case projecttaskliststatus.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectTaskListStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTaskListStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projecttaskliststatus.FieldProjectID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case projecttaskliststatus.FieldTaskListCompletedStatusID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskListCompletedStatusID(v)
		return nil
	case projecttaskliststatus.FieldTaskListSortStatusID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskListSortStatusID(v)
		return nil
	case projecttaskliststatus.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case projecttaskliststatus.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectTaskListStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectTaskListStatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectTaskListStatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTaskListStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectTaskListStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectTaskListStatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectTaskListStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectTaskListStatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProjectTaskListStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectTaskListStatusMutation) ResetField(name string) error {
	switch name {
	case projecttaskliststatus.FieldProjectID:
		m.ResetProjectID()
		return nil
	case projecttaskliststatus.FieldTaskListCompletedStatusID:
		m.ResetTaskListCompletedStatusID()
		return nil
	case projecttaskliststatus.FieldTaskListSortStatusID:
		m.ResetTaskListSortStatusID()
		return nil
	case projecttaskliststatus.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case projecttaskliststatus.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProjectTaskListStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectTaskListStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.project != nil {
		edges = append(edges, projecttaskliststatus.EdgeProject)
	}
	if m.taskListCompletedStatus != nil {
		edges = append(edges, projecttaskliststatus.EdgeTaskListCompletedStatus)
	}
	if m.taskListSortStatus != nil {
		edges = append(edges, projecttaskliststatus.EdgeTaskListSortStatus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectTaskListStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projecttaskliststatus.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case projecttaskliststatus.EdgeTaskListCompletedStatus:
		if id := m.taskListCompletedStatus; id != nil {
			return []ent.Value{*id}
		}
	case projecttaskliststatus.EdgeTaskListSortStatus:
		if id := m.taskListSortStatus; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectTaskListStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectTaskListStatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectTaskListStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproject {
		edges = append(edges, projecttaskliststatus.EdgeProject)
	}
	if m.clearedtaskListCompletedStatus {
		edges = append(edges, projecttaskliststatus.EdgeTaskListCompletedStatus)
	}
	if m.clearedtaskListSortStatus {
		edges = append(edges, projecttaskliststatus.EdgeTaskListSortStatus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectTaskListStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case projecttaskliststatus.EdgeProject:
		return m.clearedproject
	case projecttaskliststatus.EdgeTaskListCompletedStatus:
		return m.clearedtaskListCompletedStatus
	case projecttaskliststatus.EdgeTaskListSortStatus:
		return m.clearedtaskListSortStatus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectTaskListStatusMutation) ClearEdge(name string) error {
	switch name {
	case projecttaskliststatus.EdgeProject:
		m.ClearProject()
		return nil
	case projecttaskliststatus.EdgeTaskListCompletedStatus:
		m.ClearTaskListCompletedStatus()
		return nil
	case projecttaskliststatus.EdgeTaskListSortStatus:
		m.ClearTaskListSortStatus()
		return nil
	}
	return fmt.Errorf("unknown ProjectTaskListStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectTaskListStatusMutation) ResetEdge(name string) error {
	switch name {
	case projecttaskliststatus.EdgeProject:
		m.ResetProject()
		return nil
	case projecttaskliststatus.EdgeTaskListCompletedStatus:
		m.ResetTaskListCompletedStatus()
		return nil
	case projecttaskliststatus.EdgeTaskListSortStatus:
		m.ResetTaskListSortStatus()
		return nil
	}
	return fmt.Errorf("unknown ProjectTaskListStatus edge %s", name)
}

// ProjectTaskSectionMutation represents an operation that mutates the ProjectTaskSection nodes in the graph.
type ProjectTaskSectionMutation struct {
	config
	op                  Op
	typ                 string
	id                  *ulid.ID
	name                *string
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	project             *ulid.ID
	clearedproject      bool
	projectTasks        map[ulid.ID]struct{}
	removedprojectTasks map[ulid.ID]struct{}
	clearedprojectTasks bool
	done                bool
	oldValue            func(context.Context) (*ProjectTaskSection, error)
	predicates          []predicate.ProjectTaskSection
}

var _ ent.Mutation = (*ProjectTaskSectionMutation)(nil)

// projecttasksectionOption allows management of the mutation configuration using functional options.
type projecttasksectionOption func(*ProjectTaskSectionMutation)

// newProjectTaskSectionMutation creates new mutation for the ProjectTaskSection entity.
func newProjectTaskSectionMutation(c config, op Op, opts ...projecttasksectionOption) *ProjectTaskSectionMutation {
	m := &ProjectTaskSectionMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectTaskSection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectTaskSectionID sets the ID field of the mutation.
func withProjectTaskSectionID(id ulid.ID) projecttasksectionOption {
	return func(m *ProjectTaskSectionMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectTaskSection
		)
		m.oldValue = func(ctx context.Context) (*ProjectTaskSection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectTaskSection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectTaskSection sets the old ProjectTaskSection of the mutation.
func withProjectTaskSection(node *ProjectTaskSection) projecttasksectionOption {
	return func(m *ProjectTaskSectionMutation) {
		m.oldValue = func(context.Context) (*ProjectTaskSection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectTaskSectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectTaskSectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProjectTaskSection entities.
func (m *ProjectTaskSectionMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectTaskSectionMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectTaskSectionMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectTaskSection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectID sets the "project_id" field.
func (m *ProjectTaskSectionMutation) SetProjectID(u ulid.ID) {
	m.project = &u
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ProjectTaskSectionMutation) ProjectID() (r ulid.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the ProjectTaskSection entity.
// If the ProjectTaskSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskSectionMutation) OldProjectID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ProjectTaskSectionMutation) ResetProjectID() {
	m.project = nil
}

// SetName sets the "name" field.
func (m *ProjectTaskSectionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectTaskSectionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProjectTaskSection entity.
// If the ProjectTaskSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskSectionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectTaskSectionMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectTaskSectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectTaskSectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectTaskSection entity.
// If the ProjectTaskSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskSectionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectTaskSectionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectTaskSectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectTaskSectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProjectTaskSection entity.
// If the ProjectTaskSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTaskSectionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectTaskSectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectTaskSectionMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectTaskSectionMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectTaskSectionMutation) ProjectIDs() (ids []ulid.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectTaskSectionMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddProjectTaskIDs adds the "projectTasks" edge to the ProjectTask entity by ids.
func (m *ProjectTaskSectionMutation) AddProjectTaskIDs(ids ...ulid.ID) {
	if m.projectTasks == nil {
		m.projectTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.projectTasks[ids[i]] = struct{}{}
	}
}

// ClearProjectTasks clears the "projectTasks" edge to the ProjectTask entity.
func (m *ProjectTaskSectionMutation) ClearProjectTasks() {
	m.clearedprojectTasks = true
}

// ProjectTasksCleared reports if the "projectTasks" edge to the ProjectTask entity was cleared.
func (m *ProjectTaskSectionMutation) ProjectTasksCleared() bool {
	return m.clearedprojectTasks
}

// RemoveProjectTaskIDs removes the "projectTasks" edge to the ProjectTask entity by IDs.
func (m *ProjectTaskSectionMutation) RemoveProjectTaskIDs(ids ...ulid.ID) {
	if m.removedprojectTasks == nil {
		m.removedprojectTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.projectTasks, ids[i])
		m.removedprojectTasks[ids[i]] = struct{}{}
	}
}

// RemovedProjectTasks returns the removed IDs of the "projectTasks" edge to the ProjectTask entity.
func (m *ProjectTaskSectionMutation) RemovedProjectTasksIDs() (ids []ulid.ID) {
	for id := range m.removedprojectTasks {
		ids = append(ids, id)
	}
	return
}

// ProjectTasksIDs returns the "projectTasks" edge IDs in the mutation.
func (m *ProjectTaskSectionMutation) ProjectTasksIDs() (ids []ulid.ID) {
	for id := range m.projectTasks {
		ids = append(ids, id)
	}
	return
}

// ResetProjectTasks resets all changes to the "projectTasks" edge.
func (m *ProjectTaskSectionMutation) ResetProjectTasks() {
	m.projectTasks = nil
	m.clearedprojectTasks = false
	m.removedprojectTasks = nil
}

// Where appends a list predicates to the ProjectTaskSectionMutation builder.
func (m *ProjectTaskSectionMutation) Where(ps ...predicate.ProjectTaskSection) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProjectTaskSectionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProjectTaskSection).
func (m *ProjectTaskSectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectTaskSectionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.project != nil {
		fields = append(fields, projecttasksection.FieldProjectID)
	}
	if m.name != nil {
		fields = append(fields, projecttasksection.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, projecttasksection.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, projecttasksection.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectTaskSectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projecttasksection.FieldProjectID:
		return m.ProjectID()
	case projecttasksection.FieldName:
		return m.Name()
	case projecttasksection.FieldCreatedAt:
		return m.CreatedAt()
	case projecttasksection.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectTaskSectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projecttasksection.FieldProjectID:
		return m.OldProjectID(ctx)
	case projecttasksection.FieldName:
		return m.OldName(ctx)
	case projecttasksection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case projecttasksection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectTaskSection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTaskSectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projecttasksection.FieldProjectID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case projecttasksection.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case projecttasksection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case projecttasksection.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectTaskSection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectTaskSectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectTaskSectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTaskSectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectTaskSection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectTaskSectionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectTaskSectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectTaskSectionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProjectTaskSection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectTaskSectionMutation) ResetField(name string) error {
	switch name {
	case projecttasksection.FieldProjectID:
		m.ResetProjectID()
		return nil
	case projecttasksection.FieldName:
		m.ResetName()
		return nil
	case projecttasksection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case projecttasksection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProjectTaskSection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectTaskSectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, projecttasksection.EdgeProject)
	}
	if m.projectTasks != nil {
		edges = append(edges, projecttasksection.EdgeProjectTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectTaskSectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projecttasksection.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case projecttasksection.EdgeProjectTasks:
		ids := make([]ent.Value, 0, len(m.projectTasks))
		for id := range m.projectTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectTaskSectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedprojectTasks != nil {
		edges = append(edges, projecttasksection.EdgeProjectTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectTaskSectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case projecttasksection.EdgeProjectTasks:
		ids := make([]ent.Value, 0, len(m.removedprojectTasks))
		for id := range m.removedprojectTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectTaskSectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, projecttasksection.EdgeProject)
	}
	if m.clearedprojectTasks {
		edges = append(edges, projecttasksection.EdgeProjectTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectTaskSectionMutation) EdgeCleared(name string) bool {
	switch name {
	case projecttasksection.EdgeProject:
		return m.clearedproject
	case projecttasksection.EdgeProjectTasks:
		return m.clearedprojectTasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectTaskSectionMutation) ClearEdge(name string) error {
	switch name {
	case projecttasksection.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown ProjectTaskSection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectTaskSectionMutation) ResetEdge(name string) error {
	switch name {
	case projecttasksection.EdgeProject:
		m.ResetProject()
		return nil
	case projecttasksection.EdgeProjectTasks:
		m.ResetProjectTasks()
		return nil
	}
	return fmt.Errorf("unknown ProjectTaskSection edge %s", name)
}

// ProjectTeammateMutation represents an operation that mutates the ProjectTeammate nodes in the graph.
type ProjectTeammateMutation struct {
	config
	op              Op
	typ             string
	id              *ulid.ID
	role            *string
	is_owner        *bool
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	project         *ulid.ID
	clearedproject  bool
	teammate        *ulid.ID
	clearedteammate bool
	done            bool
	oldValue        func(context.Context) (*ProjectTeammate, error)
	predicates      []predicate.ProjectTeammate
}

var _ ent.Mutation = (*ProjectTeammateMutation)(nil)

// projectteammateOption allows management of the mutation configuration using functional options.
type projectteammateOption func(*ProjectTeammateMutation)

// newProjectTeammateMutation creates new mutation for the ProjectTeammate entity.
func newProjectTeammateMutation(c config, op Op, opts ...projectteammateOption) *ProjectTeammateMutation {
	m := &ProjectTeammateMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectTeammate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectTeammateID sets the ID field of the mutation.
func withProjectTeammateID(id ulid.ID) projectteammateOption {
	return func(m *ProjectTeammateMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectTeammate
		)
		m.oldValue = func(ctx context.Context) (*ProjectTeammate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectTeammate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectTeammate sets the old ProjectTeammate of the mutation.
func withProjectTeammate(node *ProjectTeammate) projectteammateOption {
	return func(m *ProjectTeammateMutation) {
		m.oldValue = func(context.Context) (*ProjectTeammate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectTeammateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectTeammateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProjectTeammate entities.
func (m *ProjectTeammateMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectTeammateMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectTeammateMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectTeammate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectID sets the "project_id" field.
func (m *ProjectTeammateMutation) SetProjectID(u ulid.ID) {
	m.project = &u
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ProjectTeammateMutation) ProjectID() (r ulid.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the ProjectTeammate entity.
// If the ProjectTeammate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTeammateMutation) OldProjectID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ProjectTeammateMutation) ResetProjectID() {
	m.project = nil
}

// SetTeammateID sets the "teammate_id" field.
func (m *ProjectTeammateMutation) SetTeammateID(u ulid.ID) {
	m.teammate = &u
}

// TeammateID returns the value of the "teammate_id" field in the mutation.
func (m *ProjectTeammateMutation) TeammateID() (r ulid.ID, exists bool) {
	v := m.teammate
	if v == nil {
		return
	}
	return *v, true
}

// OldTeammateID returns the old "teammate_id" field's value of the ProjectTeammate entity.
// If the ProjectTeammate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTeammateMutation) OldTeammateID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeammateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeammateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeammateID: %w", err)
	}
	return oldValue.TeammateID, nil
}

// ResetTeammateID resets all changes to the "teammate_id" field.
func (m *ProjectTeammateMutation) ResetTeammateID() {
	m.teammate = nil
}

// SetRole sets the "role" field.
func (m *ProjectTeammateMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *ProjectTeammateMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the ProjectTeammate entity.
// If the ProjectTeammate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTeammateMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *ProjectTeammateMutation) ResetRole() {
	m.role = nil
}

// SetIsOwner sets the "is_owner" field.
func (m *ProjectTeammateMutation) SetIsOwner(b bool) {
	m.is_owner = &b
}

// IsOwner returns the value of the "is_owner" field in the mutation.
func (m *ProjectTeammateMutation) IsOwner() (r bool, exists bool) {
	v := m.is_owner
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOwner returns the old "is_owner" field's value of the ProjectTeammate entity.
// If the ProjectTeammate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTeammateMutation) OldIsOwner(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOwner: %w", err)
	}
	return oldValue.IsOwner, nil
}

// ResetIsOwner resets all changes to the "is_owner" field.
func (m *ProjectTeammateMutation) ResetIsOwner() {
	m.is_owner = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectTeammateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectTeammateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectTeammate entity.
// If the ProjectTeammate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTeammateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectTeammateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectTeammateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectTeammateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProjectTeammate entity.
// If the ProjectTeammate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTeammateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectTeammateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectTeammateMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectTeammateMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectTeammateMutation) ProjectIDs() (ids []ulid.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectTeammateMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearTeammate clears the "teammate" edge to the Teammate entity.
func (m *ProjectTeammateMutation) ClearTeammate() {
	m.clearedteammate = true
}

// TeammateCleared reports if the "teammate" edge to the Teammate entity was cleared.
func (m *ProjectTeammateMutation) TeammateCleared() bool {
	return m.clearedteammate
}

// TeammateIDs returns the "teammate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeammateID instead. It exists only for internal usage by the builders.
func (m *ProjectTeammateMutation) TeammateIDs() (ids []ulid.ID) {
	if id := m.teammate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeammate resets all changes to the "teammate" edge.
func (m *ProjectTeammateMutation) ResetTeammate() {
	m.teammate = nil
	m.clearedteammate = false
}

// Where appends a list predicates to the ProjectTeammateMutation builder.
func (m *ProjectTeammateMutation) Where(ps ...predicate.ProjectTeammate) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProjectTeammateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProjectTeammate).
func (m *ProjectTeammateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectTeammateMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.project != nil {
		fields = append(fields, projectteammate.FieldProjectID)
	}
	if m.teammate != nil {
		fields = append(fields, projectteammate.FieldTeammateID)
	}
	if m.role != nil {
		fields = append(fields, projectteammate.FieldRole)
	}
	if m.is_owner != nil {
		fields = append(fields, projectteammate.FieldIsOwner)
	}
	if m.created_at != nil {
		fields = append(fields, projectteammate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, projectteammate.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectTeammateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectteammate.FieldProjectID:
		return m.ProjectID()
	case projectteammate.FieldTeammateID:
		return m.TeammateID()
	case projectteammate.FieldRole:
		return m.Role()
	case projectteammate.FieldIsOwner:
		return m.IsOwner()
	case projectteammate.FieldCreatedAt:
		return m.CreatedAt()
	case projectteammate.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectTeammateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectteammate.FieldProjectID:
		return m.OldProjectID(ctx)
	case projectteammate.FieldTeammateID:
		return m.OldTeammateID(ctx)
	case projectteammate.FieldRole:
		return m.OldRole(ctx)
	case projectteammate.FieldIsOwner:
		return m.OldIsOwner(ctx)
	case projectteammate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case projectteammate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectTeammate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTeammateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectteammate.FieldProjectID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case projectteammate.FieldTeammateID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeammateID(v)
		return nil
	case projectteammate.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case projectteammate.FieldIsOwner:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOwner(v)
		return nil
	case projectteammate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case projectteammate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectTeammate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectTeammateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectTeammateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTeammateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectTeammate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectTeammateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectTeammateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectTeammateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProjectTeammate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectTeammateMutation) ResetField(name string) error {
	switch name {
	case projectteammate.FieldProjectID:
		m.ResetProjectID()
		return nil
	case projectteammate.FieldTeammateID:
		m.ResetTeammateID()
		return nil
	case projectteammate.FieldRole:
		m.ResetRole()
		return nil
	case projectteammate.FieldIsOwner:
		m.ResetIsOwner()
		return nil
	case projectteammate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case projectteammate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProjectTeammate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectTeammateMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, projectteammate.EdgeProject)
	}
	if m.teammate != nil {
		edges = append(edges, projectteammate.EdgeTeammate)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectTeammateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectteammate.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case projectteammate.EdgeTeammate:
		if id := m.teammate; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectTeammateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectTeammateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectTeammateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, projectteammate.EdgeProject)
	}
	if m.clearedteammate {
		edges = append(edges, projectteammate.EdgeTeammate)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectTeammateMutation) EdgeCleared(name string) bool {
	switch name {
	case projectteammate.EdgeProject:
		return m.clearedproject
	case projectteammate.EdgeTeammate:
		return m.clearedteammate
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectTeammateMutation) ClearEdge(name string) error {
	switch name {
	case projectteammate.EdgeProject:
		m.ClearProject()
		return nil
	case projectteammate.EdgeTeammate:
		m.ClearTeammate()
		return nil
	}
	return fmt.Errorf("unknown ProjectTeammate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectTeammateMutation) ResetEdge(name string) error {
	switch name {
	case projectteammate.EdgeProject:
		m.ResetProject()
		return nil
	case projectteammate.EdgeTeammate:
		m.ResetTeammate()
		return nil
	}
	return fmt.Errorf("unknown ProjectTeammate edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op               Op
	typ              string
	id               *ulid.ID
	name             *string
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	workspace        *ulid.ID
	clearedworkspace bool
	color            *ulid.ID
	clearedcolor     bool
	taskTags         map[ulid.ID]struct{}
	removedtaskTags  map[ulid.ID]struct{}
	clearedtaskTags  bool
	done             bool
	oldValue         func(context.Context) (*Tag, error)
	predicates       []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id ulid.ID) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkspaceID sets the "workspace_id" field.
func (m *TagMutation) SetWorkspaceID(u ulid.ID) {
	m.workspace = &u
}

// WorkspaceID returns the value of the "workspace_id" field in the mutation.
func (m *TagMutation) WorkspaceID() (r ulid.ID, exists bool) {
	v := m.workspace
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspaceID returns the old "workspace_id" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldWorkspaceID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspaceID: %w", err)
	}
	return oldValue.WorkspaceID, nil
}

// ResetWorkspaceID resets all changes to the "workspace_id" field.
func (m *TagMutation) ResetWorkspaceID() {
	m.workspace = nil
}

// SetColorID sets the "color_id" field.
func (m *TagMutation) SetColorID(u ulid.ID) {
	m.color = &u
}

// ColorID returns the value of the "color_id" field in the mutation.
func (m *TagMutation) ColorID() (r ulid.ID, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColorID returns the old "color_id" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldColorID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColorID: %w", err)
	}
	return oldValue.ColorID, nil
}

// ResetColorID resets all changes to the "color_id" field.
func (m *TagMutation) ResetColorID() {
	m.color = nil
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearWorkspace clears the "workspace" edge to the Workspace entity.
func (m *TagMutation) ClearWorkspace() {
	m.clearedworkspace = true
}

// WorkspaceCleared reports if the "workspace" edge to the Workspace entity was cleared.
func (m *TagMutation) WorkspaceCleared() bool {
	return m.clearedworkspace
}

// WorkspaceIDs returns the "workspace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkspaceID instead. It exists only for internal usage by the builders.
func (m *TagMutation) WorkspaceIDs() (ids []ulid.ID) {
	if id := m.workspace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkspace resets all changes to the "workspace" edge.
func (m *TagMutation) ResetWorkspace() {
	m.workspace = nil
	m.clearedworkspace = false
}

// ClearColor clears the "color" edge to the Color entity.
func (m *TagMutation) ClearColor() {
	m.clearedcolor = true
}

// ColorCleared reports if the "color" edge to the Color entity was cleared.
func (m *TagMutation) ColorCleared() bool {
	return m.clearedcolor
}

// ColorIDs returns the "color" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ColorID instead. It exists only for internal usage by the builders.
func (m *TagMutation) ColorIDs() (ids []ulid.ID) {
	if id := m.color; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetColor resets all changes to the "color" edge.
func (m *TagMutation) ResetColor() {
	m.color = nil
	m.clearedcolor = false
}

// AddTaskTagIDs adds the "taskTags" edge to the TaskTag entity by ids.
func (m *TagMutation) AddTaskTagIDs(ids ...ulid.ID) {
	if m.taskTags == nil {
		m.taskTags = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.taskTags[ids[i]] = struct{}{}
	}
}

// ClearTaskTags clears the "taskTags" edge to the TaskTag entity.
func (m *TagMutation) ClearTaskTags() {
	m.clearedtaskTags = true
}

// TaskTagsCleared reports if the "taskTags" edge to the TaskTag entity was cleared.
func (m *TagMutation) TaskTagsCleared() bool {
	return m.clearedtaskTags
}

// RemoveTaskTagIDs removes the "taskTags" edge to the TaskTag entity by IDs.
func (m *TagMutation) RemoveTaskTagIDs(ids ...ulid.ID) {
	if m.removedtaskTags == nil {
		m.removedtaskTags = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.taskTags, ids[i])
		m.removedtaskTags[ids[i]] = struct{}{}
	}
}

// RemovedTaskTags returns the removed IDs of the "taskTags" edge to the TaskTag entity.
func (m *TagMutation) RemovedTaskTagsIDs() (ids []ulid.ID) {
	for id := range m.removedtaskTags {
		ids = append(ids, id)
	}
	return
}

// TaskTagsIDs returns the "taskTags" edge IDs in the mutation.
func (m *TagMutation) TaskTagsIDs() (ids []ulid.ID) {
	for id := range m.taskTags {
		ids = append(ids, id)
	}
	return
}

// ResetTaskTags resets all changes to the "taskTags" edge.
func (m *TagMutation) ResetTaskTags() {
	m.taskTags = nil
	m.clearedtaskTags = false
	m.removedtaskTags = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.workspace != nil {
		fields = append(fields, tag.FieldWorkspaceID)
	}
	if m.color != nil {
		fields = append(fields, tag.FieldColorID)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tag.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldWorkspaceID:
		return m.WorkspaceID()
	case tag.FieldColorID:
		return m.ColorID()
	case tag.FieldName:
		return m.Name()
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	case tag.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldWorkspaceID:
		return m.OldWorkspaceID(ctx)
	case tag.FieldColorID:
		return m.OldColorID(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldWorkspaceID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspaceID(v)
		return nil
	case tag.FieldColorID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColorID(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldWorkspaceID:
		m.ResetWorkspaceID()
		return nil
	case tag.FieldColorID:
		m.ResetColorID()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.workspace != nil {
		edges = append(edges, tag.EdgeWorkspace)
	}
	if m.color != nil {
		edges = append(edges, tag.EdgeColor)
	}
	if m.taskTags != nil {
		edges = append(edges, tag.EdgeTaskTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeWorkspace:
		if id := m.workspace; id != nil {
			return []ent.Value{*id}
		}
	case tag.EdgeColor:
		if id := m.color; id != nil {
			return []ent.Value{*id}
		}
	case tag.EdgeTaskTags:
		ids := make([]ent.Value, 0, len(m.taskTags))
		for id := range m.taskTags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtaskTags != nil {
		edges = append(edges, tag.EdgeTaskTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeTaskTags:
		ids := make([]ent.Value, 0, len(m.removedtaskTags))
		for id := range m.removedtaskTags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedworkspace {
		edges = append(edges, tag.EdgeWorkspace)
	}
	if m.clearedcolor {
		edges = append(edges, tag.EdgeColor)
	}
	if m.clearedtaskTags {
		edges = append(edges, tag.EdgeTaskTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeWorkspace:
		return m.clearedworkspace
	case tag.EdgeColor:
		return m.clearedcolor
	case tag.EdgeTaskTags:
		return m.clearedtaskTags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	case tag.EdgeWorkspace:
		m.ClearWorkspace()
		return nil
	case tag.EdgeColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeWorkspace:
		m.ResetWorkspace()
		return nil
	case tag.EdgeColor:
		m.ResetColor()
		return nil
	case tag.EdgeTaskTags:
		m.ResetTaskTags()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op                                    Op
	typ                                   string
	id                                    *ulid.ID
	created_by                            *ulid.ID
	completed                             *bool
	completed_at                          *time.Time
	is_new                                *bool
	name                                  *string
	due_date                              *time.Time
	due_time                              *time.Time
	description                           *map[string]interface{}
	created_at                            *time.Time
	updated_at                            *time.Time
	clearedFields                         map[string]struct{}
	teammate                              *ulid.ID
	clearedteammate                       bool
	taskPriority                          *ulid.ID
	clearedtaskPriority                   bool
	subTasks                              map[ulid.ID]struct{}
	removedsubTasks                       map[ulid.ID]struct{}
	clearedsubTasks                       bool
	parentTask                            *ulid.ID
	clearedparentTask                     bool
	teammateTasks                         map[ulid.ID]struct{}
	removedteammateTasks                  map[ulid.ID]struct{}
	clearedteammateTasks                  bool
	projectTasks                          map[ulid.ID]struct{}
	removedprojectTasks                   map[ulid.ID]struct{}
	clearedprojectTasks                   bool
	taskLikes                             map[ulid.ID]struct{}
	removedtaskLikes                      map[ulid.ID]struct{}
	clearedtaskLikes                      bool
	taskTags                              map[ulid.ID]struct{}
	removedtaskTags                       map[ulid.ID]struct{}
	clearedtaskTags                       bool
	taskCollaborators                     map[ulid.ID]struct{}
	removedtaskCollaborators              map[ulid.ID]struct{}
	clearedtaskCollaborators              bool
	taskFeeds                             map[ulid.ID]struct{}
	removedtaskFeeds                      map[ulid.ID]struct{}
	clearedtaskFeeds                      bool
	taskFeedLikes                         map[ulid.ID]struct{}
	removedtaskFeedLikes                  map[ulid.ID]struct{}
	clearedtaskFeedLikes                  bool
	taskFiles                             map[ulid.ID]struct{}
	removedtaskFiles                      map[ulid.ID]struct{}
	clearedtaskFiles                      bool
	deletedTasksRef                       map[ulid.ID]struct{}
	removeddeletedTasksRef                map[ulid.ID]struct{}
	cleareddeletedTasksRef                bool
	taskActivityTasks                     map[ulid.ID]struct{}
	removedtaskActivityTasks              map[ulid.ID]struct{}
	clearedtaskActivityTasks              bool
	workspaceActivityTasks                map[ulid.ID]struct{}
	removedworkspaceActivityTasks         map[ulid.ID]struct{}
	clearedworkspaceActivityTasks         bool
	archivedTaskActivityTasks             map[ulid.ID]struct{}
	removedarchivedTaskActivityTasks      map[ulid.ID]struct{}
	clearedarchivedTaskActivityTasks      bool
	archivedWorkspaceActivityTasks        map[ulid.ID]struct{}
	removedarchivedWorkspaceActivityTasks map[ulid.ID]struct{}
	clearedarchivedWorkspaceActivityTasks bool
	done                                  bool
	oldValue                              func(context.Context) (*Task, error)
	predicates                            []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id ulid.ID) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTaskParentID sets the "task_parent_id" field.
func (m *TaskMutation) SetTaskParentID(u ulid.ID) {
	m.parentTask = &u
}

// TaskParentID returns the value of the "task_parent_id" field in the mutation.
func (m *TaskMutation) TaskParentID() (r ulid.ID, exists bool) {
	v := m.parentTask
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskParentID returns the old "task_parent_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTaskParentID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskParentID: %w", err)
	}
	return oldValue.TaskParentID, nil
}

// ClearTaskParentID clears the value of the "task_parent_id" field.
func (m *TaskMutation) ClearTaskParentID() {
	m.parentTask = nil
	m.clearedFields[task.FieldTaskParentID] = struct{}{}
}

// TaskParentIDCleared returns if the "task_parent_id" field was cleared in this mutation.
func (m *TaskMutation) TaskParentIDCleared() bool {
	_, ok := m.clearedFields[task.FieldTaskParentID]
	return ok
}

// ResetTaskParentID resets all changes to the "task_parent_id" field.
func (m *TaskMutation) ResetTaskParentID() {
	m.parentTask = nil
	delete(m.clearedFields, task.FieldTaskParentID)
}

// SetTaskPriorityID sets the "task_priority_id" field.
func (m *TaskMutation) SetTaskPriorityID(u ulid.ID) {
	m.taskPriority = &u
}

// TaskPriorityID returns the value of the "task_priority_id" field in the mutation.
func (m *TaskMutation) TaskPriorityID() (r ulid.ID, exists bool) {
	v := m.taskPriority
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskPriorityID returns the old "task_priority_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTaskPriorityID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskPriorityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskPriorityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskPriorityID: %w", err)
	}
	return oldValue.TaskPriorityID, nil
}

// ClearTaskPriorityID clears the value of the "task_priority_id" field.
func (m *TaskMutation) ClearTaskPriorityID() {
	m.taskPriority = nil
	m.clearedFields[task.FieldTaskPriorityID] = struct{}{}
}

// TaskPriorityIDCleared returns if the "task_priority_id" field was cleared in this mutation.
func (m *TaskMutation) TaskPriorityIDCleared() bool {
	_, ok := m.clearedFields[task.FieldTaskPriorityID]
	return ok
}

// ResetTaskPriorityID resets all changes to the "task_priority_id" field.
func (m *TaskMutation) ResetTaskPriorityID() {
	m.taskPriority = nil
	delete(m.clearedFields, task.FieldTaskPriorityID)
}

// SetAssigneeID sets the "assignee_id" field.
func (m *TaskMutation) SetAssigneeID(u ulid.ID) {
	m.teammate = &u
}

// AssigneeID returns the value of the "assignee_id" field in the mutation.
func (m *TaskMutation) AssigneeID() (r ulid.ID, exists bool) {
	v := m.teammate
	if v == nil {
		return
	}
	return *v, true
}

// OldAssigneeID returns the old "assignee_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAssigneeID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssigneeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssigneeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssigneeID: %w", err)
	}
	return oldValue.AssigneeID, nil
}

// ClearAssigneeID clears the value of the "assignee_id" field.
func (m *TaskMutation) ClearAssigneeID() {
	m.teammate = nil
	m.clearedFields[task.FieldAssigneeID] = struct{}{}
}

// AssigneeIDCleared returns if the "assignee_id" field was cleared in this mutation.
func (m *TaskMutation) AssigneeIDCleared() bool {
	_, ok := m.clearedFields[task.FieldAssigneeID]
	return ok
}

// ResetAssigneeID resets all changes to the "assignee_id" field.
func (m *TaskMutation) ResetAssigneeID() {
	m.teammate = nil
	delete(m.clearedFields, task.FieldAssigneeID)
}

// SetCreatedBy sets the "created_by" field.
func (m *TaskMutation) SetCreatedBy(u ulid.ID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TaskMutation) CreatedBy() (r ulid.ID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedBy(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TaskMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetCompleted sets the "completed" field.
func (m *TaskMutation) SetCompleted(b bool) {
	m.completed = &b
}

// Completed returns the value of the "completed" field in the mutation.
func (m *TaskMutation) Completed() (r bool, exists bool) {
	v := m.completed
	if v == nil {
		return
	}
	return *v, true
}

// OldCompleted returns the old "completed" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCompleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompleted: %w", err)
	}
	return oldValue.Completed, nil
}

// ResetCompleted resets all changes to the "completed" field.
func (m *TaskMutation) ResetCompleted() {
	m.completed = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *TaskMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *TaskMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *TaskMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[task.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *TaskMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[task.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *TaskMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, task.FieldCompletedAt)
}

// SetIsNew sets the "is_new" field.
func (m *TaskMutation) SetIsNew(b bool) {
	m.is_new = &b
}

// IsNew returns the value of the "is_new" field in the mutation.
func (m *TaskMutation) IsNew() (r bool, exists bool) {
	v := m.is_new
	if v == nil {
		return
	}
	return *v, true
}

// OldIsNew returns the old "is_new" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldIsNew(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsNew is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsNew requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsNew: %w", err)
	}
	return oldValue.IsNew, nil
}

// ResetIsNew resets all changes to the "is_new" field.
func (m *TaskMutation) ResetIsNew() {
	m.is_new = nil
}

// SetName sets the "name" field.
func (m *TaskMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TaskMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TaskMutation) ResetName() {
	m.name = nil
}

// SetDueDate sets the "due_date" field.
func (m *TaskMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *TaskMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDueDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ClearDueDate clears the value of the "due_date" field.
func (m *TaskMutation) ClearDueDate() {
	m.due_date = nil
	m.clearedFields[task.FieldDueDate] = struct{}{}
}

// DueDateCleared returns if the "due_date" field was cleared in this mutation.
func (m *TaskMutation) DueDateCleared() bool {
	_, ok := m.clearedFields[task.FieldDueDate]
	return ok
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *TaskMutation) ResetDueDate() {
	m.due_date = nil
	delete(m.clearedFields, task.FieldDueDate)
}

// SetDueTime sets the "due_time" field.
func (m *TaskMutation) SetDueTime(t time.Time) {
	m.due_time = &t
}

// DueTime returns the value of the "due_time" field in the mutation.
func (m *TaskMutation) DueTime() (r time.Time, exists bool) {
	v := m.due_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDueTime returns the old "due_time" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDueTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueTime: %w", err)
	}
	return oldValue.DueTime, nil
}

// ClearDueTime clears the value of the "due_time" field.
func (m *TaskMutation) ClearDueTime() {
	m.due_time = nil
	m.clearedFields[task.FieldDueTime] = struct{}{}
}

// DueTimeCleared returns if the "due_time" field was cleared in this mutation.
func (m *TaskMutation) DueTimeCleared() bool {
	_, ok := m.clearedFields[task.FieldDueTime]
	return ok
}

// ResetDueTime resets all changes to the "due_time" field.
func (m *TaskMutation) ResetDueTime() {
	m.due_time = nil
	delete(m.clearedFields, task.FieldDueTime)
}

// SetDescription sets the "description" field.
func (m *TaskMutation) SetDescription(value map[string]interface{}) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *TaskMutation) Description() (r map[string]interface{}, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDescription(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TaskMutation) ResetDescription() {
	m.description = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTeammateID sets the "teammate" edge to the Teammate entity by id.
func (m *TaskMutation) SetTeammateID(id ulid.ID) {
	m.teammate = &id
}

// ClearTeammate clears the "teammate" edge to the Teammate entity.
func (m *TaskMutation) ClearTeammate() {
	m.clearedteammate = true
}

// TeammateCleared reports if the "teammate" edge to the Teammate entity was cleared.
func (m *TaskMutation) TeammateCleared() bool {
	return m.AssigneeIDCleared() || m.clearedteammate
}

// TeammateID returns the "teammate" edge ID in the mutation.
func (m *TaskMutation) TeammateID() (id ulid.ID, exists bool) {
	if m.teammate != nil {
		return *m.teammate, true
	}
	return
}

// TeammateIDs returns the "teammate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeammateID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) TeammateIDs() (ids []ulid.ID) {
	if id := m.teammate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeammate resets all changes to the "teammate" edge.
func (m *TaskMutation) ResetTeammate() {
	m.teammate = nil
	m.clearedteammate = false
}

// ClearTaskPriority clears the "taskPriority" edge to the TaskPriority entity.
func (m *TaskMutation) ClearTaskPriority() {
	m.clearedtaskPriority = true
}

// TaskPriorityCleared reports if the "taskPriority" edge to the TaskPriority entity was cleared.
func (m *TaskMutation) TaskPriorityCleared() bool {
	return m.TaskPriorityIDCleared() || m.clearedtaskPriority
}

// TaskPriorityIDs returns the "taskPriority" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskPriorityID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) TaskPriorityIDs() (ids []ulid.ID) {
	if id := m.taskPriority; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTaskPriority resets all changes to the "taskPriority" edge.
func (m *TaskMutation) ResetTaskPriority() {
	m.taskPriority = nil
	m.clearedtaskPriority = false
}

// AddSubTaskIDs adds the "subTasks" edge to the Task entity by ids.
func (m *TaskMutation) AddSubTaskIDs(ids ...ulid.ID) {
	if m.subTasks == nil {
		m.subTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.subTasks[ids[i]] = struct{}{}
	}
}

// ClearSubTasks clears the "subTasks" edge to the Task entity.
func (m *TaskMutation) ClearSubTasks() {
	m.clearedsubTasks = true
}

// SubTasksCleared reports if the "subTasks" edge to the Task entity was cleared.
func (m *TaskMutation) SubTasksCleared() bool {
	return m.clearedsubTasks
}

// RemoveSubTaskIDs removes the "subTasks" edge to the Task entity by IDs.
func (m *TaskMutation) RemoveSubTaskIDs(ids ...ulid.ID) {
	if m.removedsubTasks == nil {
		m.removedsubTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.subTasks, ids[i])
		m.removedsubTasks[ids[i]] = struct{}{}
	}
}

// RemovedSubTasks returns the removed IDs of the "subTasks" edge to the Task entity.
func (m *TaskMutation) RemovedSubTasksIDs() (ids []ulid.ID) {
	for id := range m.removedsubTasks {
		ids = append(ids, id)
	}
	return
}

// SubTasksIDs returns the "subTasks" edge IDs in the mutation.
func (m *TaskMutation) SubTasksIDs() (ids []ulid.ID) {
	for id := range m.subTasks {
		ids = append(ids, id)
	}
	return
}

// ResetSubTasks resets all changes to the "subTasks" edge.
func (m *TaskMutation) ResetSubTasks() {
	m.subTasks = nil
	m.clearedsubTasks = false
	m.removedsubTasks = nil
}

// SetParentTaskID sets the "parentTask" edge to the Task entity by id.
func (m *TaskMutation) SetParentTaskID(id ulid.ID) {
	m.parentTask = &id
}

// ClearParentTask clears the "parentTask" edge to the Task entity.
func (m *TaskMutation) ClearParentTask() {
	m.clearedparentTask = true
}

// ParentTaskCleared reports if the "parentTask" edge to the Task entity was cleared.
func (m *TaskMutation) ParentTaskCleared() bool {
	return m.TaskParentIDCleared() || m.clearedparentTask
}

// ParentTaskID returns the "parentTask" edge ID in the mutation.
func (m *TaskMutation) ParentTaskID() (id ulid.ID, exists bool) {
	if m.parentTask != nil {
		return *m.parentTask, true
	}
	return
}

// ParentTaskIDs returns the "parentTask" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentTaskID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) ParentTaskIDs() (ids []ulid.ID) {
	if id := m.parentTask; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentTask resets all changes to the "parentTask" edge.
func (m *TaskMutation) ResetParentTask() {
	m.parentTask = nil
	m.clearedparentTask = false
}

// AddTeammateTaskIDs adds the "teammateTasks" edge to the TeammateTask entity by ids.
func (m *TaskMutation) AddTeammateTaskIDs(ids ...ulid.ID) {
	if m.teammateTasks == nil {
		m.teammateTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.teammateTasks[ids[i]] = struct{}{}
	}
}

// ClearTeammateTasks clears the "teammateTasks" edge to the TeammateTask entity.
func (m *TaskMutation) ClearTeammateTasks() {
	m.clearedteammateTasks = true
}

// TeammateTasksCleared reports if the "teammateTasks" edge to the TeammateTask entity was cleared.
func (m *TaskMutation) TeammateTasksCleared() bool {
	return m.clearedteammateTasks
}

// RemoveTeammateTaskIDs removes the "teammateTasks" edge to the TeammateTask entity by IDs.
func (m *TaskMutation) RemoveTeammateTaskIDs(ids ...ulid.ID) {
	if m.removedteammateTasks == nil {
		m.removedteammateTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.teammateTasks, ids[i])
		m.removedteammateTasks[ids[i]] = struct{}{}
	}
}

// RemovedTeammateTasks returns the removed IDs of the "teammateTasks" edge to the TeammateTask entity.
func (m *TaskMutation) RemovedTeammateTasksIDs() (ids []ulid.ID) {
	for id := range m.removedteammateTasks {
		ids = append(ids, id)
	}
	return
}

// TeammateTasksIDs returns the "teammateTasks" edge IDs in the mutation.
func (m *TaskMutation) TeammateTasksIDs() (ids []ulid.ID) {
	for id := range m.teammateTasks {
		ids = append(ids, id)
	}
	return
}

// ResetTeammateTasks resets all changes to the "teammateTasks" edge.
func (m *TaskMutation) ResetTeammateTasks() {
	m.teammateTasks = nil
	m.clearedteammateTasks = false
	m.removedteammateTasks = nil
}

// AddProjectTaskIDs adds the "projectTasks" edge to the ProjectTask entity by ids.
func (m *TaskMutation) AddProjectTaskIDs(ids ...ulid.ID) {
	if m.projectTasks == nil {
		m.projectTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.projectTasks[ids[i]] = struct{}{}
	}
}

// ClearProjectTasks clears the "projectTasks" edge to the ProjectTask entity.
func (m *TaskMutation) ClearProjectTasks() {
	m.clearedprojectTasks = true
}

// ProjectTasksCleared reports if the "projectTasks" edge to the ProjectTask entity was cleared.
func (m *TaskMutation) ProjectTasksCleared() bool {
	return m.clearedprojectTasks
}

// RemoveProjectTaskIDs removes the "projectTasks" edge to the ProjectTask entity by IDs.
func (m *TaskMutation) RemoveProjectTaskIDs(ids ...ulid.ID) {
	if m.removedprojectTasks == nil {
		m.removedprojectTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.projectTasks, ids[i])
		m.removedprojectTasks[ids[i]] = struct{}{}
	}
}

// RemovedProjectTasks returns the removed IDs of the "projectTasks" edge to the ProjectTask entity.
func (m *TaskMutation) RemovedProjectTasksIDs() (ids []ulid.ID) {
	for id := range m.removedprojectTasks {
		ids = append(ids, id)
	}
	return
}

// ProjectTasksIDs returns the "projectTasks" edge IDs in the mutation.
func (m *TaskMutation) ProjectTasksIDs() (ids []ulid.ID) {
	for id := range m.projectTasks {
		ids = append(ids, id)
	}
	return
}

// ResetProjectTasks resets all changes to the "projectTasks" edge.
func (m *TaskMutation) ResetProjectTasks() {
	m.projectTasks = nil
	m.clearedprojectTasks = false
	m.removedprojectTasks = nil
}

// AddTaskLikeIDs adds the "taskLikes" edge to the TaskLike entity by ids.
func (m *TaskMutation) AddTaskLikeIDs(ids ...ulid.ID) {
	if m.taskLikes == nil {
		m.taskLikes = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.taskLikes[ids[i]] = struct{}{}
	}
}

// ClearTaskLikes clears the "taskLikes" edge to the TaskLike entity.
func (m *TaskMutation) ClearTaskLikes() {
	m.clearedtaskLikes = true
}

// TaskLikesCleared reports if the "taskLikes" edge to the TaskLike entity was cleared.
func (m *TaskMutation) TaskLikesCleared() bool {
	return m.clearedtaskLikes
}

// RemoveTaskLikeIDs removes the "taskLikes" edge to the TaskLike entity by IDs.
func (m *TaskMutation) RemoveTaskLikeIDs(ids ...ulid.ID) {
	if m.removedtaskLikes == nil {
		m.removedtaskLikes = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.taskLikes, ids[i])
		m.removedtaskLikes[ids[i]] = struct{}{}
	}
}

// RemovedTaskLikes returns the removed IDs of the "taskLikes" edge to the TaskLike entity.
func (m *TaskMutation) RemovedTaskLikesIDs() (ids []ulid.ID) {
	for id := range m.removedtaskLikes {
		ids = append(ids, id)
	}
	return
}

// TaskLikesIDs returns the "taskLikes" edge IDs in the mutation.
func (m *TaskMutation) TaskLikesIDs() (ids []ulid.ID) {
	for id := range m.taskLikes {
		ids = append(ids, id)
	}
	return
}

// ResetTaskLikes resets all changes to the "taskLikes" edge.
func (m *TaskMutation) ResetTaskLikes() {
	m.taskLikes = nil
	m.clearedtaskLikes = false
	m.removedtaskLikes = nil
}

// AddTaskTagIDs adds the "taskTags" edge to the TaskTag entity by ids.
func (m *TaskMutation) AddTaskTagIDs(ids ...ulid.ID) {
	if m.taskTags == nil {
		m.taskTags = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.taskTags[ids[i]] = struct{}{}
	}
}

// ClearTaskTags clears the "taskTags" edge to the TaskTag entity.
func (m *TaskMutation) ClearTaskTags() {
	m.clearedtaskTags = true
}

// TaskTagsCleared reports if the "taskTags" edge to the TaskTag entity was cleared.
func (m *TaskMutation) TaskTagsCleared() bool {
	return m.clearedtaskTags
}

// RemoveTaskTagIDs removes the "taskTags" edge to the TaskTag entity by IDs.
func (m *TaskMutation) RemoveTaskTagIDs(ids ...ulid.ID) {
	if m.removedtaskTags == nil {
		m.removedtaskTags = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.taskTags, ids[i])
		m.removedtaskTags[ids[i]] = struct{}{}
	}
}

// RemovedTaskTags returns the removed IDs of the "taskTags" edge to the TaskTag entity.
func (m *TaskMutation) RemovedTaskTagsIDs() (ids []ulid.ID) {
	for id := range m.removedtaskTags {
		ids = append(ids, id)
	}
	return
}

// TaskTagsIDs returns the "taskTags" edge IDs in the mutation.
func (m *TaskMutation) TaskTagsIDs() (ids []ulid.ID) {
	for id := range m.taskTags {
		ids = append(ids, id)
	}
	return
}

// ResetTaskTags resets all changes to the "taskTags" edge.
func (m *TaskMutation) ResetTaskTags() {
	m.taskTags = nil
	m.clearedtaskTags = false
	m.removedtaskTags = nil
}

// AddTaskCollaboratorIDs adds the "taskCollaborators" edge to the TaskCollaborator entity by ids.
func (m *TaskMutation) AddTaskCollaboratorIDs(ids ...ulid.ID) {
	if m.taskCollaborators == nil {
		m.taskCollaborators = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.taskCollaborators[ids[i]] = struct{}{}
	}
}

// ClearTaskCollaborators clears the "taskCollaborators" edge to the TaskCollaborator entity.
func (m *TaskMutation) ClearTaskCollaborators() {
	m.clearedtaskCollaborators = true
}

// TaskCollaboratorsCleared reports if the "taskCollaborators" edge to the TaskCollaborator entity was cleared.
func (m *TaskMutation) TaskCollaboratorsCleared() bool {
	return m.clearedtaskCollaborators
}

// RemoveTaskCollaboratorIDs removes the "taskCollaborators" edge to the TaskCollaborator entity by IDs.
func (m *TaskMutation) RemoveTaskCollaboratorIDs(ids ...ulid.ID) {
	if m.removedtaskCollaborators == nil {
		m.removedtaskCollaborators = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.taskCollaborators, ids[i])
		m.removedtaskCollaborators[ids[i]] = struct{}{}
	}
}

// RemovedTaskCollaborators returns the removed IDs of the "taskCollaborators" edge to the TaskCollaborator entity.
func (m *TaskMutation) RemovedTaskCollaboratorsIDs() (ids []ulid.ID) {
	for id := range m.removedtaskCollaborators {
		ids = append(ids, id)
	}
	return
}

// TaskCollaboratorsIDs returns the "taskCollaborators" edge IDs in the mutation.
func (m *TaskMutation) TaskCollaboratorsIDs() (ids []ulid.ID) {
	for id := range m.taskCollaborators {
		ids = append(ids, id)
	}
	return
}

// ResetTaskCollaborators resets all changes to the "taskCollaborators" edge.
func (m *TaskMutation) ResetTaskCollaborators() {
	m.taskCollaborators = nil
	m.clearedtaskCollaborators = false
	m.removedtaskCollaborators = nil
}

// AddTaskFeedIDs adds the "taskFeeds" edge to the TaskFeed entity by ids.
func (m *TaskMutation) AddTaskFeedIDs(ids ...ulid.ID) {
	if m.taskFeeds == nil {
		m.taskFeeds = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.taskFeeds[ids[i]] = struct{}{}
	}
}

// ClearTaskFeeds clears the "taskFeeds" edge to the TaskFeed entity.
func (m *TaskMutation) ClearTaskFeeds() {
	m.clearedtaskFeeds = true
}

// TaskFeedsCleared reports if the "taskFeeds" edge to the TaskFeed entity was cleared.
func (m *TaskMutation) TaskFeedsCleared() bool {
	return m.clearedtaskFeeds
}

// RemoveTaskFeedIDs removes the "taskFeeds" edge to the TaskFeed entity by IDs.
func (m *TaskMutation) RemoveTaskFeedIDs(ids ...ulid.ID) {
	if m.removedtaskFeeds == nil {
		m.removedtaskFeeds = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.taskFeeds, ids[i])
		m.removedtaskFeeds[ids[i]] = struct{}{}
	}
}

// RemovedTaskFeeds returns the removed IDs of the "taskFeeds" edge to the TaskFeed entity.
func (m *TaskMutation) RemovedTaskFeedsIDs() (ids []ulid.ID) {
	for id := range m.removedtaskFeeds {
		ids = append(ids, id)
	}
	return
}

// TaskFeedsIDs returns the "taskFeeds" edge IDs in the mutation.
func (m *TaskMutation) TaskFeedsIDs() (ids []ulid.ID) {
	for id := range m.taskFeeds {
		ids = append(ids, id)
	}
	return
}

// ResetTaskFeeds resets all changes to the "taskFeeds" edge.
func (m *TaskMutation) ResetTaskFeeds() {
	m.taskFeeds = nil
	m.clearedtaskFeeds = false
	m.removedtaskFeeds = nil
}

// AddTaskFeedLikeIDs adds the "taskFeedLikes" edge to the TaskFeedLike entity by ids.
func (m *TaskMutation) AddTaskFeedLikeIDs(ids ...ulid.ID) {
	if m.taskFeedLikes == nil {
		m.taskFeedLikes = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.taskFeedLikes[ids[i]] = struct{}{}
	}
}

// ClearTaskFeedLikes clears the "taskFeedLikes" edge to the TaskFeedLike entity.
func (m *TaskMutation) ClearTaskFeedLikes() {
	m.clearedtaskFeedLikes = true
}

// TaskFeedLikesCleared reports if the "taskFeedLikes" edge to the TaskFeedLike entity was cleared.
func (m *TaskMutation) TaskFeedLikesCleared() bool {
	return m.clearedtaskFeedLikes
}

// RemoveTaskFeedLikeIDs removes the "taskFeedLikes" edge to the TaskFeedLike entity by IDs.
func (m *TaskMutation) RemoveTaskFeedLikeIDs(ids ...ulid.ID) {
	if m.removedtaskFeedLikes == nil {
		m.removedtaskFeedLikes = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.taskFeedLikes, ids[i])
		m.removedtaskFeedLikes[ids[i]] = struct{}{}
	}
}

// RemovedTaskFeedLikes returns the removed IDs of the "taskFeedLikes" edge to the TaskFeedLike entity.
func (m *TaskMutation) RemovedTaskFeedLikesIDs() (ids []ulid.ID) {
	for id := range m.removedtaskFeedLikes {
		ids = append(ids, id)
	}
	return
}

// TaskFeedLikesIDs returns the "taskFeedLikes" edge IDs in the mutation.
func (m *TaskMutation) TaskFeedLikesIDs() (ids []ulid.ID) {
	for id := range m.taskFeedLikes {
		ids = append(ids, id)
	}
	return
}

// ResetTaskFeedLikes resets all changes to the "taskFeedLikes" edge.
func (m *TaskMutation) ResetTaskFeedLikes() {
	m.taskFeedLikes = nil
	m.clearedtaskFeedLikes = false
	m.removedtaskFeedLikes = nil
}

// AddTaskFileIDs adds the "taskFiles" edge to the TaskFile entity by ids.
func (m *TaskMutation) AddTaskFileIDs(ids ...ulid.ID) {
	if m.taskFiles == nil {
		m.taskFiles = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.taskFiles[ids[i]] = struct{}{}
	}
}

// ClearTaskFiles clears the "taskFiles" edge to the TaskFile entity.
func (m *TaskMutation) ClearTaskFiles() {
	m.clearedtaskFiles = true
}

// TaskFilesCleared reports if the "taskFiles" edge to the TaskFile entity was cleared.
func (m *TaskMutation) TaskFilesCleared() bool {
	return m.clearedtaskFiles
}

// RemoveTaskFileIDs removes the "taskFiles" edge to the TaskFile entity by IDs.
func (m *TaskMutation) RemoveTaskFileIDs(ids ...ulid.ID) {
	if m.removedtaskFiles == nil {
		m.removedtaskFiles = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.taskFiles, ids[i])
		m.removedtaskFiles[ids[i]] = struct{}{}
	}
}

// RemovedTaskFiles returns the removed IDs of the "taskFiles" edge to the TaskFile entity.
func (m *TaskMutation) RemovedTaskFilesIDs() (ids []ulid.ID) {
	for id := range m.removedtaskFiles {
		ids = append(ids, id)
	}
	return
}

// TaskFilesIDs returns the "taskFiles" edge IDs in the mutation.
func (m *TaskMutation) TaskFilesIDs() (ids []ulid.ID) {
	for id := range m.taskFiles {
		ids = append(ids, id)
	}
	return
}

// ResetTaskFiles resets all changes to the "taskFiles" edge.
func (m *TaskMutation) ResetTaskFiles() {
	m.taskFiles = nil
	m.clearedtaskFiles = false
	m.removedtaskFiles = nil
}

// AddDeletedTasksRefIDs adds the "deletedTasksRef" edge to the DeletedTask entity by ids.
func (m *TaskMutation) AddDeletedTasksRefIDs(ids ...ulid.ID) {
	if m.deletedTasksRef == nil {
		m.deletedTasksRef = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.deletedTasksRef[ids[i]] = struct{}{}
	}
}

// ClearDeletedTasksRef clears the "deletedTasksRef" edge to the DeletedTask entity.
func (m *TaskMutation) ClearDeletedTasksRef() {
	m.cleareddeletedTasksRef = true
}

// DeletedTasksRefCleared reports if the "deletedTasksRef" edge to the DeletedTask entity was cleared.
func (m *TaskMutation) DeletedTasksRefCleared() bool {
	return m.cleareddeletedTasksRef
}

// RemoveDeletedTasksRefIDs removes the "deletedTasksRef" edge to the DeletedTask entity by IDs.
func (m *TaskMutation) RemoveDeletedTasksRefIDs(ids ...ulid.ID) {
	if m.removeddeletedTasksRef == nil {
		m.removeddeletedTasksRef = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.deletedTasksRef, ids[i])
		m.removeddeletedTasksRef[ids[i]] = struct{}{}
	}
}

// RemovedDeletedTasksRef returns the removed IDs of the "deletedTasksRef" edge to the DeletedTask entity.
func (m *TaskMutation) RemovedDeletedTasksRefIDs() (ids []ulid.ID) {
	for id := range m.removeddeletedTasksRef {
		ids = append(ids, id)
	}
	return
}

// DeletedTasksRefIDs returns the "deletedTasksRef" edge IDs in the mutation.
func (m *TaskMutation) DeletedTasksRefIDs() (ids []ulid.ID) {
	for id := range m.deletedTasksRef {
		ids = append(ids, id)
	}
	return
}

// ResetDeletedTasksRef resets all changes to the "deletedTasksRef" edge.
func (m *TaskMutation) ResetDeletedTasksRef() {
	m.deletedTasksRef = nil
	m.cleareddeletedTasksRef = false
	m.removeddeletedTasksRef = nil
}

// AddTaskActivityTaskIDs adds the "taskActivityTasks" edge to the TaskActivityTask entity by ids.
func (m *TaskMutation) AddTaskActivityTaskIDs(ids ...ulid.ID) {
	if m.taskActivityTasks == nil {
		m.taskActivityTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.taskActivityTasks[ids[i]] = struct{}{}
	}
}

// ClearTaskActivityTasks clears the "taskActivityTasks" edge to the TaskActivityTask entity.
func (m *TaskMutation) ClearTaskActivityTasks() {
	m.clearedtaskActivityTasks = true
}

// TaskActivityTasksCleared reports if the "taskActivityTasks" edge to the TaskActivityTask entity was cleared.
func (m *TaskMutation) TaskActivityTasksCleared() bool {
	return m.clearedtaskActivityTasks
}

// RemoveTaskActivityTaskIDs removes the "taskActivityTasks" edge to the TaskActivityTask entity by IDs.
func (m *TaskMutation) RemoveTaskActivityTaskIDs(ids ...ulid.ID) {
	if m.removedtaskActivityTasks == nil {
		m.removedtaskActivityTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.taskActivityTasks, ids[i])
		m.removedtaskActivityTasks[ids[i]] = struct{}{}
	}
}

// RemovedTaskActivityTasks returns the removed IDs of the "taskActivityTasks" edge to the TaskActivityTask entity.
func (m *TaskMutation) RemovedTaskActivityTasksIDs() (ids []ulid.ID) {
	for id := range m.removedtaskActivityTasks {
		ids = append(ids, id)
	}
	return
}

// TaskActivityTasksIDs returns the "taskActivityTasks" edge IDs in the mutation.
func (m *TaskMutation) TaskActivityTasksIDs() (ids []ulid.ID) {
	for id := range m.taskActivityTasks {
		ids = append(ids, id)
	}
	return
}

// ResetTaskActivityTasks resets all changes to the "taskActivityTasks" edge.
func (m *TaskMutation) ResetTaskActivityTasks() {
	m.taskActivityTasks = nil
	m.clearedtaskActivityTasks = false
	m.removedtaskActivityTasks = nil
}

// AddWorkspaceActivityTaskIDs adds the "workspaceActivityTasks" edge to the WorkspaceActivityTask entity by ids.
func (m *TaskMutation) AddWorkspaceActivityTaskIDs(ids ...ulid.ID) {
	if m.workspaceActivityTasks == nil {
		m.workspaceActivityTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.workspaceActivityTasks[ids[i]] = struct{}{}
	}
}

// ClearWorkspaceActivityTasks clears the "workspaceActivityTasks" edge to the WorkspaceActivityTask entity.
func (m *TaskMutation) ClearWorkspaceActivityTasks() {
	m.clearedworkspaceActivityTasks = true
}

// WorkspaceActivityTasksCleared reports if the "workspaceActivityTasks" edge to the WorkspaceActivityTask entity was cleared.
func (m *TaskMutation) WorkspaceActivityTasksCleared() bool {
	return m.clearedworkspaceActivityTasks
}

// RemoveWorkspaceActivityTaskIDs removes the "workspaceActivityTasks" edge to the WorkspaceActivityTask entity by IDs.
func (m *TaskMutation) RemoveWorkspaceActivityTaskIDs(ids ...ulid.ID) {
	if m.removedworkspaceActivityTasks == nil {
		m.removedworkspaceActivityTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.workspaceActivityTasks, ids[i])
		m.removedworkspaceActivityTasks[ids[i]] = struct{}{}
	}
}

// RemovedWorkspaceActivityTasks returns the removed IDs of the "workspaceActivityTasks" edge to the WorkspaceActivityTask entity.
func (m *TaskMutation) RemovedWorkspaceActivityTasksIDs() (ids []ulid.ID) {
	for id := range m.removedworkspaceActivityTasks {
		ids = append(ids, id)
	}
	return
}

// WorkspaceActivityTasksIDs returns the "workspaceActivityTasks" edge IDs in the mutation.
func (m *TaskMutation) WorkspaceActivityTasksIDs() (ids []ulid.ID) {
	for id := range m.workspaceActivityTasks {
		ids = append(ids, id)
	}
	return
}

// ResetWorkspaceActivityTasks resets all changes to the "workspaceActivityTasks" edge.
func (m *TaskMutation) ResetWorkspaceActivityTasks() {
	m.workspaceActivityTasks = nil
	m.clearedworkspaceActivityTasks = false
	m.removedworkspaceActivityTasks = nil
}

// AddArchivedTaskActivityTaskIDs adds the "archivedTaskActivityTasks" edge to the ArchivedTaskActivityTask entity by ids.
func (m *TaskMutation) AddArchivedTaskActivityTaskIDs(ids ...ulid.ID) {
	if m.archivedTaskActivityTasks == nil {
		m.archivedTaskActivityTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.archivedTaskActivityTasks[ids[i]] = struct{}{}
	}
}

// ClearArchivedTaskActivityTasks clears the "archivedTaskActivityTasks" edge to the ArchivedTaskActivityTask entity.
func (m *TaskMutation) ClearArchivedTaskActivityTasks() {
	m.clearedarchivedTaskActivityTasks = true
}

// ArchivedTaskActivityTasksCleared reports if the "archivedTaskActivityTasks" edge to the ArchivedTaskActivityTask entity was cleared.
func (m *TaskMutation) ArchivedTaskActivityTasksCleared() bool {
	return m.clearedarchivedTaskActivityTasks
}

// RemoveArchivedTaskActivityTaskIDs removes the "archivedTaskActivityTasks" edge to the ArchivedTaskActivityTask entity by IDs.
func (m *TaskMutation) RemoveArchivedTaskActivityTaskIDs(ids ...ulid.ID) {
	if m.removedarchivedTaskActivityTasks == nil {
		m.removedarchivedTaskActivityTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.archivedTaskActivityTasks, ids[i])
		m.removedarchivedTaskActivityTasks[ids[i]] = struct{}{}
	}
}

// RemovedArchivedTaskActivityTasks returns the removed IDs of the "archivedTaskActivityTasks" edge to the ArchivedTaskActivityTask entity.
func (m *TaskMutation) RemovedArchivedTaskActivityTasksIDs() (ids []ulid.ID) {
	for id := range m.removedarchivedTaskActivityTasks {
		ids = append(ids, id)
	}
	return
}

// ArchivedTaskActivityTasksIDs returns the "archivedTaskActivityTasks" edge IDs in the mutation.
func (m *TaskMutation) ArchivedTaskActivityTasksIDs() (ids []ulid.ID) {
	for id := range m.archivedTaskActivityTasks {
		ids = append(ids, id)
	}
	return
}

// ResetArchivedTaskActivityTasks resets all changes to the "archivedTaskActivityTasks" edge.
func (m *TaskMutation) ResetArchivedTaskActivityTasks() {
	m.archivedTaskActivityTasks = nil
	m.clearedarchivedTaskActivityTasks = false
	m.removedarchivedTaskActivityTasks = nil
}

// AddArchivedWorkspaceActivityTaskIDs adds the "archivedWorkspaceActivityTasks" edge to the ArchivedWorkspaceActivityTask entity by ids.
func (m *TaskMutation) AddArchivedWorkspaceActivityTaskIDs(ids ...ulid.ID) {
	if m.archivedWorkspaceActivityTasks == nil {
		m.archivedWorkspaceActivityTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.archivedWorkspaceActivityTasks[ids[i]] = struct{}{}
	}
}

// ClearArchivedWorkspaceActivityTasks clears the "archivedWorkspaceActivityTasks" edge to the ArchivedWorkspaceActivityTask entity.
func (m *TaskMutation) ClearArchivedWorkspaceActivityTasks() {
	m.clearedarchivedWorkspaceActivityTasks = true
}

// ArchivedWorkspaceActivityTasksCleared reports if the "archivedWorkspaceActivityTasks" edge to the ArchivedWorkspaceActivityTask entity was cleared.
func (m *TaskMutation) ArchivedWorkspaceActivityTasksCleared() bool {
	return m.clearedarchivedWorkspaceActivityTasks
}

// RemoveArchivedWorkspaceActivityTaskIDs removes the "archivedWorkspaceActivityTasks" edge to the ArchivedWorkspaceActivityTask entity by IDs.
func (m *TaskMutation) RemoveArchivedWorkspaceActivityTaskIDs(ids ...ulid.ID) {
	if m.removedarchivedWorkspaceActivityTasks == nil {
		m.removedarchivedWorkspaceActivityTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.archivedWorkspaceActivityTasks, ids[i])
		m.removedarchivedWorkspaceActivityTasks[ids[i]] = struct{}{}
	}
}

// RemovedArchivedWorkspaceActivityTasks returns the removed IDs of the "archivedWorkspaceActivityTasks" edge to the ArchivedWorkspaceActivityTask entity.
func (m *TaskMutation) RemovedArchivedWorkspaceActivityTasksIDs() (ids []ulid.ID) {
	for id := range m.removedarchivedWorkspaceActivityTasks {
		ids = append(ids, id)
	}
	return
}

// ArchivedWorkspaceActivityTasksIDs returns the "archivedWorkspaceActivityTasks" edge IDs in the mutation.
func (m *TaskMutation) ArchivedWorkspaceActivityTasksIDs() (ids []ulid.ID) {
	for id := range m.archivedWorkspaceActivityTasks {
		ids = append(ids, id)
	}
	return
}

// ResetArchivedWorkspaceActivityTasks resets all changes to the "archivedWorkspaceActivityTasks" edge.
func (m *TaskMutation) ResetArchivedWorkspaceActivityTasks() {
	m.archivedWorkspaceActivityTasks = nil
	m.clearedarchivedWorkspaceActivityTasks = false
	m.removedarchivedWorkspaceActivityTasks = nil
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.parentTask != nil {
		fields = append(fields, task.FieldTaskParentID)
	}
	if m.taskPriority != nil {
		fields = append(fields, task.FieldTaskPriorityID)
	}
	if m.teammate != nil {
		fields = append(fields, task.FieldAssigneeID)
	}
	if m.created_by != nil {
		fields = append(fields, task.FieldCreatedBy)
	}
	if m.completed != nil {
		fields = append(fields, task.FieldCompleted)
	}
	if m.completed_at != nil {
		fields = append(fields, task.FieldCompletedAt)
	}
	if m.is_new != nil {
		fields = append(fields, task.FieldIsNew)
	}
	if m.name != nil {
		fields = append(fields, task.FieldName)
	}
	if m.due_date != nil {
		fields = append(fields, task.FieldDueDate)
	}
	if m.due_time != nil {
		fields = append(fields, task.FieldDueTime)
	}
	if m.description != nil {
		fields = append(fields, task.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, task.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldTaskParentID:
		return m.TaskParentID()
	case task.FieldTaskPriorityID:
		return m.TaskPriorityID()
	case task.FieldAssigneeID:
		return m.AssigneeID()
	case task.FieldCreatedBy:
		return m.CreatedBy()
	case task.FieldCompleted:
		return m.Completed()
	case task.FieldCompletedAt:
		return m.CompletedAt()
	case task.FieldIsNew:
		return m.IsNew()
	case task.FieldName:
		return m.Name()
	case task.FieldDueDate:
		return m.DueDate()
	case task.FieldDueTime:
		return m.DueTime()
	case task.FieldDescription:
		return m.Description()
	case task.FieldCreatedAt:
		return m.CreatedAt()
	case task.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldTaskParentID:
		return m.OldTaskParentID(ctx)
	case task.FieldTaskPriorityID:
		return m.OldTaskPriorityID(ctx)
	case task.FieldAssigneeID:
		return m.OldAssigneeID(ctx)
	case task.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case task.FieldCompleted:
		return m.OldCompleted(ctx)
	case task.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case task.FieldIsNew:
		return m.OldIsNew(ctx)
	case task.FieldName:
		return m.OldName(ctx)
	case task.FieldDueDate:
		return m.OldDueDate(ctx)
	case task.FieldDueTime:
		return m.OldDueTime(ctx)
	case task.FieldDescription:
		return m.OldDescription(ctx)
	case task.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case task.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldTaskParentID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskParentID(v)
		return nil
	case task.FieldTaskPriorityID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskPriorityID(v)
		return nil
	case task.FieldAssigneeID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssigneeID(v)
		return nil
	case task.FieldCreatedBy:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case task.FieldCompleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompleted(v)
		return nil
	case task.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case task.FieldIsNew:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsNew(v)
		return nil
	case task.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case task.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case task.FieldDueTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueTime(v)
		return nil
	case task.FieldDescription:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case task.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case task.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldTaskParentID) {
		fields = append(fields, task.FieldTaskParentID)
	}
	if m.FieldCleared(task.FieldTaskPriorityID) {
		fields = append(fields, task.FieldTaskPriorityID)
	}
	if m.FieldCleared(task.FieldAssigneeID) {
		fields = append(fields, task.FieldAssigneeID)
	}
	if m.FieldCleared(task.FieldCompletedAt) {
		fields = append(fields, task.FieldCompletedAt)
	}
	if m.FieldCleared(task.FieldDueDate) {
		fields = append(fields, task.FieldDueDate)
	}
	if m.FieldCleared(task.FieldDueTime) {
		fields = append(fields, task.FieldDueTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldTaskParentID:
		m.ClearTaskParentID()
		return nil
	case task.FieldTaskPriorityID:
		m.ClearTaskPriorityID()
		return nil
	case task.FieldAssigneeID:
		m.ClearAssigneeID()
		return nil
	case task.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case task.FieldDueDate:
		m.ClearDueDate()
		return nil
	case task.FieldDueTime:
		m.ClearDueTime()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldTaskParentID:
		m.ResetTaskParentID()
		return nil
	case task.FieldTaskPriorityID:
		m.ResetTaskPriorityID()
		return nil
	case task.FieldAssigneeID:
		m.ResetAssigneeID()
		return nil
	case task.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case task.FieldCompleted:
		m.ResetCompleted()
		return nil
	case task.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case task.FieldIsNew:
		m.ResetIsNew()
		return nil
	case task.FieldName:
		m.ResetName()
		return nil
	case task.FieldDueDate:
		m.ResetDueDate()
		return nil
	case task.FieldDueTime:
		m.ResetDueTime()
		return nil
	case task.FieldDescription:
		m.ResetDescription()
		return nil
	case task.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case task.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 17)
	if m.teammate != nil {
		edges = append(edges, task.EdgeTeammate)
	}
	if m.taskPriority != nil {
		edges = append(edges, task.EdgeTaskPriority)
	}
	if m.subTasks != nil {
		edges = append(edges, task.EdgeSubTasks)
	}
	if m.parentTask != nil {
		edges = append(edges, task.EdgeParentTask)
	}
	if m.teammateTasks != nil {
		edges = append(edges, task.EdgeTeammateTasks)
	}
	if m.projectTasks != nil {
		edges = append(edges, task.EdgeProjectTasks)
	}
	if m.taskLikes != nil {
		edges = append(edges, task.EdgeTaskLikes)
	}
	if m.taskTags != nil {
		edges = append(edges, task.EdgeTaskTags)
	}
	if m.taskCollaborators != nil {
		edges = append(edges, task.EdgeTaskCollaborators)
	}
	if m.taskFeeds != nil {
		edges = append(edges, task.EdgeTaskFeeds)
	}
	if m.taskFeedLikes != nil {
		edges = append(edges, task.EdgeTaskFeedLikes)
	}
	if m.taskFiles != nil {
		edges = append(edges, task.EdgeTaskFiles)
	}
	if m.deletedTasksRef != nil {
		edges = append(edges, task.EdgeDeletedTasksRef)
	}
	if m.taskActivityTasks != nil {
		edges = append(edges, task.EdgeTaskActivityTasks)
	}
	if m.workspaceActivityTasks != nil {
		edges = append(edges, task.EdgeWorkspaceActivityTasks)
	}
	if m.archivedTaskActivityTasks != nil {
		edges = append(edges, task.EdgeArchivedTaskActivityTasks)
	}
	if m.archivedWorkspaceActivityTasks != nil {
		edges = append(edges, task.EdgeArchivedWorkspaceActivityTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeTeammate:
		if id := m.teammate; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeTaskPriority:
		if id := m.taskPriority; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeSubTasks:
		ids := make([]ent.Value, 0, len(m.subTasks))
		for id := range m.subTasks {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeParentTask:
		if id := m.parentTask; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeTeammateTasks:
		ids := make([]ent.Value, 0, len(m.teammateTasks))
		for id := range m.teammateTasks {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeProjectTasks:
		ids := make([]ent.Value, 0, len(m.projectTasks))
		for id := range m.projectTasks {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskLikes:
		ids := make([]ent.Value, 0, len(m.taskLikes))
		for id := range m.taskLikes {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskTags:
		ids := make([]ent.Value, 0, len(m.taskTags))
		for id := range m.taskTags {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskCollaborators:
		ids := make([]ent.Value, 0, len(m.taskCollaborators))
		for id := range m.taskCollaborators {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskFeeds:
		ids := make([]ent.Value, 0, len(m.taskFeeds))
		for id := range m.taskFeeds {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskFeedLikes:
		ids := make([]ent.Value, 0, len(m.taskFeedLikes))
		for id := range m.taskFeedLikes {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskFiles:
		ids := make([]ent.Value, 0, len(m.taskFiles))
		for id := range m.taskFiles {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeDeletedTasksRef:
		ids := make([]ent.Value, 0, len(m.deletedTasksRef))
		for id := range m.deletedTasksRef {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskActivityTasks:
		ids := make([]ent.Value, 0, len(m.taskActivityTasks))
		for id := range m.taskActivityTasks {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeWorkspaceActivityTasks:
		ids := make([]ent.Value, 0, len(m.workspaceActivityTasks))
		for id := range m.workspaceActivityTasks {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeArchivedTaskActivityTasks:
		ids := make([]ent.Value, 0, len(m.archivedTaskActivityTasks))
		for id := range m.archivedTaskActivityTasks {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeArchivedWorkspaceActivityTasks:
		ids := make([]ent.Value, 0, len(m.archivedWorkspaceActivityTasks))
		for id := range m.archivedWorkspaceActivityTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 17)
	if m.removedsubTasks != nil {
		edges = append(edges, task.EdgeSubTasks)
	}
	if m.removedteammateTasks != nil {
		edges = append(edges, task.EdgeTeammateTasks)
	}
	if m.removedprojectTasks != nil {
		edges = append(edges, task.EdgeProjectTasks)
	}
	if m.removedtaskLikes != nil {
		edges = append(edges, task.EdgeTaskLikes)
	}
	if m.removedtaskTags != nil {
		edges = append(edges, task.EdgeTaskTags)
	}
	if m.removedtaskCollaborators != nil {
		edges = append(edges, task.EdgeTaskCollaborators)
	}
	if m.removedtaskFeeds != nil {
		edges = append(edges, task.EdgeTaskFeeds)
	}
	if m.removedtaskFeedLikes != nil {
		edges = append(edges, task.EdgeTaskFeedLikes)
	}
	if m.removedtaskFiles != nil {
		edges = append(edges, task.EdgeTaskFiles)
	}
	if m.removeddeletedTasksRef != nil {
		edges = append(edges, task.EdgeDeletedTasksRef)
	}
	if m.removedtaskActivityTasks != nil {
		edges = append(edges, task.EdgeTaskActivityTasks)
	}
	if m.removedworkspaceActivityTasks != nil {
		edges = append(edges, task.EdgeWorkspaceActivityTasks)
	}
	if m.removedarchivedTaskActivityTasks != nil {
		edges = append(edges, task.EdgeArchivedTaskActivityTasks)
	}
	if m.removedarchivedWorkspaceActivityTasks != nil {
		edges = append(edges, task.EdgeArchivedWorkspaceActivityTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeSubTasks:
		ids := make([]ent.Value, 0, len(m.removedsubTasks))
		for id := range m.removedsubTasks {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTeammateTasks:
		ids := make([]ent.Value, 0, len(m.removedteammateTasks))
		for id := range m.removedteammateTasks {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeProjectTasks:
		ids := make([]ent.Value, 0, len(m.removedprojectTasks))
		for id := range m.removedprojectTasks {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskLikes:
		ids := make([]ent.Value, 0, len(m.removedtaskLikes))
		for id := range m.removedtaskLikes {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskTags:
		ids := make([]ent.Value, 0, len(m.removedtaskTags))
		for id := range m.removedtaskTags {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskCollaborators:
		ids := make([]ent.Value, 0, len(m.removedtaskCollaborators))
		for id := range m.removedtaskCollaborators {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskFeeds:
		ids := make([]ent.Value, 0, len(m.removedtaskFeeds))
		for id := range m.removedtaskFeeds {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskFeedLikes:
		ids := make([]ent.Value, 0, len(m.removedtaskFeedLikes))
		for id := range m.removedtaskFeedLikes {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskFiles:
		ids := make([]ent.Value, 0, len(m.removedtaskFiles))
		for id := range m.removedtaskFiles {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeDeletedTasksRef:
		ids := make([]ent.Value, 0, len(m.removeddeletedTasksRef))
		for id := range m.removeddeletedTasksRef {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskActivityTasks:
		ids := make([]ent.Value, 0, len(m.removedtaskActivityTasks))
		for id := range m.removedtaskActivityTasks {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeWorkspaceActivityTasks:
		ids := make([]ent.Value, 0, len(m.removedworkspaceActivityTasks))
		for id := range m.removedworkspaceActivityTasks {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeArchivedTaskActivityTasks:
		ids := make([]ent.Value, 0, len(m.removedarchivedTaskActivityTasks))
		for id := range m.removedarchivedTaskActivityTasks {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeArchivedWorkspaceActivityTasks:
		ids := make([]ent.Value, 0, len(m.removedarchivedWorkspaceActivityTasks))
		for id := range m.removedarchivedWorkspaceActivityTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 17)
	if m.clearedteammate {
		edges = append(edges, task.EdgeTeammate)
	}
	if m.clearedtaskPriority {
		edges = append(edges, task.EdgeTaskPriority)
	}
	if m.clearedsubTasks {
		edges = append(edges, task.EdgeSubTasks)
	}
	if m.clearedparentTask {
		edges = append(edges, task.EdgeParentTask)
	}
	if m.clearedteammateTasks {
		edges = append(edges, task.EdgeTeammateTasks)
	}
	if m.clearedprojectTasks {
		edges = append(edges, task.EdgeProjectTasks)
	}
	if m.clearedtaskLikes {
		edges = append(edges, task.EdgeTaskLikes)
	}
	if m.clearedtaskTags {
		edges = append(edges, task.EdgeTaskTags)
	}
	if m.clearedtaskCollaborators {
		edges = append(edges, task.EdgeTaskCollaborators)
	}
	if m.clearedtaskFeeds {
		edges = append(edges, task.EdgeTaskFeeds)
	}
	if m.clearedtaskFeedLikes {
		edges = append(edges, task.EdgeTaskFeedLikes)
	}
	if m.clearedtaskFiles {
		edges = append(edges, task.EdgeTaskFiles)
	}
	if m.cleareddeletedTasksRef {
		edges = append(edges, task.EdgeDeletedTasksRef)
	}
	if m.clearedtaskActivityTasks {
		edges = append(edges, task.EdgeTaskActivityTasks)
	}
	if m.clearedworkspaceActivityTasks {
		edges = append(edges, task.EdgeWorkspaceActivityTasks)
	}
	if m.clearedarchivedTaskActivityTasks {
		edges = append(edges, task.EdgeArchivedTaskActivityTasks)
	}
	if m.clearedarchivedWorkspaceActivityTasks {
		edges = append(edges, task.EdgeArchivedWorkspaceActivityTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeTeammate:
		return m.clearedteammate
	case task.EdgeTaskPriority:
		return m.clearedtaskPriority
	case task.EdgeSubTasks:
		return m.clearedsubTasks
	case task.EdgeParentTask:
		return m.clearedparentTask
	case task.EdgeTeammateTasks:
		return m.clearedteammateTasks
	case task.EdgeProjectTasks:
		return m.clearedprojectTasks
	case task.EdgeTaskLikes:
		return m.clearedtaskLikes
	case task.EdgeTaskTags:
		return m.clearedtaskTags
	case task.EdgeTaskCollaborators:
		return m.clearedtaskCollaborators
	case task.EdgeTaskFeeds:
		return m.clearedtaskFeeds
	case task.EdgeTaskFeedLikes:
		return m.clearedtaskFeedLikes
	case task.EdgeTaskFiles:
		return m.clearedtaskFiles
	case task.EdgeDeletedTasksRef:
		return m.cleareddeletedTasksRef
	case task.EdgeTaskActivityTasks:
		return m.clearedtaskActivityTasks
	case task.EdgeWorkspaceActivityTasks:
		return m.clearedworkspaceActivityTasks
	case task.EdgeArchivedTaskActivityTasks:
		return m.clearedarchivedTaskActivityTasks
	case task.EdgeArchivedWorkspaceActivityTasks:
		return m.clearedarchivedWorkspaceActivityTasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	case task.EdgeTeammate:
		m.ClearTeammate()
		return nil
	case task.EdgeTaskPriority:
		m.ClearTaskPriority()
		return nil
	case task.EdgeParentTask:
		m.ClearParentTask()
		return nil
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeTeammate:
		m.ResetTeammate()
		return nil
	case task.EdgeTaskPriority:
		m.ResetTaskPriority()
		return nil
	case task.EdgeSubTasks:
		m.ResetSubTasks()
		return nil
	case task.EdgeParentTask:
		m.ResetParentTask()
		return nil
	case task.EdgeTeammateTasks:
		m.ResetTeammateTasks()
		return nil
	case task.EdgeProjectTasks:
		m.ResetProjectTasks()
		return nil
	case task.EdgeTaskLikes:
		m.ResetTaskLikes()
		return nil
	case task.EdgeTaskTags:
		m.ResetTaskTags()
		return nil
	case task.EdgeTaskCollaborators:
		m.ResetTaskCollaborators()
		return nil
	case task.EdgeTaskFeeds:
		m.ResetTaskFeeds()
		return nil
	case task.EdgeTaskFeedLikes:
		m.ResetTaskFeedLikes()
		return nil
	case task.EdgeTaskFiles:
		m.ResetTaskFiles()
		return nil
	case task.EdgeDeletedTasksRef:
		m.ResetDeletedTasksRef()
		return nil
	case task.EdgeTaskActivityTasks:
		m.ResetTaskActivityTasks()
		return nil
	case task.EdgeWorkspaceActivityTasks:
		m.ResetWorkspaceActivityTasks()
		return nil
	case task.EdgeArchivedTaskActivityTasks:
		m.ResetArchivedTaskActivityTasks()
		return nil
	case task.EdgeArchivedWorkspaceActivityTasks:
		m.ResetArchivedWorkspaceActivityTasks()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}

// TaskActivityMutation represents an operation that mutates the TaskActivity nodes in the graph.
type TaskActivityMutation struct {
	config
	op                       Op
	typ                      string
	id                       *ulid.ID
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	teammate                 *ulid.ID
	clearedteammate          bool
	activityType             *ulid.ID
	clearedactivityType      bool
	workspace                *ulid.ID
	clearedworkspace         bool
	taskActivityTasks        map[ulid.ID]struct{}
	removedtaskActivityTasks map[ulid.ID]struct{}
	clearedtaskActivityTasks bool
	done                     bool
	oldValue                 func(context.Context) (*TaskActivity, error)
	predicates               []predicate.TaskActivity
}

var _ ent.Mutation = (*TaskActivityMutation)(nil)

// taskactivityOption allows management of the mutation configuration using functional options.
type taskactivityOption func(*TaskActivityMutation)

// newTaskActivityMutation creates new mutation for the TaskActivity entity.
func newTaskActivityMutation(c config, op Op, opts ...taskactivityOption) *TaskActivityMutation {
	m := &TaskActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskActivityID sets the ID field of the mutation.
func withTaskActivityID(id ulid.ID) taskactivityOption {
	return func(m *TaskActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskActivity
		)
		m.oldValue = func(ctx context.Context) (*TaskActivity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskActivity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskActivity sets the old TaskActivity of the mutation.
func withTaskActivity(node *TaskActivity) taskactivityOption {
	return func(m *TaskActivityMutation) {
		m.oldValue = func(context.Context) (*TaskActivity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskActivity entities.
func (m *TaskActivityMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskActivityMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskActivityMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskActivity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetActivityTypeID sets the "activity_type_id" field.
func (m *TaskActivityMutation) SetActivityTypeID(u ulid.ID) {
	m.activityType = &u
}

// ActivityTypeID returns the value of the "activity_type_id" field in the mutation.
func (m *TaskActivityMutation) ActivityTypeID() (r ulid.ID, exists bool) {
	v := m.activityType
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityTypeID returns the old "activity_type_id" field's value of the TaskActivity entity.
// If the TaskActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskActivityMutation) OldActivityTypeID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivityTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivityTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityTypeID: %w", err)
	}
	return oldValue.ActivityTypeID, nil
}

// ResetActivityTypeID resets all changes to the "activity_type_id" field.
func (m *TaskActivityMutation) ResetActivityTypeID() {
	m.activityType = nil
}

// SetTeammateID sets the "teammate_id" field.
func (m *TaskActivityMutation) SetTeammateID(u ulid.ID) {
	m.teammate = &u
}

// TeammateID returns the value of the "teammate_id" field in the mutation.
func (m *TaskActivityMutation) TeammateID() (r ulid.ID, exists bool) {
	v := m.teammate
	if v == nil {
		return
	}
	return *v, true
}

// OldTeammateID returns the old "teammate_id" field's value of the TaskActivity entity.
// If the TaskActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskActivityMutation) OldTeammateID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeammateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeammateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeammateID: %w", err)
	}
	return oldValue.TeammateID, nil
}

// ResetTeammateID resets all changes to the "teammate_id" field.
func (m *TaskActivityMutation) ResetTeammateID() {
	m.teammate = nil
}

// SetWorkspaceID sets the "workspace_id" field.
func (m *TaskActivityMutation) SetWorkspaceID(u ulid.ID) {
	m.workspace = &u
}

// WorkspaceID returns the value of the "workspace_id" field in the mutation.
func (m *TaskActivityMutation) WorkspaceID() (r ulid.ID, exists bool) {
	v := m.workspace
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspaceID returns the old "workspace_id" field's value of the TaskActivity entity.
// If the TaskActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskActivityMutation) OldWorkspaceID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspaceID: %w", err)
	}
	return oldValue.WorkspaceID, nil
}

// ResetWorkspaceID resets all changes to the "workspace_id" field.
func (m *TaskActivityMutation) ResetWorkspaceID() {
	m.workspace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskActivityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskActivityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskActivity entity.
// If the TaskActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskActivityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskActivityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskActivityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskActivityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskActivity entity.
// If the TaskActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskActivityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskActivityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTeammate clears the "teammate" edge to the Teammate entity.
func (m *TaskActivityMutation) ClearTeammate() {
	m.clearedteammate = true
}

// TeammateCleared reports if the "teammate" edge to the Teammate entity was cleared.
func (m *TaskActivityMutation) TeammateCleared() bool {
	return m.clearedteammate
}

// TeammateIDs returns the "teammate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeammateID instead. It exists only for internal usage by the builders.
func (m *TaskActivityMutation) TeammateIDs() (ids []ulid.ID) {
	if id := m.teammate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeammate resets all changes to the "teammate" edge.
func (m *TaskActivityMutation) ResetTeammate() {
	m.teammate = nil
	m.clearedteammate = false
}

// ClearActivityType clears the "activityType" edge to the ActivityType entity.
func (m *TaskActivityMutation) ClearActivityType() {
	m.clearedactivityType = true
}

// ActivityTypeCleared reports if the "activityType" edge to the ActivityType entity was cleared.
func (m *TaskActivityMutation) ActivityTypeCleared() bool {
	return m.clearedactivityType
}

// ActivityTypeIDs returns the "activityType" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActivityTypeID instead. It exists only for internal usage by the builders.
func (m *TaskActivityMutation) ActivityTypeIDs() (ids []ulid.ID) {
	if id := m.activityType; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivityType resets all changes to the "activityType" edge.
func (m *TaskActivityMutation) ResetActivityType() {
	m.activityType = nil
	m.clearedactivityType = false
}

// ClearWorkspace clears the "workspace" edge to the Workspace entity.
func (m *TaskActivityMutation) ClearWorkspace() {
	m.clearedworkspace = true
}

// WorkspaceCleared reports if the "workspace" edge to the Workspace entity was cleared.
func (m *TaskActivityMutation) WorkspaceCleared() bool {
	return m.clearedworkspace
}

// WorkspaceIDs returns the "workspace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkspaceID instead. It exists only for internal usage by the builders.
func (m *TaskActivityMutation) WorkspaceIDs() (ids []ulid.ID) {
	if id := m.workspace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkspace resets all changes to the "workspace" edge.
func (m *TaskActivityMutation) ResetWorkspace() {
	m.workspace = nil
	m.clearedworkspace = false
}

// AddTaskActivityTaskIDs adds the "taskActivityTasks" edge to the TaskActivityTask entity by ids.
func (m *TaskActivityMutation) AddTaskActivityTaskIDs(ids ...ulid.ID) {
	if m.taskActivityTasks == nil {
		m.taskActivityTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.taskActivityTasks[ids[i]] = struct{}{}
	}
}

// ClearTaskActivityTasks clears the "taskActivityTasks" edge to the TaskActivityTask entity.
func (m *TaskActivityMutation) ClearTaskActivityTasks() {
	m.clearedtaskActivityTasks = true
}

// TaskActivityTasksCleared reports if the "taskActivityTasks" edge to the TaskActivityTask entity was cleared.
func (m *TaskActivityMutation) TaskActivityTasksCleared() bool {
	return m.clearedtaskActivityTasks
}

// RemoveTaskActivityTaskIDs removes the "taskActivityTasks" edge to the TaskActivityTask entity by IDs.
func (m *TaskActivityMutation) RemoveTaskActivityTaskIDs(ids ...ulid.ID) {
	if m.removedtaskActivityTasks == nil {
		m.removedtaskActivityTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.taskActivityTasks, ids[i])
		m.removedtaskActivityTasks[ids[i]] = struct{}{}
	}
}

// RemovedTaskActivityTasks returns the removed IDs of the "taskActivityTasks" edge to the TaskActivityTask entity.
func (m *TaskActivityMutation) RemovedTaskActivityTasksIDs() (ids []ulid.ID) {
	for id := range m.removedtaskActivityTasks {
		ids = append(ids, id)
	}
	return
}

// TaskActivityTasksIDs returns the "taskActivityTasks" edge IDs in the mutation.
func (m *TaskActivityMutation) TaskActivityTasksIDs() (ids []ulid.ID) {
	for id := range m.taskActivityTasks {
		ids = append(ids, id)
	}
	return
}

// ResetTaskActivityTasks resets all changes to the "taskActivityTasks" edge.
func (m *TaskActivityMutation) ResetTaskActivityTasks() {
	m.taskActivityTasks = nil
	m.clearedtaskActivityTasks = false
	m.removedtaskActivityTasks = nil
}

// Where appends a list predicates to the TaskActivityMutation builder.
func (m *TaskActivityMutation) Where(ps ...predicate.TaskActivity) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskActivityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TaskActivity).
func (m *TaskActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskActivityMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.activityType != nil {
		fields = append(fields, taskactivity.FieldActivityTypeID)
	}
	if m.teammate != nil {
		fields = append(fields, taskactivity.FieldTeammateID)
	}
	if m.workspace != nil {
		fields = append(fields, taskactivity.FieldWorkspaceID)
	}
	if m.created_at != nil {
		fields = append(fields, taskactivity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, taskactivity.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case taskactivity.FieldActivityTypeID:
		return m.ActivityTypeID()
	case taskactivity.FieldTeammateID:
		return m.TeammateID()
	case taskactivity.FieldWorkspaceID:
		return m.WorkspaceID()
	case taskactivity.FieldCreatedAt:
		return m.CreatedAt()
	case taskactivity.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case taskactivity.FieldActivityTypeID:
		return m.OldActivityTypeID(ctx)
	case taskactivity.FieldTeammateID:
		return m.OldTeammateID(ctx)
	case taskactivity.FieldWorkspaceID:
		return m.OldWorkspaceID(ctx)
	case taskactivity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case taskactivity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TaskActivity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case taskactivity.FieldActivityTypeID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityTypeID(v)
		return nil
	case taskactivity.FieldTeammateID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeammateID(v)
		return nil
	case taskactivity.FieldWorkspaceID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspaceID(v)
		return nil
	case taskactivity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case taskactivity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TaskActivity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskActivityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskActivityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskActivity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskActivityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskActivityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TaskActivity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskActivityMutation) ResetField(name string) error {
	switch name {
	case taskactivity.FieldActivityTypeID:
		m.ResetActivityTypeID()
		return nil
	case taskactivity.FieldTeammateID:
		m.ResetTeammateID()
		return nil
	case taskactivity.FieldWorkspaceID:
		m.ResetWorkspaceID()
		return nil
	case taskactivity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case taskactivity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TaskActivity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.teammate != nil {
		edges = append(edges, taskactivity.EdgeTeammate)
	}
	if m.activityType != nil {
		edges = append(edges, taskactivity.EdgeActivityType)
	}
	if m.workspace != nil {
		edges = append(edges, taskactivity.EdgeWorkspace)
	}
	if m.taskActivityTasks != nil {
		edges = append(edges, taskactivity.EdgeTaskActivityTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case taskactivity.EdgeTeammate:
		if id := m.teammate; id != nil {
			return []ent.Value{*id}
		}
	case taskactivity.EdgeActivityType:
		if id := m.activityType; id != nil {
			return []ent.Value{*id}
		}
	case taskactivity.EdgeWorkspace:
		if id := m.workspace; id != nil {
			return []ent.Value{*id}
		}
	case taskactivity.EdgeTaskActivityTasks:
		ids := make([]ent.Value, 0, len(m.taskActivityTasks))
		for id := range m.taskActivityTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtaskActivityTasks != nil {
		edges = append(edges, taskactivity.EdgeTaskActivityTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskActivityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case taskactivity.EdgeTaskActivityTasks:
		ids := make([]ent.Value, 0, len(m.removedtaskActivityTasks))
		for id := range m.removedtaskActivityTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedteammate {
		edges = append(edges, taskactivity.EdgeTeammate)
	}
	if m.clearedactivityType {
		edges = append(edges, taskactivity.EdgeActivityType)
	}
	if m.clearedworkspace {
		edges = append(edges, taskactivity.EdgeWorkspace)
	}
	if m.clearedtaskActivityTasks {
		edges = append(edges, taskactivity.EdgeTaskActivityTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case taskactivity.EdgeTeammate:
		return m.clearedteammate
	case taskactivity.EdgeActivityType:
		return m.clearedactivityType
	case taskactivity.EdgeWorkspace:
		return m.clearedworkspace
	case taskactivity.EdgeTaskActivityTasks:
		return m.clearedtaskActivityTasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskActivityMutation) ClearEdge(name string) error {
	switch name {
	case taskactivity.EdgeTeammate:
		m.ClearTeammate()
		return nil
	case taskactivity.EdgeActivityType:
		m.ClearActivityType()
		return nil
	case taskactivity.EdgeWorkspace:
		m.ClearWorkspace()
		return nil
	}
	return fmt.Errorf("unknown TaskActivity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskActivityMutation) ResetEdge(name string) error {
	switch name {
	case taskactivity.EdgeTeammate:
		m.ResetTeammate()
		return nil
	case taskactivity.EdgeActivityType:
		m.ResetActivityType()
		return nil
	case taskactivity.EdgeWorkspace:
		m.ResetWorkspace()
		return nil
	case taskactivity.EdgeTaskActivityTasks:
		m.ResetTaskActivityTasks()
		return nil
	}
	return fmt.Errorf("unknown TaskActivity edge %s", name)
}

// TaskActivityTaskMutation represents an operation that mutates the TaskActivityTask nodes in the graph.
type TaskActivityTaskMutation struct {
	config
	op                  Op
	typ                 string
	id                  *ulid.ID
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	task                *ulid.ID
	clearedtask         bool
	taskActivity        *ulid.ID
	clearedtaskActivity bool
	done                bool
	oldValue            func(context.Context) (*TaskActivityTask, error)
	predicates          []predicate.TaskActivityTask
}

var _ ent.Mutation = (*TaskActivityTaskMutation)(nil)

// taskactivitytaskOption allows management of the mutation configuration using functional options.
type taskactivitytaskOption func(*TaskActivityTaskMutation)

// newTaskActivityTaskMutation creates new mutation for the TaskActivityTask entity.
func newTaskActivityTaskMutation(c config, op Op, opts ...taskactivitytaskOption) *TaskActivityTaskMutation {
	m := &TaskActivityTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskActivityTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskActivityTaskID sets the ID field of the mutation.
func withTaskActivityTaskID(id ulid.ID) taskactivitytaskOption {
	return func(m *TaskActivityTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskActivityTask
		)
		m.oldValue = func(ctx context.Context) (*TaskActivityTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskActivityTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskActivityTask sets the old TaskActivityTask of the mutation.
func withTaskActivityTask(node *TaskActivityTask) taskactivitytaskOption {
	return func(m *TaskActivityTaskMutation) {
		m.oldValue = func(context.Context) (*TaskActivityTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskActivityTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskActivityTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskActivityTask entities.
func (m *TaskActivityTaskMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskActivityTaskMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskActivityTaskMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskActivityTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTaskActivityID sets the "task_activity_id" field.
func (m *TaskActivityTaskMutation) SetTaskActivityID(u ulid.ID) {
	m.taskActivity = &u
}

// TaskActivityID returns the value of the "task_activity_id" field in the mutation.
func (m *TaskActivityTaskMutation) TaskActivityID() (r ulid.ID, exists bool) {
	v := m.taskActivity
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskActivityID returns the old "task_activity_id" field's value of the TaskActivityTask entity.
// If the TaskActivityTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskActivityTaskMutation) OldTaskActivityID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskActivityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskActivityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskActivityID: %w", err)
	}
	return oldValue.TaskActivityID, nil
}

// ResetTaskActivityID resets all changes to the "task_activity_id" field.
func (m *TaskActivityTaskMutation) ResetTaskActivityID() {
	m.taskActivity = nil
}

// SetTaskID sets the "task_id" field.
func (m *TaskActivityTaskMutation) SetTaskID(u ulid.ID) {
	m.task = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *TaskActivityTaskMutation) TaskID() (r ulid.ID, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the TaskActivityTask entity.
// If the TaskActivityTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskActivityTaskMutation) OldTaskID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *TaskActivityTaskMutation) ResetTaskID() {
	m.task = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskActivityTaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskActivityTaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskActivityTask entity.
// If the TaskActivityTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskActivityTaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskActivityTaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskActivityTaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskActivityTaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskActivityTask entity.
// If the TaskActivityTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskActivityTaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskActivityTaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTask clears the "task" edge to the Task entity.
func (m *TaskActivityTaskMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *TaskActivityTaskMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *TaskActivityTaskMutation) TaskIDs() (ids []ulid.ID) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *TaskActivityTaskMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// ClearTaskActivity clears the "taskActivity" edge to the TaskActivity entity.
func (m *TaskActivityTaskMutation) ClearTaskActivity() {
	m.clearedtaskActivity = true
}

// TaskActivityCleared reports if the "taskActivity" edge to the TaskActivity entity was cleared.
func (m *TaskActivityTaskMutation) TaskActivityCleared() bool {
	return m.clearedtaskActivity
}

// TaskActivityIDs returns the "taskActivity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskActivityID instead. It exists only for internal usage by the builders.
func (m *TaskActivityTaskMutation) TaskActivityIDs() (ids []ulid.ID) {
	if id := m.taskActivity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTaskActivity resets all changes to the "taskActivity" edge.
func (m *TaskActivityTaskMutation) ResetTaskActivity() {
	m.taskActivity = nil
	m.clearedtaskActivity = false
}

// Where appends a list predicates to the TaskActivityTaskMutation builder.
func (m *TaskActivityTaskMutation) Where(ps ...predicate.TaskActivityTask) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskActivityTaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TaskActivityTask).
func (m *TaskActivityTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskActivityTaskMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.taskActivity != nil {
		fields = append(fields, taskactivitytask.FieldTaskActivityID)
	}
	if m.task != nil {
		fields = append(fields, taskactivitytask.FieldTaskID)
	}
	if m.created_at != nil {
		fields = append(fields, taskactivitytask.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, taskactivitytask.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskActivityTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case taskactivitytask.FieldTaskActivityID:
		return m.TaskActivityID()
	case taskactivitytask.FieldTaskID:
		return m.TaskID()
	case taskactivitytask.FieldCreatedAt:
		return m.CreatedAt()
	case taskactivitytask.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskActivityTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case taskactivitytask.FieldTaskActivityID:
		return m.OldTaskActivityID(ctx)
	case taskactivitytask.FieldTaskID:
		return m.OldTaskID(ctx)
	case taskactivitytask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case taskactivitytask.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TaskActivityTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskActivityTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case taskactivitytask.FieldTaskActivityID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskActivityID(v)
		return nil
	case taskactivitytask.FieldTaskID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case taskactivitytask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case taskactivitytask.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TaskActivityTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskActivityTaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskActivityTaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskActivityTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskActivityTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskActivityTaskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskActivityTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskActivityTaskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TaskActivityTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskActivityTaskMutation) ResetField(name string) error {
	switch name {
	case taskactivitytask.FieldTaskActivityID:
		m.ResetTaskActivityID()
		return nil
	case taskactivitytask.FieldTaskID:
		m.ResetTaskID()
		return nil
	case taskactivitytask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case taskactivitytask.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TaskActivityTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskActivityTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.task != nil {
		edges = append(edges, taskactivitytask.EdgeTask)
	}
	if m.taskActivity != nil {
		edges = append(edges, taskactivitytask.EdgeTaskActivity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskActivityTaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case taskactivitytask.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case taskactivitytask.EdgeTaskActivity:
		if id := m.taskActivity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskActivityTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskActivityTaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskActivityTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtask {
		edges = append(edges, taskactivitytask.EdgeTask)
	}
	if m.clearedtaskActivity {
		edges = append(edges, taskactivitytask.EdgeTaskActivity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskActivityTaskMutation) EdgeCleared(name string) bool {
	switch name {
	case taskactivitytask.EdgeTask:
		return m.clearedtask
	case taskactivitytask.EdgeTaskActivity:
		return m.clearedtaskActivity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskActivityTaskMutation) ClearEdge(name string) error {
	switch name {
	case taskactivitytask.EdgeTask:
		m.ClearTask()
		return nil
	case taskactivitytask.EdgeTaskActivity:
		m.ClearTaskActivity()
		return nil
	}
	return fmt.Errorf("unknown TaskActivityTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskActivityTaskMutation) ResetEdge(name string) error {
	switch name {
	case taskactivitytask.EdgeTask:
		m.ResetTask()
		return nil
	case taskactivitytask.EdgeTaskActivity:
		m.ResetTaskActivity()
		return nil
	}
	return fmt.Errorf("unknown TaskActivityTask edge %s", name)
}

// TaskCollaboratorMutation represents an operation that mutates the TaskCollaborator nodes in the graph.
type TaskCollaboratorMutation struct {
	config
	op              Op
	typ             string
	id              *ulid.ID
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	task            *ulid.ID
	clearedtask     bool
	teammate        *ulid.ID
	clearedteammate bool
	done            bool
	oldValue        func(context.Context) (*TaskCollaborator, error)
	predicates      []predicate.TaskCollaborator
}

var _ ent.Mutation = (*TaskCollaboratorMutation)(nil)

// taskcollaboratorOption allows management of the mutation configuration using functional options.
type taskcollaboratorOption func(*TaskCollaboratorMutation)

// newTaskCollaboratorMutation creates new mutation for the TaskCollaborator entity.
func newTaskCollaboratorMutation(c config, op Op, opts ...taskcollaboratorOption) *TaskCollaboratorMutation {
	m := &TaskCollaboratorMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskCollaborator,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskCollaboratorID sets the ID field of the mutation.
func withTaskCollaboratorID(id ulid.ID) taskcollaboratorOption {
	return func(m *TaskCollaboratorMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskCollaborator
		)
		m.oldValue = func(ctx context.Context) (*TaskCollaborator, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskCollaborator.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskCollaborator sets the old TaskCollaborator of the mutation.
func withTaskCollaborator(node *TaskCollaborator) taskcollaboratorOption {
	return func(m *TaskCollaboratorMutation) {
		m.oldValue = func(context.Context) (*TaskCollaborator, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskCollaboratorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskCollaboratorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskCollaborator entities.
func (m *TaskCollaboratorMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskCollaboratorMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskCollaboratorMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskCollaborator.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTaskID sets the "task_id" field.
func (m *TaskCollaboratorMutation) SetTaskID(u ulid.ID) {
	m.task = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *TaskCollaboratorMutation) TaskID() (r ulid.ID, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the TaskCollaborator entity.
// If the TaskCollaborator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskCollaboratorMutation) OldTaskID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *TaskCollaboratorMutation) ResetTaskID() {
	m.task = nil
}

// SetTeammateID sets the "teammate_id" field.
func (m *TaskCollaboratorMutation) SetTeammateID(u ulid.ID) {
	m.teammate = &u
}

// TeammateID returns the value of the "teammate_id" field in the mutation.
func (m *TaskCollaboratorMutation) TeammateID() (r ulid.ID, exists bool) {
	v := m.teammate
	if v == nil {
		return
	}
	return *v, true
}

// OldTeammateID returns the old "teammate_id" field's value of the TaskCollaborator entity.
// If the TaskCollaborator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskCollaboratorMutation) OldTeammateID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeammateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeammateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeammateID: %w", err)
	}
	return oldValue.TeammateID, nil
}

// ResetTeammateID resets all changes to the "teammate_id" field.
func (m *TaskCollaboratorMutation) ResetTeammateID() {
	m.teammate = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskCollaboratorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskCollaboratorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskCollaborator entity.
// If the TaskCollaborator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskCollaboratorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskCollaboratorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskCollaboratorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskCollaboratorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskCollaborator entity.
// If the TaskCollaborator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskCollaboratorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskCollaboratorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTask clears the "task" edge to the Task entity.
func (m *TaskCollaboratorMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *TaskCollaboratorMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *TaskCollaboratorMutation) TaskIDs() (ids []ulid.ID) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *TaskCollaboratorMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// ClearTeammate clears the "teammate" edge to the Teammate entity.
func (m *TaskCollaboratorMutation) ClearTeammate() {
	m.clearedteammate = true
}

// TeammateCleared reports if the "teammate" edge to the Teammate entity was cleared.
func (m *TaskCollaboratorMutation) TeammateCleared() bool {
	return m.clearedteammate
}

// TeammateIDs returns the "teammate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeammateID instead. It exists only for internal usage by the builders.
func (m *TaskCollaboratorMutation) TeammateIDs() (ids []ulid.ID) {
	if id := m.teammate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeammate resets all changes to the "teammate" edge.
func (m *TaskCollaboratorMutation) ResetTeammate() {
	m.teammate = nil
	m.clearedteammate = false
}

// Where appends a list predicates to the TaskCollaboratorMutation builder.
func (m *TaskCollaboratorMutation) Where(ps ...predicate.TaskCollaborator) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskCollaboratorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TaskCollaborator).
func (m *TaskCollaboratorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskCollaboratorMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.task != nil {
		fields = append(fields, taskcollaborator.FieldTaskID)
	}
	if m.teammate != nil {
		fields = append(fields, taskcollaborator.FieldTeammateID)
	}
	if m.created_at != nil {
		fields = append(fields, taskcollaborator.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, taskcollaborator.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskCollaboratorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case taskcollaborator.FieldTaskID:
		return m.TaskID()
	case taskcollaborator.FieldTeammateID:
		return m.TeammateID()
	case taskcollaborator.FieldCreatedAt:
		return m.CreatedAt()
	case taskcollaborator.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskCollaboratorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case taskcollaborator.FieldTaskID:
		return m.OldTaskID(ctx)
	case taskcollaborator.FieldTeammateID:
		return m.OldTeammateID(ctx)
	case taskcollaborator.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case taskcollaborator.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TaskCollaborator field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskCollaboratorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case taskcollaborator.FieldTaskID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case taskcollaborator.FieldTeammateID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeammateID(v)
		return nil
	case taskcollaborator.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case taskcollaborator.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TaskCollaborator field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskCollaboratorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskCollaboratorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskCollaboratorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskCollaborator numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskCollaboratorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskCollaboratorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskCollaboratorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TaskCollaborator nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskCollaboratorMutation) ResetField(name string) error {
	switch name {
	case taskcollaborator.FieldTaskID:
		m.ResetTaskID()
		return nil
	case taskcollaborator.FieldTeammateID:
		m.ResetTeammateID()
		return nil
	case taskcollaborator.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case taskcollaborator.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TaskCollaborator field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskCollaboratorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.task != nil {
		edges = append(edges, taskcollaborator.EdgeTask)
	}
	if m.teammate != nil {
		edges = append(edges, taskcollaborator.EdgeTeammate)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskCollaboratorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case taskcollaborator.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case taskcollaborator.EdgeTeammate:
		if id := m.teammate; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskCollaboratorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskCollaboratorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskCollaboratorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtask {
		edges = append(edges, taskcollaborator.EdgeTask)
	}
	if m.clearedteammate {
		edges = append(edges, taskcollaborator.EdgeTeammate)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskCollaboratorMutation) EdgeCleared(name string) bool {
	switch name {
	case taskcollaborator.EdgeTask:
		return m.clearedtask
	case taskcollaborator.EdgeTeammate:
		return m.clearedteammate
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskCollaboratorMutation) ClearEdge(name string) error {
	switch name {
	case taskcollaborator.EdgeTask:
		m.ClearTask()
		return nil
	case taskcollaborator.EdgeTeammate:
		m.ClearTeammate()
		return nil
	}
	return fmt.Errorf("unknown TaskCollaborator unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskCollaboratorMutation) ResetEdge(name string) error {
	switch name {
	case taskcollaborator.EdgeTask:
		m.ResetTask()
		return nil
	case taskcollaborator.EdgeTeammate:
		m.ResetTeammate()
		return nil
	}
	return fmt.Errorf("unknown TaskCollaborator edge %s", name)
}

// TaskColumnMutation represents an operation that mutates the TaskColumn nodes in the graph.
type TaskColumnMutation struct {
	config
	op                         Op
	typ                        string
	id                         *ulid.ID
	name                       *string
	_type                      *taskcolumn.Type
	created_at                 *time.Time
	updated_at                 *time.Time
	clearedFields              map[string]struct{}
	teammateTaskColumns        map[ulid.ID]struct{}
	removedteammateTaskColumns map[ulid.ID]struct{}
	clearedteammateTaskColumns bool
	projectTaskColumns         map[ulid.ID]struct{}
	removedprojectTaskColumns  map[ulid.ID]struct{}
	clearedprojectTaskColumns  bool
	done                       bool
	oldValue                   func(context.Context) (*TaskColumn, error)
	predicates                 []predicate.TaskColumn
}

var _ ent.Mutation = (*TaskColumnMutation)(nil)

// taskcolumnOption allows management of the mutation configuration using functional options.
type taskcolumnOption func(*TaskColumnMutation)

// newTaskColumnMutation creates new mutation for the TaskColumn entity.
func newTaskColumnMutation(c config, op Op, opts ...taskcolumnOption) *TaskColumnMutation {
	m := &TaskColumnMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskColumn,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskColumnID sets the ID field of the mutation.
func withTaskColumnID(id ulid.ID) taskcolumnOption {
	return func(m *TaskColumnMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskColumn
		)
		m.oldValue = func(ctx context.Context) (*TaskColumn, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskColumn.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskColumn sets the old TaskColumn of the mutation.
func withTaskColumn(node *TaskColumn) taskcolumnOption {
	return func(m *TaskColumnMutation) {
		m.oldValue = func(context.Context) (*TaskColumn, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskColumnMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskColumnMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskColumn entities.
func (m *TaskColumnMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskColumnMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskColumnMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskColumn.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TaskColumnMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TaskColumnMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TaskColumn entity.
// If the TaskColumn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskColumnMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TaskColumnMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *TaskColumnMutation) SetType(t taskcolumn.Type) {
	m._type = &t
}

// GetType returns the value of the "type" field in the mutation.
func (m *TaskColumnMutation) GetType() (r taskcolumn.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the TaskColumn entity.
// If the TaskColumn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskColumnMutation) OldType(ctx context.Context) (v taskcolumn.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TaskColumnMutation) ResetType() {
	m._type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskColumnMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskColumnMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskColumn entity.
// If the TaskColumn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskColumnMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskColumnMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskColumnMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskColumnMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskColumn entity.
// If the TaskColumn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskColumnMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskColumnMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddTeammateTaskColumnIDs adds the "teammateTaskColumns" edge to the TeammateTaskColumn entity by ids.
func (m *TaskColumnMutation) AddTeammateTaskColumnIDs(ids ...ulid.ID) {
	if m.teammateTaskColumns == nil {
		m.teammateTaskColumns = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.teammateTaskColumns[ids[i]] = struct{}{}
	}
}

// ClearTeammateTaskColumns clears the "teammateTaskColumns" edge to the TeammateTaskColumn entity.
func (m *TaskColumnMutation) ClearTeammateTaskColumns() {
	m.clearedteammateTaskColumns = true
}

// TeammateTaskColumnsCleared reports if the "teammateTaskColumns" edge to the TeammateTaskColumn entity was cleared.
func (m *TaskColumnMutation) TeammateTaskColumnsCleared() bool {
	return m.clearedteammateTaskColumns
}

// RemoveTeammateTaskColumnIDs removes the "teammateTaskColumns" edge to the TeammateTaskColumn entity by IDs.
func (m *TaskColumnMutation) RemoveTeammateTaskColumnIDs(ids ...ulid.ID) {
	if m.removedteammateTaskColumns == nil {
		m.removedteammateTaskColumns = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.teammateTaskColumns, ids[i])
		m.removedteammateTaskColumns[ids[i]] = struct{}{}
	}
}

// RemovedTeammateTaskColumns returns the removed IDs of the "teammateTaskColumns" edge to the TeammateTaskColumn entity.
func (m *TaskColumnMutation) RemovedTeammateTaskColumnsIDs() (ids []ulid.ID) {
	for id := range m.removedteammateTaskColumns {
		ids = append(ids, id)
	}
	return
}

// TeammateTaskColumnsIDs returns the "teammateTaskColumns" edge IDs in the mutation.
func (m *TaskColumnMutation) TeammateTaskColumnsIDs() (ids []ulid.ID) {
	for id := range m.teammateTaskColumns {
		ids = append(ids, id)
	}
	return
}

// ResetTeammateTaskColumns resets all changes to the "teammateTaskColumns" edge.
func (m *TaskColumnMutation) ResetTeammateTaskColumns() {
	m.teammateTaskColumns = nil
	m.clearedteammateTaskColumns = false
	m.removedteammateTaskColumns = nil
}

// AddProjectTaskColumnIDs adds the "projectTaskColumns" edge to the ProjectTaskColumn entity by ids.
func (m *TaskColumnMutation) AddProjectTaskColumnIDs(ids ...ulid.ID) {
	if m.projectTaskColumns == nil {
		m.projectTaskColumns = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.projectTaskColumns[ids[i]] = struct{}{}
	}
}

// ClearProjectTaskColumns clears the "projectTaskColumns" edge to the ProjectTaskColumn entity.
func (m *TaskColumnMutation) ClearProjectTaskColumns() {
	m.clearedprojectTaskColumns = true
}

// ProjectTaskColumnsCleared reports if the "projectTaskColumns" edge to the ProjectTaskColumn entity was cleared.
func (m *TaskColumnMutation) ProjectTaskColumnsCleared() bool {
	return m.clearedprojectTaskColumns
}

// RemoveProjectTaskColumnIDs removes the "projectTaskColumns" edge to the ProjectTaskColumn entity by IDs.
func (m *TaskColumnMutation) RemoveProjectTaskColumnIDs(ids ...ulid.ID) {
	if m.removedprojectTaskColumns == nil {
		m.removedprojectTaskColumns = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.projectTaskColumns, ids[i])
		m.removedprojectTaskColumns[ids[i]] = struct{}{}
	}
}

// RemovedProjectTaskColumns returns the removed IDs of the "projectTaskColumns" edge to the ProjectTaskColumn entity.
func (m *TaskColumnMutation) RemovedProjectTaskColumnsIDs() (ids []ulid.ID) {
	for id := range m.removedprojectTaskColumns {
		ids = append(ids, id)
	}
	return
}

// ProjectTaskColumnsIDs returns the "projectTaskColumns" edge IDs in the mutation.
func (m *TaskColumnMutation) ProjectTaskColumnsIDs() (ids []ulid.ID) {
	for id := range m.projectTaskColumns {
		ids = append(ids, id)
	}
	return
}

// ResetProjectTaskColumns resets all changes to the "projectTaskColumns" edge.
func (m *TaskColumnMutation) ResetProjectTaskColumns() {
	m.projectTaskColumns = nil
	m.clearedprojectTaskColumns = false
	m.removedprojectTaskColumns = nil
}

// Where appends a list predicates to the TaskColumnMutation builder.
func (m *TaskColumnMutation) Where(ps ...predicate.TaskColumn) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskColumnMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TaskColumn).
func (m *TaskColumnMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskColumnMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, taskcolumn.FieldName)
	}
	if m._type != nil {
		fields = append(fields, taskcolumn.FieldType)
	}
	if m.created_at != nil {
		fields = append(fields, taskcolumn.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, taskcolumn.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskColumnMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case taskcolumn.FieldName:
		return m.Name()
	case taskcolumn.FieldType:
		return m.GetType()
	case taskcolumn.FieldCreatedAt:
		return m.CreatedAt()
	case taskcolumn.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskColumnMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case taskcolumn.FieldName:
		return m.OldName(ctx)
	case taskcolumn.FieldType:
		return m.OldType(ctx)
	case taskcolumn.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case taskcolumn.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TaskColumn field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskColumnMutation) SetField(name string, value ent.Value) error {
	switch name {
	case taskcolumn.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case taskcolumn.FieldType:
		v, ok := value.(taskcolumn.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case taskcolumn.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case taskcolumn.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TaskColumn field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskColumnMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskColumnMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskColumnMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskColumn numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskColumnMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskColumnMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskColumnMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TaskColumn nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskColumnMutation) ResetField(name string) error {
	switch name {
	case taskcolumn.FieldName:
		m.ResetName()
		return nil
	case taskcolumn.FieldType:
		m.ResetType()
		return nil
	case taskcolumn.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case taskcolumn.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TaskColumn field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskColumnMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.teammateTaskColumns != nil {
		edges = append(edges, taskcolumn.EdgeTeammateTaskColumns)
	}
	if m.projectTaskColumns != nil {
		edges = append(edges, taskcolumn.EdgeProjectTaskColumns)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskColumnMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case taskcolumn.EdgeTeammateTaskColumns:
		ids := make([]ent.Value, 0, len(m.teammateTaskColumns))
		for id := range m.teammateTaskColumns {
			ids = append(ids, id)
		}
		return ids
	case taskcolumn.EdgeProjectTaskColumns:
		ids := make([]ent.Value, 0, len(m.projectTaskColumns))
		for id := range m.projectTaskColumns {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskColumnMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedteammateTaskColumns != nil {
		edges = append(edges, taskcolumn.EdgeTeammateTaskColumns)
	}
	if m.removedprojectTaskColumns != nil {
		edges = append(edges, taskcolumn.EdgeProjectTaskColumns)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskColumnMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case taskcolumn.EdgeTeammateTaskColumns:
		ids := make([]ent.Value, 0, len(m.removedteammateTaskColumns))
		for id := range m.removedteammateTaskColumns {
			ids = append(ids, id)
		}
		return ids
	case taskcolumn.EdgeProjectTaskColumns:
		ids := make([]ent.Value, 0, len(m.removedprojectTaskColumns))
		for id := range m.removedprojectTaskColumns {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskColumnMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedteammateTaskColumns {
		edges = append(edges, taskcolumn.EdgeTeammateTaskColumns)
	}
	if m.clearedprojectTaskColumns {
		edges = append(edges, taskcolumn.EdgeProjectTaskColumns)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskColumnMutation) EdgeCleared(name string) bool {
	switch name {
	case taskcolumn.EdgeTeammateTaskColumns:
		return m.clearedteammateTaskColumns
	case taskcolumn.EdgeProjectTaskColumns:
		return m.clearedprojectTaskColumns
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskColumnMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskColumn unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskColumnMutation) ResetEdge(name string) error {
	switch name {
	case taskcolumn.EdgeTeammateTaskColumns:
		m.ResetTeammateTaskColumns()
		return nil
	case taskcolumn.EdgeProjectTaskColumns:
		m.ResetProjectTaskColumns()
		return nil
	}
	return fmt.Errorf("unknown TaskColumn edge %s", name)
}

// TaskFeedMutation represents an operation that mutates the TaskFeed nodes in the graph.
type TaskFeedMutation struct {
	config
	op                   Op
	typ                  string
	id                   *ulid.ID
	description          *map[string]interface{}
	is_first             *bool
	is_pinned            *bool
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	task                 *ulid.ID
	clearedtask          bool
	teammate             *ulid.ID
	clearedteammate      bool
	taskFeedLikes        map[ulid.ID]struct{}
	removedtaskFeedLikes map[ulid.ID]struct{}
	clearedtaskFeedLikes bool
	taskFiles            map[ulid.ID]struct{}
	removedtaskFiles     map[ulid.ID]struct{}
	clearedtaskFiles     bool
	done                 bool
	oldValue             func(context.Context) (*TaskFeed, error)
	predicates           []predicate.TaskFeed
}

var _ ent.Mutation = (*TaskFeedMutation)(nil)

// taskfeedOption allows management of the mutation configuration using functional options.
type taskfeedOption func(*TaskFeedMutation)

// newTaskFeedMutation creates new mutation for the TaskFeed entity.
func newTaskFeedMutation(c config, op Op, opts ...taskfeedOption) *TaskFeedMutation {
	m := &TaskFeedMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskFeed,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskFeedID sets the ID field of the mutation.
func withTaskFeedID(id ulid.ID) taskfeedOption {
	return func(m *TaskFeedMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskFeed
		)
		m.oldValue = func(ctx context.Context) (*TaskFeed, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskFeed.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskFeed sets the old TaskFeed of the mutation.
func withTaskFeed(node *TaskFeed) taskfeedOption {
	return func(m *TaskFeedMutation) {
		m.oldValue = func(context.Context) (*TaskFeed, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskFeedMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskFeedMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskFeed entities.
func (m *TaskFeedMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskFeedMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskFeedMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskFeed.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTaskID sets the "task_id" field.
func (m *TaskFeedMutation) SetTaskID(u ulid.ID) {
	m.task = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *TaskFeedMutation) TaskID() (r ulid.ID, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the TaskFeed entity.
// If the TaskFeed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskFeedMutation) OldTaskID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *TaskFeedMutation) ResetTaskID() {
	m.task = nil
}

// SetTeammateID sets the "teammate_id" field.
func (m *TaskFeedMutation) SetTeammateID(u ulid.ID) {
	m.teammate = &u
}

// TeammateID returns the value of the "teammate_id" field in the mutation.
func (m *TaskFeedMutation) TeammateID() (r ulid.ID, exists bool) {
	v := m.teammate
	if v == nil {
		return
	}
	return *v, true
}

// OldTeammateID returns the old "teammate_id" field's value of the TaskFeed entity.
// If the TaskFeed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskFeedMutation) OldTeammateID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeammateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeammateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeammateID: %w", err)
	}
	return oldValue.TeammateID, nil
}

// ResetTeammateID resets all changes to the "teammate_id" field.
func (m *TaskFeedMutation) ResetTeammateID() {
	m.teammate = nil
}

// SetDescription sets the "description" field.
func (m *TaskFeedMutation) SetDescription(value map[string]interface{}) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *TaskFeedMutation) Description() (r map[string]interface{}, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TaskFeed entity.
// If the TaskFeed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskFeedMutation) OldDescription(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TaskFeedMutation) ResetDescription() {
	m.description = nil
}

// SetIsFirst sets the "is_first" field.
func (m *TaskFeedMutation) SetIsFirst(b bool) {
	m.is_first = &b
}

// IsFirst returns the value of the "is_first" field in the mutation.
func (m *TaskFeedMutation) IsFirst() (r bool, exists bool) {
	v := m.is_first
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFirst returns the old "is_first" field's value of the TaskFeed entity.
// If the TaskFeed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskFeedMutation) OldIsFirst(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFirst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFirst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFirst: %w", err)
	}
	return oldValue.IsFirst, nil
}

// ResetIsFirst resets all changes to the "is_first" field.
func (m *TaskFeedMutation) ResetIsFirst() {
	m.is_first = nil
}

// SetIsPinned sets the "is_pinned" field.
func (m *TaskFeedMutation) SetIsPinned(b bool) {
	m.is_pinned = &b
}

// IsPinned returns the value of the "is_pinned" field in the mutation.
func (m *TaskFeedMutation) IsPinned() (r bool, exists bool) {
	v := m.is_pinned
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPinned returns the old "is_pinned" field's value of the TaskFeed entity.
// If the TaskFeed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskFeedMutation) OldIsPinned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPinned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPinned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPinned: %w", err)
	}
	return oldValue.IsPinned, nil
}

// ResetIsPinned resets all changes to the "is_pinned" field.
func (m *TaskFeedMutation) ResetIsPinned() {
	m.is_pinned = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskFeedMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskFeedMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskFeed entity.
// If the TaskFeed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskFeedMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskFeedMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskFeedMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskFeedMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskFeed entity.
// If the TaskFeed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskFeedMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskFeedMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTask clears the "task" edge to the Task entity.
func (m *TaskFeedMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *TaskFeedMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *TaskFeedMutation) TaskIDs() (ids []ulid.ID) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *TaskFeedMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// ClearTeammate clears the "teammate" edge to the Teammate entity.
func (m *TaskFeedMutation) ClearTeammate() {
	m.clearedteammate = true
}

// TeammateCleared reports if the "teammate" edge to the Teammate entity was cleared.
func (m *TaskFeedMutation) TeammateCleared() bool {
	return m.clearedteammate
}

// TeammateIDs returns the "teammate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeammateID instead. It exists only for internal usage by the builders.
func (m *TaskFeedMutation) TeammateIDs() (ids []ulid.ID) {
	if id := m.teammate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeammate resets all changes to the "teammate" edge.
func (m *TaskFeedMutation) ResetTeammate() {
	m.teammate = nil
	m.clearedteammate = false
}

// AddTaskFeedLikeIDs adds the "taskFeedLikes" edge to the TaskFeedLike entity by ids.
func (m *TaskFeedMutation) AddTaskFeedLikeIDs(ids ...ulid.ID) {
	if m.taskFeedLikes == nil {
		m.taskFeedLikes = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.taskFeedLikes[ids[i]] = struct{}{}
	}
}

// ClearTaskFeedLikes clears the "taskFeedLikes" edge to the TaskFeedLike entity.
func (m *TaskFeedMutation) ClearTaskFeedLikes() {
	m.clearedtaskFeedLikes = true
}

// TaskFeedLikesCleared reports if the "taskFeedLikes" edge to the TaskFeedLike entity was cleared.
func (m *TaskFeedMutation) TaskFeedLikesCleared() bool {
	return m.clearedtaskFeedLikes
}

// RemoveTaskFeedLikeIDs removes the "taskFeedLikes" edge to the TaskFeedLike entity by IDs.
func (m *TaskFeedMutation) RemoveTaskFeedLikeIDs(ids ...ulid.ID) {
	if m.removedtaskFeedLikes == nil {
		m.removedtaskFeedLikes = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.taskFeedLikes, ids[i])
		m.removedtaskFeedLikes[ids[i]] = struct{}{}
	}
}

// RemovedTaskFeedLikes returns the removed IDs of the "taskFeedLikes" edge to the TaskFeedLike entity.
func (m *TaskFeedMutation) RemovedTaskFeedLikesIDs() (ids []ulid.ID) {
	for id := range m.removedtaskFeedLikes {
		ids = append(ids, id)
	}
	return
}

// TaskFeedLikesIDs returns the "taskFeedLikes" edge IDs in the mutation.
func (m *TaskFeedMutation) TaskFeedLikesIDs() (ids []ulid.ID) {
	for id := range m.taskFeedLikes {
		ids = append(ids, id)
	}
	return
}

// ResetTaskFeedLikes resets all changes to the "taskFeedLikes" edge.
func (m *TaskFeedMutation) ResetTaskFeedLikes() {
	m.taskFeedLikes = nil
	m.clearedtaskFeedLikes = false
	m.removedtaskFeedLikes = nil
}

// AddTaskFileIDs adds the "taskFiles" edge to the TaskFile entity by ids.
func (m *TaskFeedMutation) AddTaskFileIDs(ids ...ulid.ID) {
	if m.taskFiles == nil {
		m.taskFiles = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.taskFiles[ids[i]] = struct{}{}
	}
}

// ClearTaskFiles clears the "taskFiles" edge to the TaskFile entity.
func (m *TaskFeedMutation) ClearTaskFiles() {
	m.clearedtaskFiles = true
}

// TaskFilesCleared reports if the "taskFiles" edge to the TaskFile entity was cleared.
func (m *TaskFeedMutation) TaskFilesCleared() bool {
	return m.clearedtaskFiles
}

// RemoveTaskFileIDs removes the "taskFiles" edge to the TaskFile entity by IDs.
func (m *TaskFeedMutation) RemoveTaskFileIDs(ids ...ulid.ID) {
	if m.removedtaskFiles == nil {
		m.removedtaskFiles = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.taskFiles, ids[i])
		m.removedtaskFiles[ids[i]] = struct{}{}
	}
}

// RemovedTaskFiles returns the removed IDs of the "taskFiles" edge to the TaskFile entity.
func (m *TaskFeedMutation) RemovedTaskFilesIDs() (ids []ulid.ID) {
	for id := range m.removedtaskFiles {
		ids = append(ids, id)
	}
	return
}

// TaskFilesIDs returns the "taskFiles" edge IDs in the mutation.
func (m *TaskFeedMutation) TaskFilesIDs() (ids []ulid.ID) {
	for id := range m.taskFiles {
		ids = append(ids, id)
	}
	return
}

// ResetTaskFiles resets all changes to the "taskFiles" edge.
func (m *TaskFeedMutation) ResetTaskFiles() {
	m.taskFiles = nil
	m.clearedtaskFiles = false
	m.removedtaskFiles = nil
}

// Where appends a list predicates to the TaskFeedMutation builder.
func (m *TaskFeedMutation) Where(ps ...predicate.TaskFeed) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskFeedMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TaskFeed).
func (m *TaskFeedMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskFeedMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.task != nil {
		fields = append(fields, taskfeed.FieldTaskID)
	}
	if m.teammate != nil {
		fields = append(fields, taskfeed.FieldTeammateID)
	}
	if m.description != nil {
		fields = append(fields, taskfeed.FieldDescription)
	}
	if m.is_first != nil {
		fields = append(fields, taskfeed.FieldIsFirst)
	}
	if m.is_pinned != nil {
		fields = append(fields, taskfeed.FieldIsPinned)
	}
	if m.created_at != nil {
		fields = append(fields, taskfeed.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, taskfeed.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskFeedMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case taskfeed.FieldTaskID:
		return m.TaskID()
	case taskfeed.FieldTeammateID:
		return m.TeammateID()
	case taskfeed.FieldDescription:
		return m.Description()
	case taskfeed.FieldIsFirst:
		return m.IsFirst()
	case taskfeed.FieldIsPinned:
		return m.IsPinned()
	case taskfeed.FieldCreatedAt:
		return m.CreatedAt()
	case taskfeed.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskFeedMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case taskfeed.FieldTaskID:
		return m.OldTaskID(ctx)
	case taskfeed.FieldTeammateID:
		return m.OldTeammateID(ctx)
	case taskfeed.FieldDescription:
		return m.OldDescription(ctx)
	case taskfeed.FieldIsFirst:
		return m.OldIsFirst(ctx)
	case taskfeed.FieldIsPinned:
		return m.OldIsPinned(ctx)
	case taskfeed.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case taskfeed.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TaskFeed field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskFeedMutation) SetField(name string, value ent.Value) error {
	switch name {
	case taskfeed.FieldTaskID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case taskfeed.FieldTeammateID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeammateID(v)
		return nil
	case taskfeed.FieldDescription:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case taskfeed.FieldIsFirst:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFirst(v)
		return nil
	case taskfeed.FieldIsPinned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPinned(v)
		return nil
	case taskfeed.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case taskfeed.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TaskFeed field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskFeedMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskFeedMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskFeedMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskFeed numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskFeedMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskFeedMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskFeedMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TaskFeed nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskFeedMutation) ResetField(name string) error {
	switch name {
	case taskfeed.FieldTaskID:
		m.ResetTaskID()
		return nil
	case taskfeed.FieldTeammateID:
		m.ResetTeammateID()
		return nil
	case taskfeed.FieldDescription:
		m.ResetDescription()
		return nil
	case taskfeed.FieldIsFirst:
		m.ResetIsFirst()
		return nil
	case taskfeed.FieldIsPinned:
		m.ResetIsPinned()
		return nil
	case taskfeed.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case taskfeed.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TaskFeed field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskFeedMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.task != nil {
		edges = append(edges, taskfeed.EdgeTask)
	}
	if m.teammate != nil {
		edges = append(edges, taskfeed.EdgeTeammate)
	}
	if m.taskFeedLikes != nil {
		edges = append(edges, taskfeed.EdgeTaskFeedLikes)
	}
	if m.taskFiles != nil {
		edges = append(edges, taskfeed.EdgeTaskFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskFeedMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case taskfeed.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case taskfeed.EdgeTeammate:
		if id := m.teammate; id != nil {
			return []ent.Value{*id}
		}
	case taskfeed.EdgeTaskFeedLikes:
		ids := make([]ent.Value, 0, len(m.taskFeedLikes))
		for id := range m.taskFeedLikes {
			ids = append(ids, id)
		}
		return ids
	case taskfeed.EdgeTaskFiles:
		ids := make([]ent.Value, 0, len(m.taskFiles))
		for id := range m.taskFiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskFeedMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtaskFeedLikes != nil {
		edges = append(edges, taskfeed.EdgeTaskFeedLikes)
	}
	if m.removedtaskFiles != nil {
		edges = append(edges, taskfeed.EdgeTaskFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskFeedMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case taskfeed.EdgeTaskFeedLikes:
		ids := make([]ent.Value, 0, len(m.removedtaskFeedLikes))
		for id := range m.removedtaskFeedLikes {
			ids = append(ids, id)
		}
		return ids
	case taskfeed.EdgeTaskFiles:
		ids := make([]ent.Value, 0, len(m.removedtaskFiles))
		for id := range m.removedtaskFiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskFeedMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtask {
		edges = append(edges, taskfeed.EdgeTask)
	}
	if m.clearedteammate {
		edges = append(edges, taskfeed.EdgeTeammate)
	}
	if m.clearedtaskFeedLikes {
		edges = append(edges, taskfeed.EdgeTaskFeedLikes)
	}
	if m.clearedtaskFiles {
		edges = append(edges, taskfeed.EdgeTaskFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskFeedMutation) EdgeCleared(name string) bool {
	switch name {
	case taskfeed.EdgeTask:
		return m.clearedtask
	case taskfeed.EdgeTeammate:
		return m.clearedteammate
	case taskfeed.EdgeTaskFeedLikes:
		return m.clearedtaskFeedLikes
	case taskfeed.EdgeTaskFiles:
		return m.clearedtaskFiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskFeedMutation) ClearEdge(name string) error {
	switch name {
	case taskfeed.EdgeTask:
		m.ClearTask()
		return nil
	case taskfeed.EdgeTeammate:
		m.ClearTeammate()
		return nil
	}
	return fmt.Errorf("unknown TaskFeed unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskFeedMutation) ResetEdge(name string) error {
	switch name {
	case taskfeed.EdgeTask:
		m.ResetTask()
		return nil
	case taskfeed.EdgeTeammate:
		m.ResetTeammate()
		return nil
	case taskfeed.EdgeTaskFeedLikes:
		m.ResetTaskFeedLikes()
		return nil
	case taskfeed.EdgeTaskFiles:
		m.ResetTaskFiles()
		return nil
	}
	return fmt.Errorf("unknown TaskFeed edge %s", name)
}

// TaskFeedLikeMutation represents an operation that mutates the TaskFeedLike nodes in the graph.
type TaskFeedLikeMutation struct {
	config
	op              Op
	typ             string
	id              *ulid.ID
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	task            *ulid.ID
	clearedtask     bool
	teammate        *ulid.ID
	clearedteammate bool
	feed            *ulid.ID
	clearedfeed     bool
	done            bool
	oldValue        func(context.Context) (*TaskFeedLike, error)
	predicates      []predicate.TaskFeedLike
}

var _ ent.Mutation = (*TaskFeedLikeMutation)(nil)

// taskfeedlikeOption allows management of the mutation configuration using functional options.
type taskfeedlikeOption func(*TaskFeedLikeMutation)

// newTaskFeedLikeMutation creates new mutation for the TaskFeedLike entity.
func newTaskFeedLikeMutation(c config, op Op, opts ...taskfeedlikeOption) *TaskFeedLikeMutation {
	m := &TaskFeedLikeMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskFeedLike,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskFeedLikeID sets the ID field of the mutation.
func withTaskFeedLikeID(id ulid.ID) taskfeedlikeOption {
	return func(m *TaskFeedLikeMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskFeedLike
		)
		m.oldValue = func(ctx context.Context) (*TaskFeedLike, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskFeedLike.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskFeedLike sets the old TaskFeedLike of the mutation.
func withTaskFeedLike(node *TaskFeedLike) taskfeedlikeOption {
	return func(m *TaskFeedLikeMutation) {
		m.oldValue = func(context.Context) (*TaskFeedLike, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskFeedLikeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskFeedLikeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskFeedLike entities.
func (m *TaskFeedLikeMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskFeedLikeMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskFeedLikeMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskFeedLike.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTaskID sets the "task_id" field.
func (m *TaskFeedLikeMutation) SetTaskID(u ulid.ID) {
	m.task = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *TaskFeedLikeMutation) TaskID() (r ulid.ID, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the TaskFeedLike entity.
// If the TaskFeedLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskFeedLikeMutation) OldTaskID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *TaskFeedLikeMutation) ResetTaskID() {
	m.task = nil
}

// SetTeammateID sets the "teammate_id" field.
func (m *TaskFeedLikeMutation) SetTeammateID(u ulid.ID) {
	m.teammate = &u
}

// TeammateID returns the value of the "teammate_id" field in the mutation.
func (m *TaskFeedLikeMutation) TeammateID() (r ulid.ID, exists bool) {
	v := m.teammate
	if v == nil {
		return
	}
	return *v, true
}

// OldTeammateID returns the old "teammate_id" field's value of the TaskFeedLike entity.
// If the TaskFeedLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskFeedLikeMutation) OldTeammateID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeammateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeammateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeammateID: %w", err)
	}
	return oldValue.TeammateID, nil
}

// ResetTeammateID resets all changes to the "teammate_id" field.
func (m *TaskFeedLikeMutation) ResetTeammateID() {
	m.teammate = nil
}

// SetTaskFeedID sets the "task_feed_id" field.
func (m *TaskFeedLikeMutation) SetTaskFeedID(u ulid.ID) {
	m.feed = &u
}

// TaskFeedID returns the value of the "task_feed_id" field in the mutation.
func (m *TaskFeedLikeMutation) TaskFeedID() (r ulid.ID, exists bool) {
	v := m.feed
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskFeedID returns the old "task_feed_id" field's value of the TaskFeedLike entity.
// If the TaskFeedLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskFeedLikeMutation) OldTaskFeedID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskFeedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskFeedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskFeedID: %w", err)
	}
	return oldValue.TaskFeedID, nil
}

// ResetTaskFeedID resets all changes to the "task_feed_id" field.
func (m *TaskFeedLikeMutation) ResetTaskFeedID() {
	m.feed = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskFeedLikeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskFeedLikeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskFeedLike entity.
// If the TaskFeedLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskFeedLikeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskFeedLikeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskFeedLikeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskFeedLikeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskFeedLike entity.
// If the TaskFeedLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskFeedLikeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskFeedLikeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTask clears the "task" edge to the Task entity.
func (m *TaskFeedLikeMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *TaskFeedLikeMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *TaskFeedLikeMutation) TaskIDs() (ids []ulid.ID) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *TaskFeedLikeMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// ClearTeammate clears the "teammate" edge to the Teammate entity.
func (m *TaskFeedLikeMutation) ClearTeammate() {
	m.clearedteammate = true
}

// TeammateCleared reports if the "teammate" edge to the Teammate entity was cleared.
func (m *TaskFeedLikeMutation) TeammateCleared() bool {
	return m.clearedteammate
}

// TeammateIDs returns the "teammate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeammateID instead. It exists only for internal usage by the builders.
func (m *TaskFeedLikeMutation) TeammateIDs() (ids []ulid.ID) {
	if id := m.teammate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeammate resets all changes to the "teammate" edge.
func (m *TaskFeedLikeMutation) ResetTeammate() {
	m.teammate = nil
	m.clearedteammate = false
}

// SetFeedID sets the "feed" edge to the TaskFeed entity by id.
func (m *TaskFeedLikeMutation) SetFeedID(id ulid.ID) {
	m.feed = &id
}

// ClearFeed clears the "feed" edge to the TaskFeed entity.
func (m *TaskFeedLikeMutation) ClearFeed() {
	m.clearedfeed = true
}

// FeedCleared reports if the "feed" edge to the TaskFeed entity was cleared.
func (m *TaskFeedLikeMutation) FeedCleared() bool {
	return m.clearedfeed
}

// FeedID returns the "feed" edge ID in the mutation.
func (m *TaskFeedLikeMutation) FeedID() (id ulid.ID, exists bool) {
	if m.feed != nil {
		return *m.feed, true
	}
	return
}

// FeedIDs returns the "feed" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeedID instead. It exists only for internal usage by the builders.
func (m *TaskFeedLikeMutation) FeedIDs() (ids []ulid.ID) {
	if id := m.feed; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeed resets all changes to the "feed" edge.
func (m *TaskFeedLikeMutation) ResetFeed() {
	m.feed = nil
	m.clearedfeed = false
}

// Where appends a list predicates to the TaskFeedLikeMutation builder.
func (m *TaskFeedLikeMutation) Where(ps ...predicate.TaskFeedLike) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskFeedLikeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TaskFeedLike).
func (m *TaskFeedLikeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskFeedLikeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.task != nil {
		fields = append(fields, taskfeedlike.FieldTaskID)
	}
	if m.teammate != nil {
		fields = append(fields, taskfeedlike.FieldTeammateID)
	}
	if m.feed != nil {
		fields = append(fields, taskfeedlike.FieldTaskFeedID)
	}
	if m.created_at != nil {
		fields = append(fields, taskfeedlike.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, taskfeedlike.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskFeedLikeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case taskfeedlike.FieldTaskID:
		return m.TaskID()
	case taskfeedlike.FieldTeammateID:
		return m.TeammateID()
	case taskfeedlike.FieldTaskFeedID:
		return m.TaskFeedID()
	case taskfeedlike.FieldCreatedAt:
		return m.CreatedAt()
	case taskfeedlike.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskFeedLikeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case taskfeedlike.FieldTaskID:
		return m.OldTaskID(ctx)
	case taskfeedlike.FieldTeammateID:
		return m.OldTeammateID(ctx)
	case taskfeedlike.FieldTaskFeedID:
		return m.OldTaskFeedID(ctx)
	case taskfeedlike.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case taskfeedlike.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TaskFeedLike field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskFeedLikeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case taskfeedlike.FieldTaskID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case taskfeedlike.FieldTeammateID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeammateID(v)
		return nil
	case taskfeedlike.FieldTaskFeedID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskFeedID(v)
		return nil
	case taskfeedlike.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case taskfeedlike.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TaskFeedLike field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskFeedLikeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskFeedLikeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskFeedLikeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskFeedLike numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskFeedLikeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskFeedLikeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskFeedLikeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TaskFeedLike nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskFeedLikeMutation) ResetField(name string) error {
	switch name {
	case taskfeedlike.FieldTaskID:
		m.ResetTaskID()
		return nil
	case taskfeedlike.FieldTeammateID:
		m.ResetTeammateID()
		return nil
	case taskfeedlike.FieldTaskFeedID:
		m.ResetTaskFeedID()
		return nil
	case taskfeedlike.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case taskfeedlike.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TaskFeedLike field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskFeedLikeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.task != nil {
		edges = append(edges, taskfeedlike.EdgeTask)
	}
	if m.teammate != nil {
		edges = append(edges, taskfeedlike.EdgeTeammate)
	}
	if m.feed != nil {
		edges = append(edges, taskfeedlike.EdgeFeed)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskFeedLikeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case taskfeedlike.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case taskfeedlike.EdgeTeammate:
		if id := m.teammate; id != nil {
			return []ent.Value{*id}
		}
	case taskfeedlike.EdgeFeed:
		if id := m.feed; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskFeedLikeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskFeedLikeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskFeedLikeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtask {
		edges = append(edges, taskfeedlike.EdgeTask)
	}
	if m.clearedteammate {
		edges = append(edges, taskfeedlike.EdgeTeammate)
	}
	if m.clearedfeed {
		edges = append(edges, taskfeedlike.EdgeFeed)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskFeedLikeMutation) EdgeCleared(name string) bool {
	switch name {
	case taskfeedlike.EdgeTask:
		return m.clearedtask
	case taskfeedlike.EdgeTeammate:
		return m.clearedteammate
	case taskfeedlike.EdgeFeed:
		return m.clearedfeed
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskFeedLikeMutation) ClearEdge(name string) error {
	switch name {
	case taskfeedlike.EdgeTask:
		m.ClearTask()
		return nil
	case taskfeedlike.EdgeTeammate:
		m.ClearTeammate()
		return nil
	case taskfeedlike.EdgeFeed:
		m.ClearFeed()
		return nil
	}
	return fmt.Errorf("unknown TaskFeedLike unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskFeedLikeMutation) ResetEdge(name string) error {
	switch name {
	case taskfeedlike.EdgeTask:
		m.ResetTask()
		return nil
	case taskfeedlike.EdgeTeammate:
		m.ResetTeammate()
		return nil
	case taskfeedlike.EdgeFeed:
		m.ResetFeed()
		return nil
	}
	return fmt.Errorf("unknown TaskFeedLike edge %s", name)
}

// TaskFileMutation represents an operation that mutates the TaskFile nodes in the graph.
type TaskFileMutation struct {
	config
	op              Op
	typ             string
	id              *ulid.ID
	name            *string
	src             *string
	attached        *bool
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	project         *ulid.ID
	clearedproject  bool
	task            *ulid.ID
	clearedtask     bool
	taskFeed        *ulid.ID
	clearedtaskFeed bool
	fileType        *ulid.ID
	clearedfileType bool
	done            bool
	oldValue        func(context.Context) (*TaskFile, error)
	predicates      []predicate.TaskFile
}

var _ ent.Mutation = (*TaskFileMutation)(nil)

// taskfileOption allows management of the mutation configuration using functional options.
type taskfileOption func(*TaskFileMutation)

// newTaskFileMutation creates new mutation for the TaskFile entity.
func newTaskFileMutation(c config, op Op, opts ...taskfileOption) *TaskFileMutation {
	m := &TaskFileMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskFileID sets the ID field of the mutation.
func withTaskFileID(id ulid.ID) taskfileOption {
	return func(m *TaskFileMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskFile
		)
		m.oldValue = func(ctx context.Context) (*TaskFile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskFile sets the old TaskFile of the mutation.
func withTaskFile(node *TaskFile) taskfileOption {
	return func(m *TaskFileMutation) {
		m.oldValue = func(context.Context) (*TaskFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskFile entities.
func (m *TaskFileMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskFileMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskFileMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskFile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectID sets the "project_id" field.
func (m *TaskFileMutation) SetProjectID(u ulid.ID) {
	m.project = &u
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *TaskFileMutation) ProjectID() (r ulid.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the TaskFile entity.
// If the TaskFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskFileMutation) OldProjectID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *TaskFileMutation) ResetProjectID() {
	m.project = nil
}

// SetTaskID sets the "task_id" field.
func (m *TaskFileMutation) SetTaskID(u ulid.ID) {
	m.task = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *TaskFileMutation) TaskID() (r ulid.ID, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the TaskFile entity.
// If the TaskFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskFileMutation) OldTaskID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *TaskFileMutation) ResetTaskID() {
	m.task = nil
}

// SetTaskFeedID sets the "task_feed_id" field.
func (m *TaskFileMutation) SetTaskFeedID(u ulid.ID) {
	m.taskFeed = &u
}

// TaskFeedID returns the value of the "task_feed_id" field in the mutation.
func (m *TaskFileMutation) TaskFeedID() (r ulid.ID, exists bool) {
	v := m.taskFeed
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskFeedID returns the old "task_feed_id" field's value of the TaskFile entity.
// If the TaskFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskFileMutation) OldTaskFeedID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskFeedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskFeedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskFeedID: %w", err)
	}
	return oldValue.TaskFeedID, nil
}

// ResetTaskFeedID resets all changes to the "task_feed_id" field.
func (m *TaskFileMutation) ResetTaskFeedID() {
	m.taskFeed = nil
}

// SetFileTypeID sets the "file_type_id" field.
func (m *TaskFileMutation) SetFileTypeID(u ulid.ID) {
	m.fileType = &u
}

// FileTypeID returns the value of the "file_type_id" field in the mutation.
func (m *TaskFileMutation) FileTypeID() (r ulid.ID, exists bool) {
	v := m.fileType
	if v == nil {
		return
	}
	return *v, true
}

// OldFileTypeID returns the old "file_type_id" field's value of the TaskFile entity.
// If the TaskFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskFileMutation) OldFileTypeID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileTypeID: %w", err)
	}
	return oldValue.FileTypeID, nil
}

// ResetFileTypeID resets all changes to the "file_type_id" field.
func (m *TaskFileMutation) ResetFileTypeID() {
	m.fileType = nil
}

// SetName sets the "name" field.
func (m *TaskFileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TaskFileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TaskFile entity.
// If the TaskFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskFileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TaskFileMutation) ResetName() {
	m.name = nil
}

// SetSrc sets the "src" field.
func (m *TaskFileMutation) SetSrc(s string) {
	m.src = &s
}

// Src returns the value of the "src" field in the mutation.
func (m *TaskFileMutation) Src() (r string, exists bool) {
	v := m.src
	if v == nil {
		return
	}
	return *v, true
}

// OldSrc returns the old "src" field's value of the TaskFile entity.
// If the TaskFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskFileMutation) OldSrc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSrc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSrc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSrc: %w", err)
	}
	return oldValue.Src, nil
}

// ResetSrc resets all changes to the "src" field.
func (m *TaskFileMutation) ResetSrc() {
	m.src = nil
}

// SetAttached sets the "attached" field.
func (m *TaskFileMutation) SetAttached(b bool) {
	m.attached = &b
}

// Attached returns the value of the "attached" field in the mutation.
func (m *TaskFileMutation) Attached() (r bool, exists bool) {
	v := m.attached
	if v == nil {
		return
	}
	return *v, true
}

// OldAttached returns the old "attached" field's value of the TaskFile entity.
// If the TaskFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskFileMutation) OldAttached(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttached is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttached requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttached: %w", err)
	}
	return oldValue.Attached, nil
}

// ResetAttached resets all changes to the "attached" field.
func (m *TaskFileMutation) ResetAttached() {
	m.attached = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskFileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskFileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskFile entity.
// If the TaskFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskFileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskFileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskFileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskFileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskFile entity.
// If the TaskFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskFileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskFileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *TaskFileMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *TaskFileMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *TaskFileMutation) ProjectIDs() (ids []ulid.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *TaskFileMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearTask clears the "task" edge to the Task entity.
func (m *TaskFileMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *TaskFileMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *TaskFileMutation) TaskIDs() (ids []ulid.ID) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *TaskFileMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// ClearTaskFeed clears the "taskFeed" edge to the TaskFeed entity.
func (m *TaskFileMutation) ClearTaskFeed() {
	m.clearedtaskFeed = true
}

// TaskFeedCleared reports if the "taskFeed" edge to the TaskFeed entity was cleared.
func (m *TaskFileMutation) TaskFeedCleared() bool {
	return m.clearedtaskFeed
}

// TaskFeedIDs returns the "taskFeed" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskFeedID instead. It exists only for internal usage by the builders.
func (m *TaskFileMutation) TaskFeedIDs() (ids []ulid.ID) {
	if id := m.taskFeed; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTaskFeed resets all changes to the "taskFeed" edge.
func (m *TaskFileMutation) ResetTaskFeed() {
	m.taskFeed = nil
	m.clearedtaskFeed = false
}

// ClearFileType clears the "fileType" edge to the FileType entity.
func (m *TaskFileMutation) ClearFileType() {
	m.clearedfileType = true
}

// FileTypeCleared reports if the "fileType" edge to the FileType entity was cleared.
func (m *TaskFileMutation) FileTypeCleared() bool {
	return m.clearedfileType
}

// FileTypeIDs returns the "fileType" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileTypeID instead. It exists only for internal usage by the builders.
func (m *TaskFileMutation) FileTypeIDs() (ids []ulid.ID) {
	if id := m.fileType; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFileType resets all changes to the "fileType" edge.
func (m *TaskFileMutation) ResetFileType() {
	m.fileType = nil
	m.clearedfileType = false
}

// Where appends a list predicates to the TaskFileMutation builder.
func (m *TaskFileMutation) Where(ps ...predicate.TaskFile) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskFileMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TaskFile).
func (m *TaskFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskFileMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.project != nil {
		fields = append(fields, taskfile.FieldProjectID)
	}
	if m.task != nil {
		fields = append(fields, taskfile.FieldTaskID)
	}
	if m.taskFeed != nil {
		fields = append(fields, taskfile.FieldTaskFeedID)
	}
	if m.fileType != nil {
		fields = append(fields, taskfile.FieldFileTypeID)
	}
	if m.name != nil {
		fields = append(fields, taskfile.FieldName)
	}
	if m.src != nil {
		fields = append(fields, taskfile.FieldSrc)
	}
	if m.attached != nil {
		fields = append(fields, taskfile.FieldAttached)
	}
	if m.created_at != nil {
		fields = append(fields, taskfile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, taskfile.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case taskfile.FieldProjectID:
		return m.ProjectID()
	case taskfile.FieldTaskID:
		return m.TaskID()
	case taskfile.FieldTaskFeedID:
		return m.TaskFeedID()
	case taskfile.FieldFileTypeID:
		return m.FileTypeID()
	case taskfile.FieldName:
		return m.Name()
	case taskfile.FieldSrc:
		return m.Src()
	case taskfile.FieldAttached:
		return m.Attached()
	case taskfile.FieldCreatedAt:
		return m.CreatedAt()
	case taskfile.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case taskfile.FieldProjectID:
		return m.OldProjectID(ctx)
	case taskfile.FieldTaskID:
		return m.OldTaskID(ctx)
	case taskfile.FieldTaskFeedID:
		return m.OldTaskFeedID(ctx)
	case taskfile.FieldFileTypeID:
		return m.OldFileTypeID(ctx)
	case taskfile.FieldName:
		return m.OldName(ctx)
	case taskfile.FieldSrc:
		return m.OldSrc(ctx)
	case taskfile.FieldAttached:
		return m.OldAttached(ctx)
	case taskfile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case taskfile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TaskFile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case taskfile.FieldProjectID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case taskfile.FieldTaskID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case taskfile.FieldTaskFeedID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskFeedID(v)
		return nil
	case taskfile.FieldFileTypeID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileTypeID(v)
		return nil
	case taskfile.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case taskfile.FieldSrc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSrc(v)
		return nil
	case taskfile.FieldAttached:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttached(v)
		return nil
	case taskfile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case taskfile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TaskFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskFileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskFileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskFileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskFileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TaskFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskFileMutation) ResetField(name string) error {
	switch name {
	case taskfile.FieldProjectID:
		m.ResetProjectID()
		return nil
	case taskfile.FieldTaskID:
		m.ResetTaskID()
		return nil
	case taskfile.FieldTaskFeedID:
		m.ResetTaskFeedID()
		return nil
	case taskfile.FieldFileTypeID:
		m.ResetFileTypeID()
		return nil
	case taskfile.FieldName:
		m.ResetName()
		return nil
	case taskfile.FieldSrc:
		m.ResetSrc()
		return nil
	case taskfile.FieldAttached:
		m.ResetAttached()
		return nil
	case taskfile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case taskfile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TaskFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.project != nil {
		edges = append(edges, taskfile.EdgeProject)
	}
	if m.task != nil {
		edges = append(edges, taskfile.EdgeTask)
	}
	if m.taskFeed != nil {
		edges = append(edges, taskfile.EdgeTaskFeed)
	}
	if m.fileType != nil {
		edges = append(edges, taskfile.EdgeFileType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskFileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case taskfile.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case taskfile.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case taskfile.EdgeTaskFeed:
		if id := m.taskFeed; id != nil {
			return []ent.Value{*id}
		}
	case taskfile.EdgeFileType:
		if id := m.fileType; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskFileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedproject {
		edges = append(edges, taskfile.EdgeProject)
	}
	if m.clearedtask {
		edges = append(edges, taskfile.EdgeTask)
	}
	if m.clearedtaskFeed {
		edges = append(edges, taskfile.EdgeTaskFeed)
	}
	if m.clearedfileType {
		edges = append(edges, taskfile.EdgeFileType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskFileMutation) EdgeCleared(name string) bool {
	switch name {
	case taskfile.EdgeProject:
		return m.clearedproject
	case taskfile.EdgeTask:
		return m.clearedtask
	case taskfile.EdgeTaskFeed:
		return m.clearedtaskFeed
	case taskfile.EdgeFileType:
		return m.clearedfileType
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskFileMutation) ClearEdge(name string) error {
	switch name {
	case taskfile.EdgeProject:
		m.ClearProject()
		return nil
	case taskfile.EdgeTask:
		m.ClearTask()
		return nil
	case taskfile.EdgeTaskFeed:
		m.ClearTaskFeed()
		return nil
	case taskfile.EdgeFileType:
		m.ClearFileType()
		return nil
	}
	return fmt.Errorf("unknown TaskFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskFileMutation) ResetEdge(name string) error {
	switch name {
	case taskfile.EdgeProject:
		m.ResetProject()
		return nil
	case taskfile.EdgeTask:
		m.ResetTask()
		return nil
	case taskfile.EdgeTaskFeed:
		m.ResetTaskFeed()
		return nil
	case taskfile.EdgeFileType:
		m.ResetFileType()
		return nil
	}
	return fmt.Errorf("unknown TaskFile edge %s", name)
}

// TaskLikeMutation represents an operation that mutates the TaskLike nodes in the graph.
type TaskLikeMutation struct {
	config
	op               Op
	typ              string
	id               *ulid.ID
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	task             *ulid.ID
	clearedtask      bool
	teammate         *ulid.ID
	clearedteammate  bool
	workspace        *ulid.ID
	clearedworkspace bool
	done             bool
	oldValue         func(context.Context) (*TaskLike, error)
	predicates       []predicate.TaskLike
}

var _ ent.Mutation = (*TaskLikeMutation)(nil)

// tasklikeOption allows management of the mutation configuration using functional options.
type tasklikeOption func(*TaskLikeMutation)

// newTaskLikeMutation creates new mutation for the TaskLike entity.
func newTaskLikeMutation(c config, op Op, opts ...tasklikeOption) *TaskLikeMutation {
	m := &TaskLikeMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskLike,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskLikeID sets the ID field of the mutation.
func withTaskLikeID(id ulid.ID) tasklikeOption {
	return func(m *TaskLikeMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskLike
		)
		m.oldValue = func(ctx context.Context) (*TaskLike, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskLike.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskLike sets the old TaskLike of the mutation.
func withTaskLike(node *TaskLike) tasklikeOption {
	return func(m *TaskLikeMutation) {
		m.oldValue = func(context.Context) (*TaskLike, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskLikeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskLikeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskLike entities.
func (m *TaskLikeMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskLikeMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskLikeMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskLike.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTaskID sets the "task_id" field.
func (m *TaskLikeMutation) SetTaskID(u ulid.ID) {
	m.task = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *TaskLikeMutation) TaskID() (r ulid.ID, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the TaskLike entity.
// If the TaskLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLikeMutation) OldTaskID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *TaskLikeMutation) ResetTaskID() {
	m.task = nil
}

// SetTeammateID sets the "teammate_id" field.
func (m *TaskLikeMutation) SetTeammateID(u ulid.ID) {
	m.teammate = &u
}

// TeammateID returns the value of the "teammate_id" field in the mutation.
func (m *TaskLikeMutation) TeammateID() (r ulid.ID, exists bool) {
	v := m.teammate
	if v == nil {
		return
	}
	return *v, true
}

// OldTeammateID returns the old "teammate_id" field's value of the TaskLike entity.
// If the TaskLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLikeMutation) OldTeammateID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeammateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeammateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeammateID: %w", err)
	}
	return oldValue.TeammateID, nil
}

// ResetTeammateID resets all changes to the "teammate_id" field.
func (m *TaskLikeMutation) ResetTeammateID() {
	m.teammate = nil
}

// SetWorkspaceID sets the "workspace_id" field.
func (m *TaskLikeMutation) SetWorkspaceID(u ulid.ID) {
	m.workspace = &u
}

// WorkspaceID returns the value of the "workspace_id" field in the mutation.
func (m *TaskLikeMutation) WorkspaceID() (r ulid.ID, exists bool) {
	v := m.workspace
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspaceID returns the old "workspace_id" field's value of the TaskLike entity.
// If the TaskLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLikeMutation) OldWorkspaceID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspaceID: %w", err)
	}
	return oldValue.WorkspaceID, nil
}

// ResetWorkspaceID resets all changes to the "workspace_id" field.
func (m *TaskLikeMutation) ResetWorkspaceID() {
	m.workspace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskLikeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskLikeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskLike entity.
// If the TaskLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLikeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskLikeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskLikeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskLikeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskLike entity.
// If the TaskLike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskLikeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskLikeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTask clears the "task" edge to the Task entity.
func (m *TaskLikeMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *TaskLikeMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *TaskLikeMutation) TaskIDs() (ids []ulid.ID) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *TaskLikeMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// ClearTeammate clears the "teammate" edge to the Teammate entity.
func (m *TaskLikeMutation) ClearTeammate() {
	m.clearedteammate = true
}

// TeammateCleared reports if the "teammate" edge to the Teammate entity was cleared.
func (m *TaskLikeMutation) TeammateCleared() bool {
	return m.clearedteammate
}

// TeammateIDs returns the "teammate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeammateID instead. It exists only for internal usage by the builders.
func (m *TaskLikeMutation) TeammateIDs() (ids []ulid.ID) {
	if id := m.teammate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeammate resets all changes to the "teammate" edge.
func (m *TaskLikeMutation) ResetTeammate() {
	m.teammate = nil
	m.clearedteammate = false
}

// ClearWorkspace clears the "workspace" edge to the Workspace entity.
func (m *TaskLikeMutation) ClearWorkspace() {
	m.clearedworkspace = true
}

// WorkspaceCleared reports if the "workspace" edge to the Workspace entity was cleared.
func (m *TaskLikeMutation) WorkspaceCleared() bool {
	return m.clearedworkspace
}

// WorkspaceIDs returns the "workspace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkspaceID instead. It exists only for internal usage by the builders.
func (m *TaskLikeMutation) WorkspaceIDs() (ids []ulid.ID) {
	if id := m.workspace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkspace resets all changes to the "workspace" edge.
func (m *TaskLikeMutation) ResetWorkspace() {
	m.workspace = nil
	m.clearedworkspace = false
}

// Where appends a list predicates to the TaskLikeMutation builder.
func (m *TaskLikeMutation) Where(ps ...predicate.TaskLike) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskLikeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TaskLike).
func (m *TaskLikeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskLikeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.task != nil {
		fields = append(fields, tasklike.FieldTaskID)
	}
	if m.teammate != nil {
		fields = append(fields, tasklike.FieldTeammateID)
	}
	if m.workspace != nil {
		fields = append(fields, tasklike.FieldWorkspaceID)
	}
	if m.created_at != nil {
		fields = append(fields, tasklike.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tasklike.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskLikeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tasklike.FieldTaskID:
		return m.TaskID()
	case tasklike.FieldTeammateID:
		return m.TeammateID()
	case tasklike.FieldWorkspaceID:
		return m.WorkspaceID()
	case tasklike.FieldCreatedAt:
		return m.CreatedAt()
	case tasklike.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskLikeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tasklike.FieldTaskID:
		return m.OldTaskID(ctx)
	case tasklike.FieldTeammateID:
		return m.OldTeammateID(ctx)
	case tasklike.FieldWorkspaceID:
		return m.OldWorkspaceID(ctx)
	case tasklike.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tasklike.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TaskLike field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskLikeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tasklike.FieldTaskID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case tasklike.FieldTeammateID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeammateID(v)
		return nil
	case tasklike.FieldWorkspaceID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspaceID(v)
		return nil
	case tasklike.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tasklike.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TaskLike field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskLikeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskLikeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskLikeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskLike numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskLikeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskLikeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskLikeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TaskLike nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskLikeMutation) ResetField(name string) error {
	switch name {
	case tasklike.FieldTaskID:
		m.ResetTaskID()
		return nil
	case tasklike.FieldTeammateID:
		m.ResetTeammateID()
		return nil
	case tasklike.FieldWorkspaceID:
		m.ResetWorkspaceID()
		return nil
	case tasklike.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tasklike.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TaskLike field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskLikeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.task != nil {
		edges = append(edges, tasklike.EdgeTask)
	}
	if m.teammate != nil {
		edges = append(edges, tasklike.EdgeTeammate)
	}
	if m.workspace != nil {
		edges = append(edges, tasklike.EdgeWorkspace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskLikeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tasklike.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case tasklike.EdgeTeammate:
		if id := m.teammate; id != nil {
			return []ent.Value{*id}
		}
	case tasklike.EdgeWorkspace:
		if id := m.workspace; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskLikeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskLikeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskLikeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtask {
		edges = append(edges, tasklike.EdgeTask)
	}
	if m.clearedteammate {
		edges = append(edges, tasklike.EdgeTeammate)
	}
	if m.clearedworkspace {
		edges = append(edges, tasklike.EdgeWorkspace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskLikeMutation) EdgeCleared(name string) bool {
	switch name {
	case tasklike.EdgeTask:
		return m.clearedtask
	case tasklike.EdgeTeammate:
		return m.clearedteammate
	case tasklike.EdgeWorkspace:
		return m.clearedworkspace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskLikeMutation) ClearEdge(name string) error {
	switch name {
	case tasklike.EdgeTask:
		m.ClearTask()
		return nil
	case tasklike.EdgeTeammate:
		m.ClearTeammate()
		return nil
	case tasklike.EdgeWorkspace:
		m.ClearWorkspace()
		return nil
	}
	return fmt.Errorf("unknown TaskLike unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskLikeMutation) ResetEdge(name string) error {
	switch name {
	case tasklike.EdgeTask:
		m.ResetTask()
		return nil
	case tasklike.EdgeTeammate:
		m.ResetTeammate()
		return nil
	case tasklike.EdgeWorkspace:
		m.ResetWorkspace()
		return nil
	}
	return fmt.Errorf("unknown TaskLike edge %s", name)
}

// TaskListCompletedStatusMutation represents an operation that mutates the TaskListCompletedStatus nodes in the graph.
type TaskListCompletedStatusMutation struct {
	config
	op                              Op
	typ                             string
	id                              *ulid.ID
	name                            *string
	status_code                     *tasklistcompletedstatus.StatusCode
	created_at                      *time.Time
	updated_at                      *time.Time
	clearedFields                   map[string]struct{}
	teammateTaskListStatuses        map[ulid.ID]struct{}
	removedteammateTaskListStatuses map[ulid.ID]struct{}
	clearedteammateTaskListStatuses bool
	projectTaskListStatuses         map[ulid.ID]struct{}
	removedprojectTaskListStatuses  map[ulid.ID]struct{}
	clearedprojectTaskListStatuses  bool
	done                            bool
	oldValue                        func(context.Context) (*TaskListCompletedStatus, error)
	predicates                      []predicate.TaskListCompletedStatus
}

var _ ent.Mutation = (*TaskListCompletedStatusMutation)(nil)

// tasklistcompletedstatusOption allows management of the mutation configuration using functional options.
type tasklistcompletedstatusOption func(*TaskListCompletedStatusMutation)

// newTaskListCompletedStatusMutation creates new mutation for the TaskListCompletedStatus entity.
func newTaskListCompletedStatusMutation(c config, op Op, opts ...tasklistcompletedstatusOption) *TaskListCompletedStatusMutation {
	m := &TaskListCompletedStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskListCompletedStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskListCompletedStatusID sets the ID field of the mutation.
func withTaskListCompletedStatusID(id ulid.ID) tasklistcompletedstatusOption {
	return func(m *TaskListCompletedStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskListCompletedStatus
		)
		m.oldValue = func(ctx context.Context) (*TaskListCompletedStatus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskListCompletedStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskListCompletedStatus sets the old TaskListCompletedStatus of the mutation.
func withTaskListCompletedStatus(node *TaskListCompletedStatus) tasklistcompletedstatusOption {
	return func(m *TaskListCompletedStatusMutation) {
		m.oldValue = func(context.Context) (*TaskListCompletedStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskListCompletedStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskListCompletedStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskListCompletedStatus entities.
func (m *TaskListCompletedStatusMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskListCompletedStatusMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskListCompletedStatusMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskListCompletedStatus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TaskListCompletedStatusMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TaskListCompletedStatusMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TaskListCompletedStatus entity.
// If the TaskListCompletedStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskListCompletedStatusMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TaskListCompletedStatusMutation) ResetName() {
	m.name = nil
}

// SetStatusCode sets the "status_code" field.
func (m *TaskListCompletedStatusMutation) SetStatusCode(tc tasklistcompletedstatus.StatusCode) {
	m.status_code = &tc
}

// StatusCode returns the value of the "status_code" field in the mutation.
func (m *TaskListCompletedStatusMutation) StatusCode() (r tasklistcompletedstatus.StatusCode, exists bool) {
	v := m.status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusCode returns the old "status_code" field's value of the TaskListCompletedStatus entity.
// If the TaskListCompletedStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskListCompletedStatusMutation) OldStatusCode(ctx context.Context) (v tasklistcompletedstatus.StatusCode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusCode: %w", err)
	}
	return oldValue.StatusCode, nil
}

// ResetStatusCode resets all changes to the "status_code" field.
func (m *TaskListCompletedStatusMutation) ResetStatusCode() {
	m.status_code = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskListCompletedStatusMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskListCompletedStatusMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskListCompletedStatus entity.
// If the TaskListCompletedStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskListCompletedStatusMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskListCompletedStatusMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskListCompletedStatusMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskListCompletedStatusMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskListCompletedStatus entity.
// If the TaskListCompletedStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskListCompletedStatusMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskListCompletedStatusMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddTeammateTaskListStatuseIDs adds the "teammateTaskListStatuses" edge to the TeammateTaskListStatus entity by ids.
func (m *TaskListCompletedStatusMutation) AddTeammateTaskListStatuseIDs(ids ...ulid.ID) {
	if m.teammateTaskListStatuses == nil {
		m.teammateTaskListStatuses = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.teammateTaskListStatuses[ids[i]] = struct{}{}
	}
}

// ClearTeammateTaskListStatuses clears the "teammateTaskListStatuses" edge to the TeammateTaskListStatus entity.
func (m *TaskListCompletedStatusMutation) ClearTeammateTaskListStatuses() {
	m.clearedteammateTaskListStatuses = true
}

// TeammateTaskListStatusesCleared reports if the "teammateTaskListStatuses" edge to the TeammateTaskListStatus entity was cleared.
func (m *TaskListCompletedStatusMutation) TeammateTaskListStatusesCleared() bool {
	return m.clearedteammateTaskListStatuses
}

// RemoveTeammateTaskListStatuseIDs removes the "teammateTaskListStatuses" edge to the TeammateTaskListStatus entity by IDs.
func (m *TaskListCompletedStatusMutation) RemoveTeammateTaskListStatuseIDs(ids ...ulid.ID) {
	if m.removedteammateTaskListStatuses == nil {
		m.removedteammateTaskListStatuses = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.teammateTaskListStatuses, ids[i])
		m.removedteammateTaskListStatuses[ids[i]] = struct{}{}
	}
}

// RemovedTeammateTaskListStatuses returns the removed IDs of the "teammateTaskListStatuses" edge to the TeammateTaskListStatus entity.
func (m *TaskListCompletedStatusMutation) RemovedTeammateTaskListStatusesIDs() (ids []ulid.ID) {
	for id := range m.removedteammateTaskListStatuses {
		ids = append(ids, id)
	}
	return
}

// TeammateTaskListStatusesIDs returns the "teammateTaskListStatuses" edge IDs in the mutation.
func (m *TaskListCompletedStatusMutation) TeammateTaskListStatusesIDs() (ids []ulid.ID) {
	for id := range m.teammateTaskListStatuses {
		ids = append(ids, id)
	}
	return
}

// ResetTeammateTaskListStatuses resets all changes to the "teammateTaskListStatuses" edge.
func (m *TaskListCompletedStatusMutation) ResetTeammateTaskListStatuses() {
	m.teammateTaskListStatuses = nil
	m.clearedteammateTaskListStatuses = false
	m.removedteammateTaskListStatuses = nil
}

// AddProjectTaskListStatuseIDs adds the "projectTaskListStatuses" edge to the ProjectTaskListStatus entity by ids.
func (m *TaskListCompletedStatusMutation) AddProjectTaskListStatuseIDs(ids ...ulid.ID) {
	if m.projectTaskListStatuses == nil {
		m.projectTaskListStatuses = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.projectTaskListStatuses[ids[i]] = struct{}{}
	}
}

// ClearProjectTaskListStatuses clears the "projectTaskListStatuses" edge to the ProjectTaskListStatus entity.
func (m *TaskListCompletedStatusMutation) ClearProjectTaskListStatuses() {
	m.clearedprojectTaskListStatuses = true
}

// ProjectTaskListStatusesCleared reports if the "projectTaskListStatuses" edge to the ProjectTaskListStatus entity was cleared.
func (m *TaskListCompletedStatusMutation) ProjectTaskListStatusesCleared() bool {
	return m.clearedprojectTaskListStatuses
}

// RemoveProjectTaskListStatuseIDs removes the "projectTaskListStatuses" edge to the ProjectTaskListStatus entity by IDs.
func (m *TaskListCompletedStatusMutation) RemoveProjectTaskListStatuseIDs(ids ...ulid.ID) {
	if m.removedprojectTaskListStatuses == nil {
		m.removedprojectTaskListStatuses = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.projectTaskListStatuses, ids[i])
		m.removedprojectTaskListStatuses[ids[i]] = struct{}{}
	}
}

// RemovedProjectTaskListStatuses returns the removed IDs of the "projectTaskListStatuses" edge to the ProjectTaskListStatus entity.
func (m *TaskListCompletedStatusMutation) RemovedProjectTaskListStatusesIDs() (ids []ulid.ID) {
	for id := range m.removedprojectTaskListStatuses {
		ids = append(ids, id)
	}
	return
}

// ProjectTaskListStatusesIDs returns the "projectTaskListStatuses" edge IDs in the mutation.
func (m *TaskListCompletedStatusMutation) ProjectTaskListStatusesIDs() (ids []ulid.ID) {
	for id := range m.projectTaskListStatuses {
		ids = append(ids, id)
	}
	return
}

// ResetProjectTaskListStatuses resets all changes to the "projectTaskListStatuses" edge.
func (m *TaskListCompletedStatusMutation) ResetProjectTaskListStatuses() {
	m.projectTaskListStatuses = nil
	m.clearedprojectTaskListStatuses = false
	m.removedprojectTaskListStatuses = nil
}

// Where appends a list predicates to the TaskListCompletedStatusMutation builder.
func (m *TaskListCompletedStatusMutation) Where(ps ...predicate.TaskListCompletedStatus) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskListCompletedStatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TaskListCompletedStatus).
func (m *TaskListCompletedStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskListCompletedStatusMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, tasklistcompletedstatus.FieldName)
	}
	if m.status_code != nil {
		fields = append(fields, tasklistcompletedstatus.FieldStatusCode)
	}
	if m.created_at != nil {
		fields = append(fields, tasklistcompletedstatus.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tasklistcompletedstatus.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskListCompletedStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tasklistcompletedstatus.FieldName:
		return m.Name()
	case tasklistcompletedstatus.FieldStatusCode:
		return m.StatusCode()
	case tasklistcompletedstatus.FieldCreatedAt:
		return m.CreatedAt()
	case tasklistcompletedstatus.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskListCompletedStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tasklistcompletedstatus.FieldName:
		return m.OldName(ctx)
	case tasklistcompletedstatus.FieldStatusCode:
		return m.OldStatusCode(ctx)
	case tasklistcompletedstatus.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tasklistcompletedstatus.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TaskListCompletedStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskListCompletedStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tasklistcompletedstatus.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tasklistcompletedstatus.FieldStatusCode:
		v, ok := value.(tasklistcompletedstatus.StatusCode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusCode(v)
		return nil
	case tasklistcompletedstatus.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tasklistcompletedstatus.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TaskListCompletedStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskListCompletedStatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskListCompletedStatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskListCompletedStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskListCompletedStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskListCompletedStatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskListCompletedStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskListCompletedStatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TaskListCompletedStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskListCompletedStatusMutation) ResetField(name string) error {
	switch name {
	case tasklistcompletedstatus.FieldName:
		m.ResetName()
		return nil
	case tasklistcompletedstatus.FieldStatusCode:
		m.ResetStatusCode()
		return nil
	case tasklistcompletedstatus.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tasklistcompletedstatus.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TaskListCompletedStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskListCompletedStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.teammateTaskListStatuses != nil {
		edges = append(edges, tasklistcompletedstatus.EdgeTeammateTaskListStatuses)
	}
	if m.projectTaskListStatuses != nil {
		edges = append(edges, tasklistcompletedstatus.EdgeProjectTaskListStatuses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskListCompletedStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tasklistcompletedstatus.EdgeTeammateTaskListStatuses:
		ids := make([]ent.Value, 0, len(m.teammateTaskListStatuses))
		for id := range m.teammateTaskListStatuses {
			ids = append(ids, id)
		}
		return ids
	case tasklistcompletedstatus.EdgeProjectTaskListStatuses:
		ids := make([]ent.Value, 0, len(m.projectTaskListStatuses))
		for id := range m.projectTaskListStatuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskListCompletedStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedteammateTaskListStatuses != nil {
		edges = append(edges, tasklistcompletedstatus.EdgeTeammateTaskListStatuses)
	}
	if m.removedprojectTaskListStatuses != nil {
		edges = append(edges, tasklistcompletedstatus.EdgeProjectTaskListStatuses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskListCompletedStatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tasklistcompletedstatus.EdgeTeammateTaskListStatuses:
		ids := make([]ent.Value, 0, len(m.removedteammateTaskListStatuses))
		for id := range m.removedteammateTaskListStatuses {
			ids = append(ids, id)
		}
		return ids
	case tasklistcompletedstatus.EdgeProjectTaskListStatuses:
		ids := make([]ent.Value, 0, len(m.removedprojectTaskListStatuses))
		for id := range m.removedprojectTaskListStatuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskListCompletedStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedteammateTaskListStatuses {
		edges = append(edges, tasklistcompletedstatus.EdgeTeammateTaskListStatuses)
	}
	if m.clearedprojectTaskListStatuses {
		edges = append(edges, tasklistcompletedstatus.EdgeProjectTaskListStatuses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskListCompletedStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case tasklistcompletedstatus.EdgeTeammateTaskListStatuses:
		return m.clearedteammateTaskListStatuses
	case tasklistcompletedstatus.EdgeProjectTaskListStatuses:
		return m.clearedprojectTaskListStatuses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskListCompletedStatusMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskListCompletedStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskListCompletedStatusMutation) ResetEdge(name string) error {
	switch name {
	case tasklistcompletedstatus.EdgeTeammateTaskListStatuses:
		m.ResetTeammateTaskListStatuses()
		return nil
	case tasklistcompletedstatus.EdgeProjectTaskListStatuses:
		m.ResetProjectTaskListStatuses()
		return nil
	}
	return fmt.Errorf("unknown TaskListCompletedStatus edge %s", name)
}

// TaskListSortStatusMutation represents an operation that mutates the TaskListSortStatus nodes in the graph.
type TaskListSortStatusMutation struct {
	config
	op                              Op
	typ                             string
	id                              *ulid.ID
	name                            *string
	status_code                     *tasklistsortstatus.StatusCode
	created_at                      *time.Time
	updated_at                      *time.Time
	clearedFields                   map[string]struct{}
	teammateTaskListStatuses        map[ulid.ID]struct{}
	removedteammateTaskListStatuses map[ulid.ID]struct{}
	clearedteammateTaskListStatuses bool
	projectTaskListStatuses         map[ulid.ID]struct{}
	removedprojectTaskListStatuses  map[ulid.ID]struct{}
	clearedprojectTaskListStatuses  bool
	done                            bool
	oldValue                        func(context.Context) (*TaskListSortStatus, error)
	predicates                      []predicate.TaskListSortStatus
}

var _ ent.Mutation = (*TaskListSortStatusMutation)(nil)

// tasklistsortstatusOption allows management of the mutation configuration using functional options.
type tasklistsortstatusOption func(*TaskListSortStatusMutation)

// newTaskListSortStatusMutation creates new mutation for the TaskListSortStatus entity.
func newTaskListSortStatusMutation(c config, op Op, opts ...tasklistsortstatusOption) *TaskListSortStatusMutation {
	m := &TaskListSortStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskListSortStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskListSortStatusID sets the ID field of the mutation.
func withTaskListSortStatusID(id ulid.ID) tasklistsortstatusOption {
	return func(m *TaskListSortStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskListSortStatus
		)
		m.oldValue = func(ctx context.Context) (*TaskListSortStatus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskListSortStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskListSortStatus sets the old TaskListSortStatus of the mutation.
func withTaskListSortStatus(node *TaskListSortStatus) tasklistsortstatusOption {
	return func(m *TaskListSortStatusMutation) {
		m.oldValue = func(context.Context) (*TaskListSortStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskListSortStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskListSortStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskListSortStatus entities.
func (m *TaskListSortStatusMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskListSortStatusMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskListSortStatusMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskListSortStatus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TaskListSortStatusMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TaskListSortStatusMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TaskListSortStatus entity.
// If the TaskListSortStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskListSortStatusMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TaskListSortStatusMutation) ResetName() {
	m.name = nil
}

// SetStatusCode sets the "status_code" field.
func (m *TaskListSortStatusMutation) SetStatusCode(tc tasklistsortstatus.StatusCode) {
	m.status_code = &tc
}

// StatusCode returns the value of the "status_code" field in the mutation.
func (m *TaskListSortStatusMutation) StatusCode() (r tasklistsortstatus.StatusCode, exists bool) {
	v := m.status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusCode returns the old "status_code" field's value of the TaskListSortStatus entity.
// If the TaskListSortStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskListSortStatusMutation) OldStatusCode(ctx context.Context) (v tasklistsortstatus.StatusCode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusCode: %w", err)
	}
	return oldValue.StatusCode, nil
}

// ResetStatusCode resets all changes to the "status_code" field.
func (m *TaskListSortStatusMutation) ResetStatusCode() {
	m.status_code = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskListSortStatusMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskListSortStatusMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskListSortStatus entity.
// If the TaskListSortStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskListSortStatusMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskListSortStatusMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskListSortStatusMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskListSortStatusMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskListSortStatus entity.
// If the TaskListSortStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskListSortStatusMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskListSortStatusMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddTeammateTaskListStatuseIDs adds the "teammateTaskListStatuses" edge to the TeammateTaskListStatus entity by ids.
func (m *TaskListSortStatusMutation) AddTeammateTaskListStatuseIDs(ids ...ulid.ID) {
	if m.teammateTaskListStatuses == nil {
		m.teammateTaskListStatuses = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.teammateTaskListStatuses[ids[i]] = struct{}{}
	}
}

// ClearTeammateTaskListStatuses clears the "teammateTaskListStatuses" edge to the TeammateTaskListStatus entity.
func (m *TaskListSortStatusMutation) ClearTeammateTaskListStatuses() {
	m.clearedteammateTaskListStatuses = true
}

// TeammateTaskListStatusesCleared reports if the "teammateTaskListStatuses" edge to the TeammateTaskListStatus entity was cleared.
func (m *TaskListSortStatusMutation) TeammateTaskListStatusesCleared() bool {
	return m.clearedteammateTaskListStatuses
}

// RemoveTeammateTaskListStatuseIDs removes the "teammateTaskListStatuses" edge to the TeammateTaskListStatus entity by IDs.
func (m *TaskListSortStatusMutation) RemoveTeammateTaskListStatuseIDs(ids ...ulid.ID) {
	if m.removedteammateTaskListStatuses == nil {
		m.removedteammateTaskListStatuses = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.teammateTaskListStatuses, ids[i])
		m.removedteammateTaskListStatuses[ids[i]] = struct{}{}
	}
}

// RemovedTeammateTaskListStatuses returns the removed IDs of the "teammateTaskListStatuses" edge to the TeammateTaskListStatus entity.
func (m *TaskListSortStatusMutation) RemovedTeammateTaskListStatusesIDs() (ids []ulid.ID) {
	for id := range m.removedteammateTaskListStatuses {
		ids = append(ids, id)
	}
	return
}

// TeammateTaskListStatusesIDs returns the "teammateTaskListStatuses" edge IDs in the mutation.
func (m *TaskListSortStatusMutation) TeammateTaskListStatusesIDs() (ids []ulid.ID) {
	for id := range m.teammateTaskListStatuses {
		ids = append(ids, id)
	}
	return
}

// ResetTeammateTaskListStatuses resets all changes to the "teammateTaskListStatuses" edge.
func (m *TaskListSortStatusMutation) ResetTeammateTaskListStatuses() {
	m.teammateTaskListStatuses = nil
	m.clearedteammateTaskListStatuses = false
	m.removedteammateTaskListStatuses = nil
}

// AddProjectTaskListStatuseIDs adds the "projectTaskListStatuses" edge to the ProjectTaskListStatus entity by ids.
func (m *TaskListSortStatusMutation) AddProjectTaskListStatuseIDs(ids ...ulid.ID) {
	if m.projectTaskListStatuses == nil {
		m.projectTaskListStatuses = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.projectTaskListStatuses[ids[i]] = struct{}{}
	}
}

// ClearProjectTaskListStatuses clears the "projectTaskListStatuses" edge to the ProjectTaskListStatus entity.
func (m *TaskListSortStatusMutation) ClearProjectTaskListStatuses() {
	m.clearedprojectTaskListStatuses = true
}

// ProjectTaskListStatusesCleared reports if the "projectTaskListStatuses" edge to the ProjectTaskListStatus entity was cleared.
func (m *TaskListSortStatusMutation) ProjectTaskListStatusesCleared() bool {
	return m.clearedprojectTaskListStatuses
}

// RemoveProjectTaskListStatuseIDs removes the "projectTaskListStatuses" edge to the ProjectTaskListStatus entity by IDs.
func (m *TaskListSortStatusMutation) RemoveProjectTaskListStatuseIDs(ids ...ulid.ID) {
	if m.removedprojectTaskListStatuses == nil {
		m.removedprojectTaskListStatuses = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.projectTaskListStatuses, ids[i])
		m.removedprojectTaskListStatuses[ids[i]] = struct{}{}
	}
}

// RemovedProjectTaskListStatuses returns the removed IDs of the "projectTaskListStatuses" edge to the ProjectTaskListStatus entity.
func (m *TaskListSortStatusMutation) RemovedProjectTaskListStatusesIDs() (ids []ulid.ID) {
	for id := range m.removedprojectTaskListStatuses {
		ids = append(ids, id)
	}
	return
}

// ProjectTaskListStatusesIDs returns the "projectTaskListStatuses" edge IDs in the mutation.
func (m *TaskListSortStatusMutation) ProjectTaskListStatusesIDs() (ids []ulid.ID) {
	for id := range m.projectTaskListStatuses {
		ids = append(ids, id)
	}
	return
}

// ResetProjectTaskListStatuses resets all changes to the "projectTaskListStatuses" edge.
func (m *TaskListSortStatusMutation) ResetProjectTaskListStatuses() {
	m.projectTaskListStatuses = nil
	m.clearedprojectTaskListStatuses = false
	m.removedprojectTaskListStatuses = nil
}

// Where appends a list predicates to the TaskListSortStatusMutation builder.
func (m *TaskListSortStatusMutation) Where(ps ...predicate.TaskListSortStatus) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskListSortStatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TaskListSortStatus).
func (m *TaskListSortStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskListSortStatusMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, tasklistsortstatus.FieldName)
	}
	if m.status_code != nil {
		fields = append(fields, tasklistsortstatus.FieldStatusCode)
	}
	if m.created_at != nil {
		fields = append(fields, tasklistsortstatus.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tasklistsortstatus.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskListSortStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tasklistsortstatus.FieldName:
		return m.Name()
	case tasklistsortstatus.FieldStatusCode:
		return m.StatusCode()
	case tasklistsortstatus.FieldCreatedAt:
		return m.CreatedAt()
	case tasklistsortstatus.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskListSortStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tasklistsortstatus.FieldName:
		return m.OldName(ctx)
	case tasklistsortstatus.FieldStatusCode:
		return m.OldStatusCode(ctx)
	case tasklistsortstatus.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tasklistsortstatus.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TaskListSortStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskListSortStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tasklistsortstatus.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tasklistsortstatus.FieldStatusCode:
		v, ok := value.(tasklistsortstatus.StatusCode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusCode(v)
		return nil
	case tasklistsortstatus.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tasklistsortstatus.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TaskListSortStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskListSortStatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskListSortStatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskListSortStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskListSortStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskListSortStatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskListSortStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskListSortStatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TaskListSortStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskListSortStatusMutation) ResetField(name string) error {
	switch name {
	case tasklistsortstatus.FieldName:
		m.ResetName()
		return nil
	case tasklistsortstatus.FieldStatusCode:
		m.ResetStatusCode()
		return nil
	case tasklistsortstatus.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tasklistsortstatus.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TaskListSortStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskListSortStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.teammateTaskListStatuses != nil {
		edges = append(edges, tasklistsortstatus.EdgeTeammateTaskListStatuses)
	}
	if m.projectTaskListStatuses != nil {
		edges = append(edges, tasklistsortstatus.EdgeProjectTaskListStatuses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskListSortStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tasklistsortstatus.EdgeTeammateTaskListStatuses:
		ids := make([]ent.Value, 0, len(m.teammateTaskListStatuses))
		for id := range m.teammateTaskListStatuses {
			ids = append(ids, id)
		}
		return ids
	case tasklistsortstatus.EdgeProjectTaskListStatuses:
		ids := make([]ent.Value, 0, len(m.projectTaskListStatuses))
		for id := range m.projectTaskListStatuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskListSortStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedteammateTaskListStatuses != nil {
		edges = append(edges, tasklistsortstatus.EdgeTeammateTaskListStatuses)
	}
	if m.removedprojectTaskListStatuses != nil {
		edges = append(edges, tasklistsortstatus.EdgeProjectTaskListStatuses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskListSortStatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tasklistsortstatus.EdgeTeammateTaskListStatuses:
		ids := make([]ent.Value, 0, len(m.removedteammateTaskListStatuses))
		for id := range m.removedteammateTaskListStatuses {
			ids = append(ids, id)
		}
		return ids
	case tasklistsortstatus.EdgeProjectTaskListStatuses:
		ids := make([]ent.Value, 0, len(m.removedprojectTaskListStatuses))
		for id := range m.removedprojectTaskListStatuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskListSortStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedteammateTaskListStatuses {
		edges = append(edges, tasklistsortstatus.EdgeTeammateTaskListStatuses)
	}
	if m.clearedprojectTaskListStatuses {
		edges = append(edges, tasklistsortstatus.EdgeProjectTaskListStatuses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskListSortStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case tasklistsortstatus.EdgeTeammateTaskListStatuses:
		return m.clearedteammateTaskListStatuses
	case tasklistsortstatus.EdgeProjectTaskListStatuses:
		return m.clearedprojectTaskListStatuses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskListSortStatusMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskListSortStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskListSortStatusMutation) ResetEdge(name string) error {
	switch name {
	case tasklistsortstatus.EdgeTeammateTaskListStatuses:
		m.ResetTeammateTaskListStatuses()
		return nil
	case tasklistsortstatus.EdgeProjectTaskListStatuses:
		m.ResetProjectTaskListStatuses()
		return nil
	}
	return fmt.Errorf("unknown TaskListSortStatus edge %s", name)
}

// TaskPriorityMutation represents an operation that mutates the TaskPriority nodes in the graph.
type TaskPriorityMutation struct {
	config
	op            Op
	typ           string
	id            *ulid.ID
	name          *string
	priority_type *taskpriority.PriorityType
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	color         *ulid.ID
	clearedcolor  bool
	tasks         map[ulid.ID]struct{}
	removedtasks  map[ulid.ID]struct{}
	clearedtasks  bool
	done          bool
	oldValue      func(context.Context) (*TaskPriority, error)
	predicates    []predicate.TaskPriority
}

var _ ent.Mutation = (*TaskPriorityMutation)(nil)

// taskpriorityOption allows management of the mutation configuration using functional options.
type taskpriorityOption func(*TaskPriorityMutation)

// newTaskPriorityMutation creates new mutation for the TaskPriority entity.
func newTaskPriorityMutation(c config, op Op, opts ...taskpriorityOption) *TaskPriorityMutation {
	m := &TaskPriorityMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskPriority,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskPriorityID sets the ID field of the mutation.
func withTaskPriorityID(id ulid.ID) taskpriorityOption {
	return func(m *TaskPriorityMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskPriority
		)
		m.oldValue = func(ctx context.Context) (*TaskPriority, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskPriority.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskPriority sets the old TaskPriority of the mutation.
func withTaskPriority(node *TaskPriority) taskpriorityOption {
	return func(m *TaskPriorityMutation) {
		m.oldValue = func(context.Context) (*TaskPriority, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskPriorityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskPriorityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskPriority entities.
func (m *TaskPriorityMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskPriorityMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskPriorityMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskPriority.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetColorID sets the "color_id" field.
func (m *TaskPriorityMutation) SetColorID(u ulid.ID) {
	m.color = &u
}

// ColorID returns the value of the "color_id" field in the mutation.
func (m *TaskPriorityMutation) ColorID() (r ulid.ID, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColorID returns the old "color_id" field's value of the TaskPriority entity.
// If the TaskPriority object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskPriorityMutation) OldColorID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColorID: %w", err)
	}
	return oldValue.ColorID, nil
}

// ResetColorID resets all changes to the "color_id" field.
func (m *TaskPriorityMutation) ResetColorID() {
	m.color = nil
}

// SetName sets the "name" field.
func (m *TaskPriorityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TaskPriorityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TaskPriority entity.
// If the TaskPriority object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskPriorityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TaskPriorityMutation) ResetName() {
	m.name = nil
}

// SetPriorityType sets the "priority_type" field.
func (m *TaskPriorityMutation) SetPriorityType(tt taskpriority.PriorityType) {
	m.priority_type = &tt
}

// PriorityType returns the value of the "priority_type" field in the mutation.
func (m *TaskPriorityMutation) PriorityType() (r taskpriority.PriorityType, exists bool) {
	v := m.priority_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPriorityType returns the old "priority_type" field's value of the TaskPriority entity.
// If the TaskPriority object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskPriorityMutation) OldPriorityType(ctx context.Context) (v taskpriority.PriorityType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriorityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriorityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriorityType: %w", err)
	}
	return oldValue.PriorityType, nil
}

// ResetPriorityType resets all changes to the "priority_type" field.
func (m *TaskPriorityMutation) ResetPriorityType() {
	m.priority_type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskPriorityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskPriorityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskPriority entity.
// If the TaskPriority object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskPriorityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskPriorityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskPriorityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskPriorityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskPriority entity.
// If the TaskPriority object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskPriorityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskPriorityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearColor clears the "color" edge to the Color entity.
func (m *TaskPriorityMutation) ClearColor() {
	m.clearedcolor = true
}

// ColorCleared reports if the "color" edge to the Color entity was cleared.
func (m *TaskPriorityMutation) ColorCleared() bool {
	return m.clearedcolor
}

// ColorIDs returns the "color" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ColorID instead. It exists only for internal usage by the builders.
func (m *TaskPriorityMutation) ColorIDs() (ids []ulid.ID) {
	if id := m.color; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetColor resets all changes to the "color" edge.
func (m *TaskPriorityMutation) ResetColor() {
	m.color = nil
	m.clearedcolor = false
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *TaskPriorityMutation) AddTaskIDs(ids ...ulid.ID) {
	if m.tasks == nil {
		m.tasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *TaskPriorityMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *TaskPriorityMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *TaskPriorityMutation) RemoveTaskIDs(ids ...ulid.ID) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *TaskPriorityMutation) RemovedTasksIDs() (ids []ulid.ID) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *TaskPriorityMutation) TasksIDs() (ids []ulid.ID) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *TaskPriorityMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// Where appends a list predicates to the TaskPriorityMutation builder.
func (m *TaskPriorityMutation) Where(ps ...predicate.TaskPriority) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskPriorityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TaskPriority).
func (m *TaskPriorityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskPriorityMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.color != nil {
		fields = append(fields, taskpriority.FieldColorID)
	}
	if m.name != nil {
		fields = append(fields, taskpriority.FieldName)
	}
	if m.priority_type != nil {
		fields = append(fields, taskpriority.FieldPriorityType)
	}
	if m.created_at != nil {
		fields = append(fields, taskpriority.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, taskpriority.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskPriorityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case taskpriority.FieldColorID:
		return m.ColorID()
	case taskpriority.FieldName:
		return m.Name()
	case taskpriority.FieldPriorityType:
		return m.PriorityType()
	case taskpriority.FieldCreatedAt:
		return m.CreatedAt()
	case taskpriority.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskPriorityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case taskpriority.FieldColorID:
		return m.OldColorID(ctx)
	case taskpriority.FieldName:
		return m.OldName(ctx)
	case taskpriority.FieldPriorityType:
		return m.OldPriorityType(ctx)
	case taskpriority.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case taskpriority.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TaskPriority field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskPriorityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case taskpriority.FieldColorID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColorID(v)
		return nil
	case taskpriority.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case taskpriority.FieldPriorityType:
		v, ok := value.(taskpriority.PriorityType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriorityType(v)
		return nil
	case taskpriority.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case taskpriority.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TaskPriority field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskPriorityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskPriorityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskPriorityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskPriority numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskPriorityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskPriorityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskPriorityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TaskPriority nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskPriorityMutation) ResetField(name string) error {
	switch name {
	case taskpriority.FieldColorID:
		m.ResetColorID()
		return nil
	case taskpriority.FieldName:
		m.ResetName()
		return nil
	case taskpriority.FieldPriorityType:
		m.ResetPriorityType()
		return nil
	case taskpriority.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case taskpriority.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TaskPriority field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskPriorityMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.color != nil {
		edges = append(edges, taskpriority.EdgeColor)
	}
	if m.tasks != nil {
		edges = append(edges, taskpriority.EdgeTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskPriorityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case taskpriority.EdgeColor:
		if id := m.color; id != nil {
			return []ent.Value{*id}
		}
	case taskpriority.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskPriorityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtasks != nil {
		edges = append(edges, taskpriority.EdgeTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskPriorityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case taskpriority.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskPriorityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcolor {
		edges = append(edges, taskpriority.EdgeColor)
	}
	if m.clearedtasks {
		edges = append(edges, taskpriority.EdgeTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskPriorityMutation) EdgeCleared(name string) bool {
	switch name {
	case taskpriority.EdgeColor:
		return m.clearedcolor
	case taskpriority.EdgeTasks:
		return m.clearedtasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskPriorityMutation) ClearEdge(name string) error {
	switch name {
	case taskpriority.EdgeColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown TaskPriority unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskPriorityMutation) ResetEdge(name string) error {
	switch name {
	case taskpriority.EdgeColor:
		m.ResetColor()
		return nil
	case taskpriority.EdgeTasks:
		m.ResetTasks()
		return nil
	}
	return fmt.Errorf("unknown TaskPriority edge %s", name)
}

// TaskSectionMutation represents an operation that mutates the TaskSection nodes in the graph.
type TaskSectionMutation struct {
	config
	op            Op
	typ           string
	id            *ulid.ID
	name          *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*TaskSection, error)
	predicates    []predicate.TaskSection
}

var _ ent.Mutation = (*TaskSectionMutation)(nil)

// tasksectionOption allows management of the mutation configuration using functional options.
type tasksectionOption func(*TaskSectionMutation)

// newTaskSectionMutation creates new mutation for the TaskSection entity.
func newTaskSectionMutation(c config, op Op, opts ...tasksectionOption) *TaskSectionMutation {
	m := &TaskSectionMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskSection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskSectionID sets the ID field of the mutation.
func withTaskSectionID(id ulid.ID) tasksectionOption {
	return func(m *TaskSectionMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskSection
		)
		m.oldValue = func(ctx context.Context) (*TaskSection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskSection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskSection sets the old TaskSection of the mutation.
func withTaskSection(node *TaskSection) tasksectionOption {
	return func(m *TaskSectionMutation) {
		m.oldValue = func(context.Context) (*TaskSection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskSectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskSectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskSection entities.
func (m *TaskSectionMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskSectionMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskSectionMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskSection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TaskSectionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TaskSectionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TaskSection entity.
// If the TaskSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskSectionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TaskSectionMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskSectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskSectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskSection entity.
// If the TaskSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskSectionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskSectionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskSectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskSectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskSection entity.
// If the TaskSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskSectionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskSectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the TaskSectionMutation builder.
func (m *TaskSectionMutation) Where(ps ...predicate.TaskSection) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskSectionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TaskSection).
func (m *TaskSectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskSectionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, tasksection.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, tasksection.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tasksection.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskSectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tasksection.FieldName:
		return m.Name()
	case tasksection.FieldCreatedAt:
		return m.CreatedAt()
	case tasksection.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskSectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tasksection.FieldName:
		return m.OldName(ctx)
	case tasksection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tasksection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TaskSection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskSectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tasksection.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tasksection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tasksection.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TaskSection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskSectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskSectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskSectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskSection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskSectionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskSectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskSectionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TaskSection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskSectionMutation) ResetField(name string) error {
	switch name {
	case tasksection.FieldName:
		m.ResetName()
		return nil
	case tasksection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tasksection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TaskSection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskSectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskSectionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskSectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskSectionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskSectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskSectionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskSectionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TaskSection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskSectionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TaskSection edge %s", name)
}

// TaskTagMutation represents an operation that mutates the TaskTag nodes in the graph.
type TaskTagMutation struct {
	config
	op            Op
	typ           string
	id            *ulid.ID
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	task          *ulid.ID
	clearedtask   bool
	tag           *ulid.ID
	clearedtag    bool
	done          bool
	oldValue      func(context.Context) (*TaskTag, error)
	predicates    []predicate.TaskTag
}

var _ ent.Mutation = (*TaskTagMutation)(nil)

// tasktagOption allows management of the mutation configuration using functional options.
type tasktagOption func(*TaskTagMutation)

// newTaskTagMutation creates new mutation for the TaskTag entity.
func newTaskTagMutation(c config, op Op, opts ...tasktagOption) *TaskTagMutation {
	m := &TaskTagMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskTagID sets the ID field of the mutation.
func withTaskTagID(id ulid.ID) tasktagOption {
	return func(m *TaskTagMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskTag
		)
		m.oldValue = func(ctx context.Context) (*TaskTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskTag sets the old TaskTag of the mutation.
func withTaskTag(node *TaskTag) tasktagOption {
	return func(m *TaskTagMutation) {
		m.oldValue = func(context.Context) (*TaskTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskTag entities.
func (m *TaskTagMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskTagMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskTagMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTaskID sets the "task_id" field.
func (m *TaskTagMutation) SetTaskID(u ulid.ID) {
	m.task = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *TaskTagMutation) TaskID() (r ulid.ID, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the TaskTag entity.
// If the TaskTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskTagMutation) OldTaskID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *TaskTagMutation) ResetTaskID() {
	m.task = nil
}

// SetTagID sets the "tag_id" field.
func (m *TaskTagMutation) SetTagID(u ulid.ID) {
	m.tag = &u
}

// TagID returns the value of the "tag_id" field in the mutation.
func (m *TaskTagMutation) TagID() (r ulid.ID, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTagID returns the old "tag_id" field's value of the TaskTag entity.
// If the TaskTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskTagMutation) OldTagID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagID: %w", err)
	}
	return oldValue.TagID, nil
}

// ResetTagID resets all changes to the "tag_id" field.
func (m *TaskTagMutation) ResetTagID() {
	m.tag = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskTagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskTag entity.
// If the TaskTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskTagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskTagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskTagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskTagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskTag entity.
// If the TaskTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskTagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskTagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTask clears the "task" edge to the Task entity.
func (m *TaskTagMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *TaskTagMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *TaskTagMutation) TaskIDs() (ids []ulid.ID) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *TaskTagMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// ClearTag clears the "tag" edge to the Tag entity.
func (m *TaskTagMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared reports if the "tag" edge to the Tag entity was cleared.
func (m *TaskTagMutation) TagCleared() bool {
	return m.clearedtag
}

// TagIDs returns the "tag" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TagID instead. It exists only for internal usage by the builders.
func (m *TaskTagMutation) TagIDs() (ids []ulid.ID) {
	if id := m.tag; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *TaskTagMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
}

// Where appends a list predicates to the TaskTagMutation builder.
func (m *TaskTagMutation) Where(ps ...predicate.TaskTag) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskTagMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TaskTag).
func (m *TaskTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskTagMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.task != nil {
		fields = append(fields, tasktag.FieldTaskID)
	}
	if m.tag != nil {
		fields = append(fields, tasktag.FieldTagID)
	}
	if m.created_at != nil {
		fields = append(fields, tasktag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tasktag.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tasktag.FieldTaskID:
		return m.TaskID()
	case tasktag.FieldTagID:
		return m.TagID()
	case tasktag.FieldCreatedAt:
		return m.CreatedAt()
	case tasktag.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tasktag.FieldTaskID:
		return m.OldTaskID(ctx)
	case tasktag.FieldTagID:
		return m.OldTagID(ctx)
	case tasktag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tasktag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TaskTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tasktag.FieldTaskID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case tasktag.FieldTagID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagID(v)
		return nil
	case tasktag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tasktag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TaskTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskTagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskTagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TaskTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskTagMutation) ResetField(name string) error {
	switch name {
	case tasktag.FieldTaskID:
		m.ResetTaskID()
		return nil
	case tasktag.FieldTagID:
		m.ResetTagID()
		return nil
	case tasktag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tasktag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TaskTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.task != nil {
		edges = append(edges, tasktag.EdgeTask)
	}
	if m.tag != nil {
		edges = append(edges, tasktag.EdgeTag)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tasktag.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case tasktag.EdgeTag:
		if id := m.tag; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtask {
		edges = append(edges, tasktag.EdgeTask)
	}
	if m.clearedtag {
		edges = append(edges, tasktag.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskTagMutation) EdgeCleared(name string) bool {
	switch name {
	case tasktag.EdgeTask:
		return m.clearedtask
	case tasktag.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskTagMutation) ClearEdge(name string) error {
	switch name {
	case tasktag.EdgeTask:
		m.ClearTask()
		return nil
	case tasktag.EdgeTag:
		m.ClearTag()
		return nil
	}
	return fmt.Errorf("unknown TaskTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskTagMutation) ResetEdge(name string) error {
	switch name {
	case tasktag.EdgeTask:
		m.ResetTask()
		return nil
	case tasktag.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown TaskTag edge %s", name)
}

// TeammateMutation represents an operation that mutates the Teammate nodes in the graph.
type TeammateMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *ulid.ID
	name                               *string
	image                              *string
	email                              *string
	created_at                         *time.Time
	updated_at                         *time.Time
	clearedFields                      map[string]struct{}
	workspaces                         map[ulid.ID]struct{}
	removedworkspaces                  map[ulid.ID]struct{}
	clearedworkspaces                  bool
	projects                           map[ulid.ID]struct{}
	removedprojects                    map[ulid.ID]struct{}
	clearedprojects                    bool
	projectTeammates                   map[ulid.ID]struct{}
	removedprojectTeammates            map[ulid.ID]struct{}
	clearedprojectTeammates            bool
	workspaceTeammates                 map[ulid.ID]struct{}
	removedworkspaceTeammates          map[ulid.ID]struct{}
	clearedworkspaceTeammates          bool
	favoriteProjects                   map[ulid.ID]struct{}
	removedfavoriteProjects            map[ulid.ID]struct{}
	clearedfavoriteProjects            bool
	favoriteWorkspaces                 map[ulid.ID]struct{}
	removedfavoriteWorkspaces          map[ulid.ID]struct{}
	clearedfavoriteWorkspaces          bool
	teammateTaskTabStatuses            map[ulid.ID]struct{}
	removedteammateTaskTabStatuses     map[ulid.ID]struct{}
	clearedteammateTaskTabStatuses     bool
	teammateTaskColumns                map[ulid.ID]struct{}
	removedteammateTaskColumns         map[ulid.ID]struct{}
	clearedteammateTaskColumns         bool
	teammateTaskListStatuses           map[ulid.ID]struct{}
	removedteammateTaskListStatuses    map[ulid.ID]struct{}
	clearedteammateTaskListStatuses    bool
	teammateTaskSections               map[ulid.ID]struct{}
	removedteammateTaskSections        map[ulid.ID]struct{}
	clearedteammateTaskSections        bool
	tasks                              map[ulid.ID]struct{}
	removedtasks                       map[ulid.ID]struct{}
	clearedtasks                       bool
	teammateTasks                      map[ulid.ID]struct{}
	removedteammateTasks               map[ulid.ID]struct{}
	clearedteammateTasks               bool
	taskLikes                          map[ulid.ID]struct{}
	removedtaskLikes                   map[ulid.ID]struct{}
	clearedtaskLikes                   bool
	taskCollaborators                  map[ulid.ID]struct{}
	removedtaskCollaborators           map[ulid.ID]struct{}
	clearedtaskCollaborators           bool
	taskFeeds                          map[ulid.ID]struct{}
	removedtaskFeeds                   map[ulid.ID]struct{}
	clearedtaskFeeds                   bool
	taskFeedLikes                      map[ulid.ID]struct{}
	removedtaskFeedLikes               map[ulid.ID]struct{}
	clearedtaskFeedLikes               bool
	taskActivities                     map[ulid.ID]struct{}
	removedtaskActivities              map[ulid.ID]struct{}
	clearedtaskActivities              bool
	workspaceActivities                map[ulid.ID]struct{}
	removedworkspaceActivities         map[ulid.ID]struct{}
	clearedworkspaceActivities         bool
	archivedTaskActivities             map[ulid.ID]struct{}
	removedarchivedTaskActivities      map[ulid.ID]struct{}
	clearedarchivedTaskActivities      bool
	archivedWorkspaceActivities        map[ulid.ID]struct{}
	removedarchivedWorkspaceActivities map[ulid.ID]struct{}
	clearedarchivedWorkspaceActivities bool
	done                               bool
	oldValue                           func(context.Context) (*Teammate, error)
	predicates                         []predicate.Teammate
}

var _ ent.Mutation = (*TeammateMutation)(nil)

// teammateOption allows management of the mutation configuration using functional options.
type teammateOption func(*TeammateMutation)

// newTeammateMutation creates new mutation for the Teammate entity.
func newTeammateMutation(c config, op Op, opts ...teammateOption) *TeammateMutation {
	m := &TeammateMutation{
		config:        c,
		op:            op,
		typ:           TypeTeammate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeammateID sets the ID field of the mutation.
func withTeammateID(id ulid.ID) teammateOption {
	return func(m *TeammateMutation) {
		var (
			err   error
			once  sync.Once
			value *Teammate
		)
		m.oldValue = func(ctx context.Context) (*Teammate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Teammate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeammate sets the old Teammate of the mutation.
func withTeammate(node *Teammate) teammateOption {
	return func(m *TeammateMutation) {
		m.oldValue = func(context.Context) (*Teammate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeammateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeammateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Teammate entities.
func (m *TeammateMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeammateMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeammateMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Teammate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TeammateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeammateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Teammate entity.
// If the Teammate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeammateMutation) ResetName() {
	m.name = nil
}

// SetImage sets the "image" field.
func (m *TeammateMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *TeammateMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Teammate entity.
// If the Teammate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *TeammateMutation) ResetImage() {
	m.image = nil
}

// SetEmail sets the "email" field.
func (m *TeammateMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *TeammateMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Teammate entity.
// If the Teammate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *TeammateMutation) ResetEmail() {
	m.email = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TeammateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeammateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Teammate entity.
// If the Teammate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeammateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeammateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeammateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Teammate entity.
// If the Teammate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeammateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddWorkspaceIDs adds the "workspaces" edge to the Workspace entity by ids.
func (m *TeammateMutation) AddWorkspaceIDs(ids ...ulid.ID) {
	if m.workspaces == nil {
		m.workspaces = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.workspaces[ids[i]] = struct{}{}
	}
}

// ClearWorkspaces clears the "workspaces" edge to the Workspace entity.
func (m *TeammateMutation) ClearWorkspaces() {
	m.clearedworkspaces = true
}

// WorkspacesCleared reports if the "workspaces" edge to the Workspace entity was cleared.
func (m *TeammateMutation) WorkspacesCleared() bool {
	return m.clearedworkspaces
}

// RemoveWorkspaceIDs removes the "workspaces" edge to the Workspace entity by IDs.
func (m *TeammateMutation) RemoveWorkspaceIDs(ids ...ulid.ID) {
	if m.removedworkspaces == nil {
		m.removedworkspaces = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.workspaces, ids[i])
		m.removedworkspaces[ids[i]] = struct{}{}
	}
}

// RemovedWorkspaces returns the removed IDs of the "workspaces" edge to the Workspace entity.
func (m *TeammateMutation) RemovedWorkspacesIDs() (ids []ulid.ID) {
	for id := range m.removedworkspaces {
		ids = append(ids, id)
	}
	return
}

// WorkspacesIDs returns the "workspaces" edge IDs in the mutation.
func (m *TeammateMutation) WorkspacesIDs() (ids []ulid.ID) {
	for id := range m.workspaces {
		ids = append(ids, id)
	}
	return
}

// ResetWorkspaces resets all changes to the "workspaces" edge.
func (m *TeammateMutation) ResetWorkspaces() {
	m.workspaces = nil
	m.clearedworkspaces = false
	m.removedworkspaces = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *TeammateMutation) AddProjectIDs(ids ...ulid.ID) {
	if m.projects == nil {
		m.projects = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *TeammateMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *TeammateMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *TeammateMutation) RemoveProjectIDs(ids ...ulid.ID) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *TeammateMutation) RemovedProjectsIDs() (ids []ulid.ID) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *TeammateMutation) ProjectsIDs() (ids []ulid.ID) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *TeammateMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddProjectTeammateIDs adds the "projectTeammates" edge to the ProjectTeammate entity by ids.
func (m *TeammateMutation) AddProjectTeammateIDs(ids ...ulid.ID) {
	if m.projectTeammates == nil {
		m.projectTeammates = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.projectTeammates[ids[i]] = struct{}{}
	}
}

// ClearProjectTeammates clears the "projectTeammates" edge to the ProjectTeammate entity.
func (m *TeammateMutation) ClearProjectTeammates() {
	m.clearedprojectTeammates = true
}

// ProjectTeammatesCleared reports if the "projectTeammates" edge to the ProjectTeammate entity was cleared.
func (m *TeammateMutation) ProjectTeammatesCleared() bool {
	return m.clearedprojectTeammates
}

// RemoveProjectTeammateIDs removes the "projectTeammates" edge to the ProjectTeammate entity by IDs.
func (m *TeammateMutation) RemoveProjectTeammateIDs(ids ...ulid.ID) {
	if m.removedprojectTeammates == nil {
		m.removedprojectTeammates = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.projectTeammates, ids[i])
		m.removedprojectTeammates[ids[i]] = struct{}{}
	}
}

// RemovedProjectTeammates returns the removed IDs of the "projectTeammates" edge to the ProjectTeammate entity.
func (m *TeammateMutation) RemovedProjectTeammatesIDs() (ids []ulid.ID) {
	for id := range m.removedprojectTeammates {
		ids = append(ids, id)
	}
	return
}

// ProjectTeammatesIDs returns the "projectTeammates" edge IDs in the mutation.
func (m *TeammateMutation) ProjectTeammatesIDs() (ids []ulid.ID) {
	for id := range m.projectTeammates {
		ids = append(ids, id)
	}
	return
}

// ResetProjectTeammates resets all changes to the "projectTeammates" edge.
func (m *TeammateMutation) ResetProjectTeammates() {
	m.projectTeammates = nil
	m.clearedprojectTeammates = false
	m.removedprojectTeammates = nil
}

// AddWorkspaceTeammateIDs adds the "workspaceTeammates" edge to the WorkspaceTeammate entity by ids.
func (m *TeammateMutation) AddWorkspaceTeammateIDs(ids ...ulid.ID) {
	if m.workspaceTeammates == nil {
		m.workspaceTeammates = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.workspaceTeammates[ids[i]] = struct{}{}
	}
}

// ClearWorkspaceTeammates clears the "workspaceTeammates" edge to the WorkspaceTeammate entity.
func (m *TeammateMutation) ClearWorkspaceTeammates() {
	m.clearedworkspaceTeammates = true
}

// WorkspaceTeammatesCleared reports if the "workspaceTeammates" edge to the WorkspaceTeammate entity was cleared.
func (m *TeammateMutation) WorkspaceTeammatesCleared() bool {
	return m.clearedworkspaceTeammates
}

// RemoveWorkspaceTeammateIDs removes the "workspaceTeammates" edge to the WorkspaceTeammate entity by IDs.
func (m *TeammateMutation) RemoveWorkspaceTeammateIDs(ids ...ulid.ID) {
	if m.removedworkspaceTeammates == nil {
		m.removedworkspaceTeammates = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.workspaceTeammates, ids[i])
		m.removedworkspaceTeammates[ids[i]] = struct{}{}
	}
}

// RemovedWorkspaceTeammates returns the removed IDs of the "workspaceTeammates" edge to the WorkspaceTeammate entity.
func (m *TeammateMutation) RemovedWorkspaceTeammatesIDs() (ids []ulid.ID) {
	for id := range m.removedworkspaceTeammates {
		ids = append(ids, id)
	}
	return
}

// WorkspaceTeammatesIDs returns the "workspaceTeammates" edge IDs in the mutation.
func (m *TeammateMutation) WorkspaceTeammatesIDs() (ids []ulid.ID) {
	for id := range m.workspaceTeammates {
		ids = append(ids, id)
	}
	return
}

// ResetWorkspaceTeammates resets all changes to the "workspaceTeammates" edge.
func (m *TeammateMutation) ResetWorkspaceTeammates() {
	m.workspaceTeammates = nil
	m.clearedworkspaceTeammates = false
	m.removedworkspaceTeammates = nil
}

// AddFavoriteProjectIDs adds the "favoriteProjects" edge to the FavoriteProject entity by ids.
func (m *TeammateMutation) AddFavoriteProjectIDs(ids ...ulid.ID) {
	if m.favoriteProjects == nil {
		m.favoriteProjects = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.favoriteProjects[ids[i]] = struct{}{}
	}
}

// ClearFavoriteProjects clears the "favoriteProjects" edge to the FavoriteProject entity.
func (m *TeammateMutation) ClearFavoriteProjects() {
	m.clearedfavoriteProjects = true
}

// FavoriteProjectsCleared reports if the "favoriteProjects" edge to the FavoriteProject entity was cleared.
func (m *TeammateMutation) FavoriteProjectsCleared() bool {
	return m.clearedfavoriteProjects
}

// RemoveFavoriteProjectIDs removes the "favoriteProjects" edge to the FavoriteProject entity by IDs.
func (m *TeammateMutation) RemoveFavoriteProjectIDs(ids ...ulid.ID) {
	if m.removedfavoriteProjects == nil {
		m.removedfavoriteProjects = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.favoriteProjects, ids[i])
		m.removedfavoriteProjects[ids[i]] = struct{}{}
	}
}

// RemovedFavoriteProjects returns the removed IDs of the "favoriteProjects" edge to the FavoriteProject entity.
func (m *TeammateMutation) RemovedFavoriteProjectsIDs() (ids []ulid.ID) {
	for id := range m.removedfavoriteProjects {
		ids = append(ids, id)
	}
	return
}

// FavoriteProjectsIDs returns the "favoriteProjects" edge IDs in the mutation.
func (m *TeammateMutation) FavoriteProjectsIDs() (ids []ulid.ID) {
	for id := range m.favoriteProjects {
		ids = append(ids, id)
	}
	return
}

// ResetFavoriteProjects resets all changes to the "favoriteProjects" edge.
func (m *TeammateMutation) ResetFavoriteProjects() {
	m.favoriteProjects = nil
	m.clearedfavoriteProjects = false
	m.removedfavoriteProjects = nil
}

// AddFavoriteWorkspaceIDs adds the "favoriteWorkspaces" edge to the FavoriteWorkspace entity by ids.
func (m *TeammateMutation) AddFavoriteWorkspaceIDs(ids ...ulid.ID) {
	if m.favoriteWorkspaces == nil {
		m.favoriteWorkspaces = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.favoriteWorkspaces[ids[i]] = struct{}{}
	}
}

// ClearFavoriteWorkspaces clears the "favoriteWorkspaces" edge to the FavoriteWorkspace entity.
func (m *TeammateMutation) ClearFavoriteWorkspaces() {
	m.clearedfavoriteWorkspaces = true
}

// FavoriteWorkspacesCleared reports if the "favoriteWorkspaces" edge to the FavoriteWorkspace entity was cleared.
func (m *TeammateMutation) FavoriteWorkspacesCleared() bool {
	return m.clearedfavoriteWorkspaces
}

// RemoveFavoriteWorkspaceIDs removes the "favoriteWorkspaces" edge to the FavoriteWorkspace entity by IDs.
func (m *TeammateMutation) RemoveFavoriteWorkspaceIDs(ids ...ulid.ID) {
	if m.removedfavoriteWorkspaces == nil {
		m.removedfavoriteWorkspaces = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.favoriteWorkspaces, ids[i])
		m.removedfavoriteWorkspaces[ids[i]] = struct{}{}
	}
}

// RemovedFavoriteWorkspaces returns the removed IDs of the "favoriteWorkspaces" edge to the FavoriteWorkspace entity.
func (m *TeammateMutation) RemovedFavoriteWorkspacesIDs() (ids []ulid.ID) {
	for id := range m.removedfavoriteWorkspaces {
		ids = append(ids, id)
	}
	return
}

// FavoriteWorkspacesIDs returns the "favoriteWorkspaces" edge IDs in the mutation.
func (m *TeammateMutation) FavoriteWorkspacesIDs() (ids []ulid.ID) {
	for id := range m.favoriteWorkspaces {
		ids = append(ids, id)
	}
	return
}

// ResetFavoriteWorkspaces resets all changes to the "favoriteWorkspaces" edge.
func (m *TeammateMutation) ResetFavoriteWorkspaces() {
	m.favoriteWorkspaces = nil
	m.clearedfavoriteWorkspaces = false
	m.removedfavoriteWorkspaces = nil
}

// AddTeammateTaskTabStatuseIDs adds the "teammateTaskTabStatuses" edge to the TeammateTaskTabStatus entity by ids.
func (m *TeammateMutation) AddTeammateTaskTabStatuseIDs(ids ...ulid.ID) {
	if m.teammateTaskTabStatuses == nil {
		m.teammateTaskTabStatuses = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.teammateTaskTabStatuses[ids[i]] = struct{}{}
	}
}

// ClearTeammateTaskTabStatuses clears the "teammateTaskTabStatuses" edge to the TeammateTaskTabStatus entity.
func (m *TeammateMutation) ClearTeammateTaskTabStatuses() {
	m.clearedteammateTaskTabStatuses = true
}

// TeammateTaskTabStatusesCleared reports if the "teammateTaskTabStatuses" edge to the TeammateTaskTabStatus entity was cleared.
func (m *TeammateMutation) TeammateTaskTabStatusesCleared() bool {
	return m.clearedteammateTaskTabStatuses
}

// RemoveTeammateTaskTabStatuseIDs removes the "teammateTaskTabStatuses" edge to the TeammateTaskTabStatus entity by IDs.
func (m *TeammateMutation) RemoveTeammateTaskTabStatuseIDs(ids ...ulid.ID) {
	if m.removedteammateTaskTabStatuses == nil {
		m.removedteammateTaskTabStatuses = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.teammateTaskTabStatuses, ids[i])
		m.removedteammateTaskTabStatuses[ids[i]] = struct{}{}
	}
}

// RemovedTeammateTaskTabStatuses returns the removed IDs of the "teammateTaskTabStatuses" edge to the TeammateTaskTabStatus entity.
func (m *TeammateMutation) RemovedTeammateTaskTabStatusesIDs() (ids []ulid.ID) {
	for id := range m.removedteammateTaskTabStatuses {
		ids = append(ids, id)
	}
	return
}

// TeammateTaskTabStatusesIDs returns the "teammateTaskTabStatuses" edge IDs in the mutation.
func (m *TeammateMutation) TeammateTaskTabStatusesIDs() (ids []ulid.ID) {
	for id := range m.teammateTaskTabStatuses {
		ids = append(ids, id)
	}
	return
}

// ResetTeammateTaskTabStatuses resets all changes to the "teammateTaskTabStatuses" edge.
func (m *TeammateMutation) ResetTeammateTaskTabStatuses() {
	m.teammateTaskTabStatuses = nil
	m.clearedteammateTaskTabStatuses = false
	m.removedteammateTaskTabStatuses = nil
}

// AddTeammateTaskColumnIDs adds the "teammateTaskColumns" edge to the TeammateTaskColumn entity by ids.
func (m *TeammateMutation) AddTeammateTaskColumnIDs(ids ...ulid.ID) {
	if m.teammateTaskColumns == nil {
		m.teammateTaskColumns = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.teammateTaskColumns[ids[i]] = struct{}{}
	}
}

// ClearTeammateTaskColumns clears the "teammateTaskColumns" edge to the TeammateTaskColumn entity.
func (m *TeammateMutation) ClearTeammateTaskColumns() {
	m.clearedteammateTaskColumns = true
}

// TeammateTaskColumnsCleared reports if the "teammateTaskColumns" edge to the TeammateTaskColumn entity was cleared.
func (m *TeammateMutation) TeammateTaskColumnsCleared() bool {
	return m.clearedteammateTaskColumns
}

// RemoveTeammateTaskColumnIDs removes the "teammateTaskColumns" edge to the TeammateTaskColumn entity by IDs.
func (m *TeammateMutation) RemoveTeammateTaskColumnIDs(ids ...ulid.ID) {
	if m.removedteammateTaskColumns == nil {
		m.removedteammateTaskColumns = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.teammateTaskColumns, ids[i])
		m.removedteammateTaskColumns[ids[i]] = struct{}{}
	}
}

// RemovedTeammateTaskColumns returns the removed IDs of the "teammateTaskColumns" edge to the TeammateTaskColumn entity.
func (m *TeammateMutation) RemovedTeammateTaskColumnsIDs() (ids []ulid.ID) {
	for id := range m.removedteammateTaskColumns {
		ids = append(ids, id)
	}
	return
}

// TeammateTaskColumnsIDs returns the "teammateTaskColumns" edge IDs in the mutation.
func (m *TeammateMutation) TeammateTaskColumnsIDs() (ids []ulid.ID) {
	for id := range m.teammateTaskColumns {
		ids = append(ids, id)
	}
	return
}

// ResetTeammateTaskColumns resets all changes to the "teammateTaskColumns" edge.
func (m *TeammateMutation) ResetTeammateTaskColumns() {
	m.teammateTaskColumns = nil
	m.clearedteammateTaskColumns = false
	m.removedteammateTaskColumns = nil
}

// AddTeammateTaskListStatuseIDs adds the "teammateTaskListStatuses" edge to the TeammateTaskListStatus entity by ids.
func (m *TeammateMutation) AddTeammateTaskListStatuseIDs(ids ...ulid.ID) {
	if m.teammateTaskListStatuses == nil {
		m.teammateTaskListStatuses = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.teammateTaskListStatuses[ids[i]] = struct{}{}
	}
}

// ClearTeammateTaskListStatuses clears the "teammateTaskListStatuses" edge to the TeammateTaskListStatus entity.
func (m *TeammateMutation) ClearTeammateTaskListStatuses() {
	m.clearedteammateTaskListStatuses = true
}

// TeammateTaskListStatusesCleared reports if the "teammateTaskListStatuses" edge to the TeammateTaskListStatus entity was cleared.
func (m *TeammateMutation) TeammateTaskListStatusesCleared() bool {
	return m.clearedteammateTaskListStatuses
}

// RemoveTeammateTaskListStatuseIDs removes the "teammateTaskListStatuses" edge to the TeammateTaskListStatus entity by IDs.
func (m *TeammateMutation) RemoveTeammateTaskListStatuseIDs(ids ...ulid.ID) {
	if m.removedteammateTaskListStatuses == nil {
		m.removedteammateTaskListStatuses = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.teammateTaskListStatuses, ids[i])
		m.removedteammateTaskListStatuses[ids[i]] = struct{}{}
	}
}

// RemovedTeammateTaskListStatuses returns the removed IDs of the "teammateTaskListStatuses" edge to the TeammateTaskListStatus entity.
func (m *TeammateMutation) RemovedTeammateTaskListStatusesIDs() (ids []ulid.ID) {
	for id := range m.removedteammateTaskListStatuses {
		ids = append(ids, id)
	}
	return
}

// TeammateTaskListStatusesIDs returns the "teammateTaskListStatuses" edge IDs in the mutation.
func (m *TeammateMutation) TeammateTaskListStatusesIDs() (ids []ulid.ID) {
	for id := range m.teammateTaskListStatuses {
		ids = append(ids, id)
	}
	return
}

// ResetTeammateTaskListStatuses resets all changes to the "teammateTaskListStatuses" edge.
func (m *TeammateMutation) ResetTeammateTaskListStatuses() {
	m.teammateTaskListStatuses = nil
	m.clearedteammateTaskListStatuses = false
	m.removedteammateTaskListStatuses = nil
}

// AddTeammateTaskSectionIDs adds the "teammateTaskSections" edge to the TeammateTaskSection entity by ids.
func (m *TeammateMutation) AddTeammateTaskSectionIDs(ids ...ulid.ID) {
	if m.teammateTaskSections == nil {
		m.teammateTaskSections = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.teammateTaskSections[ids[i]] = struct{}{}
	}
}

// ClearTeammateTaskSections clears the "teammateTaskSections" edge to the TeammateTaskSection entity.
func (m *TeammateMutation) ClearTeammateTaskSections() {
	m.clearedteammateTaskSections = true
}

// TeammateTaskSectionsCleared reports if the "teammateTaskSections" edge to the TeammateTaskSection entity was cleared.
func (m *TeammateMutation) TeammateTaskSectionsCleared() bool {
	return m.clearedteammateTaskSections
}

// RemoveTeammateTaskSectionIDs removes the "teammateTaskSections" edge to the TeammateTaskSection entity by IDs.
func (m *TeammateMutation) RemoveTeammateTaskSectionIDs(ids ...ulid.ID) {
	if m.removedteammateTaskSections == nil {
		m.removedteammateTaskSections = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.teammateTaskSections, ids[i])
		m.removedteammateTaskSections[ids[i]] = struct{}{}
	}
}

// RemovedTeammateTaskSections returns the removed IDs of the "teammateTaskSections" edge to the TeammateTaskSection entity.
func (m *TeammateMutation) RemovedTeammateTaskSectionsIDs() (ids []ulid.ID) {
	for id := range m.removedteammateTaskSections {
		ids = append(ids, id)
	}
	return
}

// TeammateTaskSectionsIDs returns the "teammateTaskSections" edge IDs in the mutation.
func (m *TeammateMutation) TeammateTaskSectionsIDs() (ids []ulid.ID) {
	for id := range m.teammateTaskSections {
		ids = append(ids, id)
	}
	return
}

// ResetTeammateTaskSections resets all changes to the "teammateTaskSections" edge.
func (m *TeammateMutation) ResetTeammateTaskSections() {
	m.teammateTaskSections = nil
	m.clearedteammateTaskSections = false
	m.removedteammateTaskSections = nil
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *TeammateMutation) AddTaskIDs(ids ...ulid.ID) {
	if m.tasks == nil {
		m.tasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *TeammateMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *TeammateMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *TeammateMutation) RemoveTaskIDs(ids ...ulid.ID) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *TeammateMutation) RemovedTasksIDs() (ids []ulid.ID) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *TeammateMutation) TasksIDs() (ids []ulid.ID) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *TeammateMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddTeammateTaskIDs adds the "teammateTasks" edge to the TeammateTask entity by ids.
func (m *TeammateMutation) AddTeammateTaskIDs(ids ...ulid.ID) {
	if m.teammateTasks == nil {
		m.teammateTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.teammateTasks[ids[i]] = struct{}{}
	}
}

// ClearTeammateTasks clears the "teammateTasks" edge to the TeammateTask entity.
func (m *TeammateMutation) ClearTeammateTasks() {
	m.clearedteammateTasks = true
}

// TeammateTasksCleared reports if the "teammateTasks" edge to the TeammateTask entity was cleared.
func (m *TeammateMutation) TeammateTasksCleared() bool {
	return m.clearedteammateTasks
}

// RemoveTeammateTaskIDs removes the "teammateTasks" edge to the TeammateTask entity by IDs.
func (m *TeammateMutation) RemoveTeammateTaskIDs(ids ...ulid.ID) {
	if m.removedteammateTasks == nil {
		m.removedteammateTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.teammateTasks, ids[i])
		m.removedteammateTasks[ids[i]] = struct{}{}
	}
}

// RemovedTeammateTasks returns the removed IDs of the "teammateTasks" edge to the TeammateTask entity.
func (m *TeammateMutation) RemovedTeammateTasksIDs() (ids []ulid.ID) {
	for id := range m.removedteammateTasks {
		ids = append(ids, id)
	}
	return
}

// TeammateTasksIDs returns the "teammateTasks" edge IDs in the mutation.
func (m *TeammateMutation) TeammateTasksIDs() (ids []ulid.ID) {
	for id := range m.teammateTasks {
		ids = append(ids, id)
	}
	return
}

// ResetTeammateTasks resets all changes to the "teammateTasks" edge.
func (m *TeammateMutation) ResetTeammateTasks() {
	m.teammateTasks = nil
	m.clearedteammateTasks = false
	m.removedteammateTasks = nil
}

// AddTaskLikeIDs adds the "taskLikes" edge to the TaskLike entity by ids.
func (m *TeammateMutation) AddTaskLikeIDs(ids ...ulid.ID) {
	if m.taskLikes == nil {
		m.taskLikes = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.taskLikes[ids[i]] = struct{}{}
	}
}

// ClearTaskLikes clears the "taskLikes" edge to the TaskLike entity.
func (m *TeammateMutation) ClearTaskLikes() {
	m.clearedtaskLikes = true
}

// TaskLikesCleared reports if the "taskLikes" edge to the TaskLike entity was cleared.
func (m *TeammateMutation) TaskLikesCleared() bool {
	return m.clearedtaskLikes
}

// RemoveTaskLikeIDs removes the "taskLikes" edge to the TaskLike entity by IDs.
func (m *TeammateMutation) RemoveTaskLikeIDs(ids ...ulid.ID) {
	if m.removedtaskLikes == nil {
		m.removedtaskLikes = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.taskLikes, ids[i])
		m.removedtaskLikes[ids[i]] = struct{}{}
	}
}

// RemovedTaskLikes returns the removed IDs of the "taskLikes" edge to the TaskLike entity.
func (m *TeammateMutation) RemovedTaskLikesIDs() (ids []ulid.ID) {
	for id := range m.removedtaskLikes {
		ids = append(ids, id)
	}
	return
}

// TaskLikesIDs returns the "taskLikes" edge IDs in the mutation.
func (m *TeammateMutation) TaskLikesIDs() (ids []ulid.ID) {
	for id := range m.taskLikes {
		ids = append(ids, id)
	}
	return
}

// ResetTaskLikes resets all changes to the "taskLikes" edge.
func (m *TeammateMutation) ResetTaskLikes() {
	m.taskLikes = nil
	m.clearedtaskLikes = false
	m.removedtaskLikes = nil
}

// AddTaskCollaboratorIDs adds the "taskCollaborators" edge to the TaskCollaborator entity by ids.
func (m *TeammateMutation) AddTaskCollaboratorIDs(ids ...ulid.ID) {
	if m.taskCollaborators == nil {
		m.taskCollaborators = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.taskCollaborators[ids[i]] = struct{}{}
	}
}

// ClearTaskCollaborators clears the "taskCollaborators" edge to the TaskCollaborator entity.
func (m *TeammateMutation) ClearTaskCollaborators() {
	m.clearedtaskCollaborators = true
}

// TaskCollaboratorsCleared reports if the "taskCollaborators" edge to the TaskCollaborator entity was cleared.
func (m *TeammateMutation) TaskCollaboratorsCleared() bool {
	return m.clearedtaskCollaborators
}

// RemoveTaskCollaboratorIDs removes the "taskCollaborators" edge to the TaskCollaborator entity by IDs.
func (m *TeammateMutation) RemoveTaskCollaboratorIDs(ids ...ulid.ID) {
	if m.removedtaskCollaborators == nil {
		m.removedtaskCollaborators = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.taskCollaborators, ids[i])
		m.removedtaskCollaborators[ids[i]] = struct{}{}
	}
}

// RemovedTaskCollaborators returns the removed IDs of the "taskCollaborators" edge to the TaskCollaborator entity.
func (m *TeammateMutation) RemovedTaskCollaboratorsIDs() (ids []ulid.ID) {
	for id := range m.removedtaskCollaborators {
		ids = append(ids, id)
	}
	return
}

// TaskCollaboratorsIDs returns the "taskCollaborators" edge IDs in the mutation.
func (m *TeammateMutation) TaskCollaboratorsIDs() (ids []ulid.ID) {
	for id := range m.taskCollaborators {
		ids = append(ids, id)
	}
	return
}

// ResetTaskCollaborators resets all changes to the "taskCollaborators" edge.
func (m *TeammateMutation) ResetTaskCollaborators() {
	m.taskCollaborators = nil
	m.clearedtaskCollaborators = false
	m.removedtaskCollaborators = nil
}

// AddTaskFeedIDs adds the "taskFeeds" edge to the TaskFeed entity by ids.
func (m *TeammateMutation) AddTaskFeedIDs(ids ...ulid.ID) {
	if m.taskFeeds == nil {
		m.taskFeeds = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.taskFeeds[ids[i]] = struct{}{}
	}
}

// ClearTaskFeeds clears the "taskFeeds" edge to the TaskFeed entity.
func (m *TeammateMutation) ClearTaskFeeds() {
	m.clearedtaskFeeds = true
}

// TaskFeedsCleared reports if the "taskFeeds" edge to the TaskFeed entity was cleared.
func (m *TeammateMutation) TaskFeedsCleared() bool {
	return m.clearedtaskFeeds
}

// RemoveTaskFeedIDs removes the "taskFeeds" edge to the TaskFeed entity by IDs.
func (m *TeammateMutation) RemoveTaskFeedIDs(ids ...ulid.ID) {
	if m.removedtaskFeeds == nil {
		m.removedtaskFeeds = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.taskFeeds, ids[i])
		m.removedtaskFeeds[ids[i]] = struct{}{}
	}
}

// RemovedTaskFeeds returns the removed IDs of the "taskFeeds" edge to the TaskFeed entity.
func (m *TeammateMutation) RemovedTaskFeedsIDs() (ids []ulid.ID) {
	for id := range m.removedtaskFeeds {
		ids = append(ids, id)
	}
	return
}

// TaskFeedsIDs returns the "taskFeeds" edge IDs in the mutation.
func (m *TeammateMutation) TaskFeedsIDs() (ids []ulid.ID) {
	for id := range m.taskFeeds {
		ids = append(ids, id)
	}
	return
}

// ResetTaskFeeds resets all changes to the "taskFeeds" edge.
func (m *TeammateMutation) ResetTaskFeeds() {
	m.taskFeeds = nil
	m.clearedtaskFeeds = false
	m.removedtaskFeeds = nil
}

// AddTaskFeedLikeIDs adds the "taskFeedLikes" edge to the TaskFeedLike entity by ids.
func (m *TeammateMutation) AddTaskFeedLikeIDs(ids ...ulid.ID) {
	if m.taskFeedLikes == nil {
		m.taskFeedLikes = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.taskFeedLikes[ids[i]] = struct{}{}
	}
}

// ClearTaskFeedLikes clears the "taskFeedLikes" edge to the TaskFeedLike entity.
func (m *TeammateMutation) ClearTaskFeedLikes() {
	m.clearedtaskFeedLikes = true
}

// TaskFeedLikesCleared reports if the "taskFeedLikes" edge to the TaskFeedLike entity was cleared.
func (m *TeammateMutation) TaskFeedLikesCleared() bool {
	return m.clearedtaskFeedLikes
}

// RemoveTaskFeedLikeIDs removes the "taskFeedLikes" edge to the TaskFeedLike entity by IDs.
func (m *TeammateMutation) RemoveTaskFeedLikeIDs(ids ...ulid.ID) {
	if m.removedtaskFeedLikes == nil {
		m.removedtaskFeedLikes = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.taskFeedLikes, ids[i])
		m.removedtaskFeedLikes[ids[i]] = struct{}{}
	}
}

// RemovedTaskFeedLikes returns the removed IDs of the "taskFeedLikes" edge to the TaskFeedLike entity.
func (m *TeammateMutation) RemovedTaskFeedLikesIDs() (ids []ulid.ID) {
	for id := range m.removedtaskFeedLikes {
		ids = append(ids, id)
	}
	return
}

// TaskFeedLikesIDs returns the "taskFeedLikes" edge IDs in the mutation.
func (m *TeammateMutation) TaskFeedLikesIDs() (ids []ulid.ID) {
	for id := range m.taskFeedLikes {
		ids = append(ids, id)
	}
	return
}

// ResetTaskFeedLikes resets all changes to the "taskFeedLikes" edge.
func (m *TeammateMutation) ResetTaskFeedLikes() {
	m.taskFeedLikes = nil
	m.clearedtaskFeedLikes = false
	m.removedtaskFeedLikes = nil
}

// AddTaskActivityIDs adds the "taskActivities" edge to the TaskActivity entity by ids.
func (m *TeammateMutation) AddTaskActivityIDs(ids ...ulid.ID) {
	if m.taskActivities == nil {
		m.taskActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.taskActivities[ids[i]] = struct{}{}
	}
}

// ClearTaskActivities clears the "taskActivities" edge to the TaskActivity entity.
func (m *TeammateMutation) ClearTaskActivities() {
	m.clearedtaskActivities = true
}

// TaskActivitiesCleared reports if the "taskActivities" edge to the TaskActivity entity was cleared.
func (m *TeammateMutation) TaskActivitiesCleared() bool {
	return m.clearedtaskActivities
}

// RemoveTaskActivityIDs removes the "taskActivities" edge to the TaskActivity entity by IDs.
func (m *TeammateMutation) RemoveTaskActivityIDs(ids ...ulid.ID) {
	if m.removedtaskActivities == nil {
		m.removedtaskActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.taskActivities, ids[i])
		m.removedtaskActivities[ids[i]] = struct{}{}
	}
}

// RemovedTaskActivities returns the removed IDs of the "taskActivities" edge to the TaskActivity entity.
func (m *TeammateMutation) RemovedTaskActivitiesIDs() (ids []ulid.ID) {
	for id := range m.removedtaskActivities {
		ids = append(ids, id)
	}
	return
}

// TaskActivitiesIDs returns the "taskActivities" edge IDs in the mutation.
func (m *TeammateMutation) TaskActivitiesIDs() (ids []ulid.ID) {
	for id := range m.taskActivities {
		ids = append(ids, id)
	}
	return
}

// ResetTaskActivities resets all changes to the "taskActivities" edge.
func (m *TeammateMutation) ResetTaskActivities() {
	m.taskActivities = nil
	m.clearedtaskActivities = false
	m.removedtaskActivities = nil
}

// AddWorkspaceActivityIDs adds the "workspaceActivities" edge to the WorkspaceActivity entity by ids.
func (m *TeammateMutation) AddWorkspaceActivityIDs(ids ...ulid.ID) {
	if m.workspaceActivities == nil {
		m.workspaceActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.workspaceActivities[ids[i]] = struct{}{}
	}
}

// ClearWorkspaceActivities clears the "workspaceActivities" edge to the WorkspaceActivity entity.
func (m *TeammateMutation) ClearWorkspaceActivities() {
	m.clearedworkspaceActivities = true
}

// WorkspaceActivitiesCleared reports if the "workspaceActivities" edge to the WorkspaceActivity entity was cleared.
func (m *TeammateMutation) WorkspaceActivitiesCleared() bool {
	return m.clearedworkspaceActivities
}

// RemoveWorkspaceActivityIDs removes the "workspaceActivities" edge to the WorkspaceActivity entity by IDs.
func (m *TeammateMutation) RemoveWorkspaceActivityIDs(ids ...ulid.ID) {
	if m.removedworkspaceActivities == nil {
		m.removedworkspaceActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.workspaceActivities, ids[i])
		m.removedworkspaceActivities[ids[i]] = struct{}{}
	}
}

// RemovedWorkspaceActivities returns the removed IDs of the "workspaceActivities" edge to the WorkspaceActivity entity.
func (m *TeammateMutation) RemovedWorkspaceActivitiesIDs() (ids []ulid.ID) {
	for id := range m.removedworkspaceActivities {
		ids = append(ids, id)
	}
	return
}

// WorkspaceActivitiesIDs returns the "workspaceActivities" edge IDs in the mutation.
func (m *TeammateMutation) WorkspaceActivitiesIDs() (ids []ulid.ID) {
	for id := range m.workspaceActivities {
		ids = append(ids, id)
	}
	return
}

// ResetWorkspaceActivities resets all changes to the "workspaceActivities" edge.
func (m *TeammateMutation) ResetWorkspaceActivities() {
	m.workspaceActivities = nil
	m.clearedworkspaceActivities = false
	m.removedworkspaceActivities = nil
}

// AddArchivedTaskActivityIDs adds the "archivedTaskActivities" edge to the ArchivedTaskActivity entity by ids.
func (m *TeammateMutation) AddArchivedTaskActivityIDs(ids ...ulid.ID) {
	if m.archivedTaskActivities == nil {
		m.archivedTaskActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.archivedTaskActivities[ids[i]] = struct{}{}
	}
}

// ClearArchivedTaskActivities clears the "archivedTaskActivities" edge to the ArchivedTaskActivity entity.
func (m *TeammateMutation) ClearArchivedTaskActivities() {
	m.clearedarchivedTaskActivities = true
}

// ArchivedTaskActivitiesCleared reports if the "archivedTaskActivities" edge to the ArchivedTaskActivity entity was cleared.
func (m *TeammateMutation) ArchivedTaskActivitiesCleared() bool {
	return m.clearedarchivedTaskActivities
}

// RemoveArchivedTaskActivityIDs removes the "archivedTaskActivities" edge to the ArchivedTaskActivity entity by IDs.
func (m *TeammateMutation) RemoveArchivedTaskActivityIDs(ids ...ulid.ID) {
	if m.removedarchivedTaskActivities == nil {
		m.removedarchivedTaskActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.archivedTaskActivities, ids[i])
		m.removedarchivedTaskActivities[ids[i]] = struct{}{}
	}
}

// RemovedArchivedTaskActivities returns the removed IDs of the "archivedTaskActivities" edge to the ArchivedTaskActivity entity.
func (m *TeammateMutation) RemovedArchivedTaskActivitiesIDs() (ids []ulid.ID) {
	for id := range m.removedarchivedTaskActivities {
		ids = append(ids, id)
	}
	return
}

// ArchivedTaskActivitiesIDs returns the "archivedTaskActivities" edge IDs in the mutation.
func (m *TeammateMutation) ArchivedTaskActivitiesIDs() (ids []ulid.ID) {
	for id := range m.archivedTaskActivities {
		ids = append(ids, id)
	}
	return
}

// ResetArchivedTaskActivities resets all changes to the "archivedTaskActivities" edge.
func (m *TeammateMutation) ResetArchivedTaskActivities() {
	m.archivedTaskActivities = nil
	m.clearedarchivedTaskActivities = false
	m.removedarchivedTaskActivities = nil
}

// AddArchivedWorkspaceActivityIDs adds the "archivedWorkspaceActivities" edge to the ArchivedWorkspaceActivity entity by ids.
func (m *TeammateMutation) AddArchivedWorkspaceActivityIDs(ids ...ulid.ID) {
	if m.archivedWorkspaceActivities == nil {
		m.archivedWorkspaceActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.archivedWorkspaceActivities[ids[i]] = struct{}{}
	}
}

// ClearArchivedWorkspaceActivities clears the "archivedWorkspaceActivities" edge to the ArchivedWorkspaceActivity entity.
func (m *TeammateMutation) ClearArchivedWorkspaceActivities() {
	m.clearedarchivedWorkspaceActivities = true
}

// ArchivedWorkspaceActivitiesCleared reports if the "archivedWorkspaceActivities" edge to the ArchivedWorkspaceActivity entity was cleared.
func (m *TeammateMutation) ArchivedWorkspaceActivitiesCleared() bool {
	return m.clearedarchivedWorkspaceActivities
}

// RemoveArchivedWorkspaceActivityIDs removes the "archivedWorkspaceActivities" edge to the ArchivedWorkspaceActivity entity by IDs.
func (m *TeammateMutation) RemoveArchivedWorkspaceActivityIDs(ids ...ulid.ID) {
	if m.removedarchivedWorkspaceActivities == nil {
		m.removedarchivedWorkspaceActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.archivedWorkspaceActivities, ids[i])
		m.removedarchivedWorkspaceActivities[ids[i]] = struct{}{}
	}
}

// RemovedArchivedWorkspaceActivities returns the removed IDs of the "archivedWorkspaceActivities" edge to the ArchivedWorkspaceActivity entity.
func (m *TeammateMutation) RemovedArchivedWorkspaceActivitiesIDs() (ids []ulid.ID) {
	for id := range m.removedarchivedWorkspaceActivities {
		ids = append(ids, id)
	}
	return
}

// ArchivedWorkspaceActivitiesIDs returns the "archivedWorkspaceActivities" edge IDs in the mutation.
func (m *TeammateMutation) ArchivedWorkspaceActivitiesIDs() (ids []ulid.ID) {
	for id := range m.archivedWorkspaceActivities {
		ids = append(ids, id)
	}
	return
}

// ResetArchivedWorkspaceActivities resets all changes to the "archivedWorkspaceActivities" edge.
func (m *TeammateMutation) ResetArchivedWorkspaceActivities() {
	m.archivedWorkspaceActivities = nil
	m.clearedarchivedWorkspaceActivities = false
	m.removedarchivedWorkspaceActivities = nil
}

// Where appends a list predicates to the TeammateMutation builder.
func (m *TeammateMutation) Where(ps ...predicate.Teammate) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TeammateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Teammate).
func (m *TeammateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeammateMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, teammate.FieldName)
	}
	if m.image != nil {
		fields = append(fields, teammate.FieldImage)
	}
	if m.email != nil {
		fields = append(fields, teammate.FieldEmail)
	}
	if m.created_at != nil {
		fields = append(fields, teammate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, teammate.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeammateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teammate.FieldName:
		return m.Name()
	case teammate.FieldImage:
		return m.Image()
	case teammate.FieldEmail:
		return m.Email()
	case teammate.FieldCreatedAt:
		return m.CreatedAt()
	case teammate.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeammateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teammate.FieldName:
		return m.OldName(ctx)
	case teammate.FieldImage:
		return m.OldImage(ctx)
	case teammate.FieldEmail:
		return m.OldEmail(ctx)
	case teammate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case teammate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Teammate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeammateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teammate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case teammate.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case teammate.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case teammate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case teammate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Teammate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeammateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeammateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeammateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Teammate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeammateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeammateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeammateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Teammate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeammateMutation) ResetField(name string) error {
	switch name {
	case teammate.FieldName:
		m.ResetName()
		return nil
	case teammate.FieldImage:
		m.ResetImage()
		return nil
	case teammate.FieldEmail:
		m.ResetEmail()
		return nil
	case teammate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case teammate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Teammate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeammateMutation) AddedEdges() []string {
	edges := make([]string, 0, 20)
	if m.workspaces != nil {
		edges = append(edges, teammate.EdgeWorkspaces)
	}
	if m.projects != nil {
		edges = append(edges, teammate.EdgeProjects)
	}
	if m.projectTeammates != nil {
		edges = append(edges, teammate.EdgeProjectTeammates)
	}
	if m.workspaceTeammates != nil {
		edges = append(edges, teammate.EdgeWorkspaceTeammates)
	}
	if m.favoriteProjects != nil {
		edges = append(edges, teammate.EdgeFavoriteProjects)
	}
	if m.favoriteWorkspaces != nil {
		edges = append(edges, teammate.EdgeFavoriteWorkspaces)
	}
	if m.teammateTaskTabStatuses != nil {
		edges = append(edges, teammate.EdgeTeammateTaskTabStatuses)
	}
	if m.teammateTaskColumns != nil {
		edges = append(edges, teammate.EdgeTeammateTaskColumns)
	}
	if m.teammateTaskListStatuses != nil {
		edges = append(edges, teammate.EdgeTeammateTaskListStatuses)
	}
	if m.teammateTaskSections != nil {
		edges = append(edges, teammate.EdgeTeammateTaskSections)
	}
	if m.tasks != nil {
		edges = append(edges, teammate.EdgeTasks)
	}
	if m.teammateTasks != nil {
		edges = append(edges, teammate.EdgeTeammateTasks)
	}
	if m.taskLikes != nil {
		edges = append(edges, teammate.EdgeTaskLikes)
	}
	if m.taskCollaborators != nil {
		edges = append(edges, teammate.EdgeTaskCollaborators)
	}
	if m.taskFeeds != nil {
		edges = append(edges, teammate.EdgeTaskFeeds)
	}
	if m.taskFeedLikes != nil {
		edges = append(edges, teammate.EdgeTaskFeedLikes)
	}
	if m.taskActivities != nil {
		edges = append(edges, teammate.EdgeTaskActivities)
	}
	if m.workspaceActivities != nil {
		edges = append(edges, teammate.EdgeWorkspaceActivities)
	}
	if m.archivedTaskActivities != nil {
		edges = append(edges, teammate.EdgeArchivedTaskActivities)
	}
	if m.archivedWorkspaceActivities != nil {
		edges = append(edges, teammate.EdgeArchivedWorkspaceActivities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeammateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teammate.EdgeWorkspaces:
		ids := make([]ent.Value, 0, len(m.workspaces))
		for id := range m.workspaces {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeProjectTeammates:
		ids := make([]ent.Value, 0, len(m.projectTeammates))
		for id := range m.projectTeammates {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeWorkspaceTeammates:
		ids := make([]ent.Value, 0, len(m.workspaceTeammates))
		for id := range m.workspaceTeammates {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeFavoriteProjects:
		ids := make([]ent.Value, 0, len(m.favoriteProjects))
		for id := range m.favoriteProjects {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeFavoriteWorkspaces:
		ids := make([]ent.Value, 0, len(m.favoriteWorkspaces))
		for id := range m.favoriteWorkspaces {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeTeammateTaskTabStatuses:
		ids := make([]ent.Value, 0, len(m.teammateTaskTabStatuses))
		for id := range m.teammateTaskTabStatuses {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeTeammateTaskColumns:
		ids := make([]ent.Value, 0, len(m.teammateTaskColumns))
		for id := range m.teammateTaskColumns {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeTeammateTaskListStatuses:
		ids := make([]ent.Value, 0, len(m.teammateTaskListStatuses))
		for id := range m.teammateTaskListStatuses {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeTeammateTaskSections:
		ids := make([]ent.Value, 0, len(m.teammateTaskSections))
		for id := range m.teammateTaskSections {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeTeammateTasks:
		ids := make([]ent.Value, 0, len(m.teammateTasks))
		for id := range m.teammateTasks {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeTaskLikes:
		ids := make([]ent.Value, 0, len(m.taskLikes))
		for id := range m.taskLikes {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeTaskCollaborators:
		ids := make([]ent.Value, 0, len(m.taskCollaborators))
		for id := range m.taskCollaborators {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeTaskFeeds:
		ids := make([]ent.Value, 0, len(m.taskFeeds))
		for id := range m.taskFeeds {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeTaskFeedLikes:
		ids := make([]ent.Value, 0, len(m.taskFeedLikes))
		for id := range m.taskFeedLikes {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeTaskActivities:
		ids := make([]ent.Value, 0, len(m.taskActivities))
		for id := range m.taskActivities {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeWorkspaceActivities:
		ids := make([]ent.Value, 0, len(m.workspaceActivities))
		for id := range m.workspaceActivities {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeArchivedTaskActivities:
		ids := make([]ent.Value, 0, len(m.archivedTaskActivities))
		for id := range m.archivedTaskActivities {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeArchivedWorkspaceActivities:
		ids := make([]ent.Value, 0, len(m.archivedWorkspaceActivities))
		for id := range m.archivedWorkspaceActivities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeammateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 20)
	if m.removedworkspaces != nil {
		edges = append(edges, teammate.EdgeWorkspaces)
	}
	if m.removedprojects != nil {
		edges = append(edges, teammate.EdgeProjects)
	}
	if m.removedprojectTeammates != nil {
		edges = append(edges, teammate.EdgeProjectTeammates)
	}
	if m.removedworkspaceTeammates != nil {
		edges = append(edges, teammate.EdgeWorkspaceTeammates)
	}
	if m.removedfavoriteProjects != nil {
		edges = append(edges, teammate.EdgeFavoriteProjects)
	}
	if m.removedfavoriteWorkspaces != nil {
		edges = append(edges, teammate.EdgeFavoriteWorkspaces)
	}
	if m.removedteammateTaskTabStatuses != nil {
		edges = append(edges, teammate.EdgeTeammateTaskTabStatuses)
	}
	if m.removedteammateTaskColumns != nil {
		edges = append(edges, teammate.EdgeTeammateTaskColumns)
	}
	if m.removedteammateTaskListStatuses != nil {
		edges = append(edges, teammate.EdgeTeammateTaskListStatuses)
	}
	if m.removedteammateTaskSections != nil {
		edges = append(edges, teammate.EdgeTeammateTaskSections)
	}
	if m.removedtasks != nil {
		edges = append(edges, teammate.EdgeTasks)
	}
	if m.removedteammateTasks != nil {
		edges = append(edges, teammate.EdgeTeammateTasks)
	}
	if m.removedtaskLikes != nil {
		edges = append(edges, teammate.EdgeTaskLikes)
	}
	if m.removedtaskCollaborators != nil {
		edges = append(edges, teammate.EdgeTaskCollaborators)
	}
	if m.removedtaskFeeds != nil {
		edges = append(edges, teammate.EdgeTaskFeeds)
	}
	if m.removedtaskFeedLikes != nil {
		edges = append(edges, teammate.EdgeTaskFeedLikes)
	}
	if m.removedtaskActivities != nil {
		edges = append(edges, teammate.EdgeTaskActivities)
	}
	if m.removedworkspaceActivities != nil {
		edges = append(edges, teammate.EdgeWorkspaceActivities)
	}
	if m.removedarchivedTaskActivities != nil {
		edges = append(edges, teammate.EdgeArchivedTaskActivities)
	}
	if m.removedarchivedWorkspaceActivities != nil {
		edges = append(edges, teammate.EdgeArchivedWorkspaceActivities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeammateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case teammate.EdgeWorkspaces:
		ids := make([]ent.Value, 0, len(m.removedworkspaces))
		for id := range m.removedworkspaces {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeProjectTeammates:
		ids := make([]ent.Value, 0, len(m.removedprojectTeammates))
		for id := range m.removedprojectTeammates {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeWorkspaceTeammates:
		ids := make([]ent.Value, 0, len(m.removedworkspaceTeammates))
		for id := range m.removedworkspaceTeammates {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeFavoriteProjects:
		ids := make([]ent.Value, 0, len(m.removedfavoriteProjects))
		for id := range m.removedfavoriteProjects {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeFavoriteWorkspaces:
		ids := make([]ent.Value, 0, len(m.removedfavoriteWorkspaces))
		for id := range m.removedfavoriteWorkspaces {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeTeammateTaskTabStatuses:
		ids := make([]ent.Value, 0, len(m.removedteammateTaskTabStatuses))
		for id := range m.removedteammateTaskTabStatuses {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeTeammateTaskColumns:
		ids := make([]ent.Value, 0, len(m.removedteammateTaskColumns))
		for id := range m.removedteammateTaskColumns {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeTeammateTaskListStatuses:
		ids := make([]ent.Value, 0, len(m.removedteammateTaskListStatuses))
		for id := range m.removedteammateTaskListStatuses {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeTeammateTaskSections:
		ids := make([]ent.Value, 0, len(m.removedteammateTaskSections))
		for id := range m.removedteammateTaskSections {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeTeammateTasks:
		ids := make([]ent.Value, 0, len(m.removedteammateTasks))
		for id := range m.removedteammateTasks {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeTaskLikes:
		ids := make([]ent.Value, 0, len(m.removedtaskLikes))
		for id := range m.removedtaskLikes {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeTaskCollaborators:
		ids := make([]ent.Value, 0, len(m.removedtaskCollaborators))
		for id := range m.removedtaskCollaborators {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeTaskFeeds:
		ids := make([]ent.Value, 0, len(m.removedtaskFeeds))
		for id := range m.removedtaskFeeds {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeTaskFeedLikes:
		ids := make([]ent.Value, 0, len(m.removedtaskFeedLikes))
		for id := range m.removedtaskFeedLikes {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeTaskActivities:
		ids := make([]ent.Value, 0, len(m.removedtaskActivities))
		for id := range m.removedtaskActivities {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeWorkspaceActivities:
		ids := make([]ent.Value, 0, len(m.removedworkspaceActivities))
		for id := range m.removedworkspaceActivities {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeArchivedTaskActivities:
		ids := make([]ent.Value, 0, len(m.removedarchivedTaskActivities))
		for id := range m.removedarchivedTaskActivities {
			ids = append(ids, id)
		}
		return ids
	case teammate.EdgeArchivedWorkspaceActivities:
		ids := make([]ent.Value, 0, len(m.removedarchivedWorkspaceActivities))
		for id := range m.removedarchivedWorkspaceActivities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeammateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 20)
	if m.clearedworkspaces {
		edges = append(edges, teammate.EdgeWorkspaces)
	}
	if m.clearedprojects {
		edges = append(edges, teammate.EdgeProjects)
	}
	if m.clearedprojectTeammates {
		edges = append(edges, teammate.EdgeProjectTeammates)
	}
	if m.clearedworkspaceTeammates {
		edges = append(edges, teammate.EdgeWorkspaceTeammates)
	}
	if m.clearedfavoriteProjects {
		edges = append(edges, teammate.EdgeFavoriteProjects)
	}
	if m.clearedfavoriteWorkspaces {
		edges = append(edges, teammate.EdgeFavoriteWorkspaces)
	}
	if m.clearedteammateTaskTabStatuses {
		edges = append(edges, teammate.EdgeTeammateTaskTabStatuses)
	}
	if m.clearedteammateTaskColumns {
		edges = append(edges, teammate.EdgeTeammateTaskColumns)
	}
	if m.clearedteammateTaskListStatuses {
		edges = append(edges, teammate.EdgeTeammateTaskListStatuses)
	}
	if m.clearedteammateTaskSections {
		edges = append(edges, teammate.EdgeTeammateTaskSections)
	}
	if m.clearedtasks {
		edges = append(edges, teammate.EdgeTasks)
	}
	if m.clearedteammateTasks {
		edges = append(edges, teammate.EdgeTeammateTasks)
	}
	if m.clearedtaskLikes {
		edges = append(edges, teammate.EdgeTaskLikes)
	}
	if m.clearedtaskCollaborators {
		edges = append(edges, teammate.EdgeTaskCollaborators)
	}
	if m.clearedtaskFeeds {
		edges = append(edges, teammate.EdgeTaskFeeds)
	}
	if m.clearedtaskFeedLikes {
		edges = append(edges, teammate.EdgeTaskFeedLikes)
	}
	if m.clearedtaskActivities {
		edges = append(edges, teammate.EdgeTaskActivities)
	}
	if m.clearedworkspaceActivities {
		edges = append(edges, teammate.EdgeWorkspaceActivities)
	}
	if m.clearedarchivedTaskActivities {
		edges = append(edges, teammate.EdgeArchivedTaskActivities)
	}
	if m.clearedarchivedWorkspaceActivities {
		edges = append(edges, teammate.EdgeArchivedWorkspaceActivities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeammateMutation) EdgeCleared(name string) bool {
	switch name {
	case teammate.EdgeWorkspaces:
		return m.clearedworkspaces
	case teammate.EdgeProjects:
		return m.clearedprojects
	case teammate.EdgeProjectTeammates:
		return m.clearedprojectTeammates
	case teammate.EdgeWorkspaceTeammates:
		return m.clearedworkspaceTeammates
	case teammate.EdgeFavoriteProjects:
		return m.clearedfavoriteProjects
	case teammate.EdgeFavoriteWorkspaces:
		return m.clearedfavoriteWorkspaces
	case teammate.EdgeTeammateTaskTabStatuses:
		return m.clearedteammateTaskTabStatuses
	case teammate.EdgeTeammateTaskColumns:
		return m.clearedteammateTaskColumns
	case teammate.EdgeTeammateTaskListStatuses:
		return m.clearedteammateTaskListStatuses
	case teammate.EdgeTeammateTaskSections:
		return m.clearedteammateTaskSections
	case teammate.EdgeTasks:
		return m.clearedtasks
	case teammate.EdgeTeammateTasks:
		return m.clearedteammateTasks
	case teammate.EdgeTaskLikes:
		return m.clearedtaskLikes
	case teammate.EdgeTaskCollaborators:
		return m.clearedtaskCollaborators
	case teammate.EdgeTaskFeeds:
		return m.clearedtaskFeeds
	case teammate.EdgeTaskFeedLikes:
		return m.clearedtaskFeedLikes
	case teammate.EdgeTaskActivities:
		return m.clearedtaskActivities
	case teammate.EdgeWorkspaceActivities:
		return m.clearedworkspaceActivities
	case teammate.EdgeArchivedTaskActivities:
		return m.clearedarchivedTaskActivities
	case teammate.EdgeArchivedWorkspaceActivities:
		return m.clearedarchivedWorkspaceActivities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeammateMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Teammate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeammateMutation) ResetEdge(name string) error {
	switch name {
	case teammate.EdgeWorkspaces:
		m.ResetWorkspaces()
		return nil
	case teammate.EdgeProjects:
		m.ResetProjects()
		return nil
	case teammate.EdgeProjectTeammates:
		m.ResetProjectTeammates()
		return nil
	case teammate.EdgeWorkspaceTeammates:
		m.ResetWorkspaceTeammates()
		return nil
	case teammate.EdgeFavoriteProjects:
		m.ResetFavoriteProjects()
		return nil
	case teammate.EdgeFavoriteWorkspaces:
		m.ResetFavoriteWorkspaces()
		return nil
	case teammate.EdgeTeammateTaskTabStatuses:
		m.ResetTeammateTaskTabStatuses()
		return nil
	case teammate.EdgeTeammateTaskColumns:
		m.ResetTeammateTaskColumns()
		return nil
	case teammate.EdgeTeammateTaskListStatuses:
		m.ResetTeammateTaskListStatuses()
		return nil
	case teammate.EdgeTeammateTaskSections:
		m.ResetTeammateTaskSections()
		return nil
	case teammate.EdgeTasks:
		m.ResetTasks()
		return nil
	case teammate.EdgeTeammateTasks:
		m.ResetTeammateTasks()
		return nil
	case teammate.EdgeTaskLikes:
		m.ResetTaskLikes()
		return nil
	case teammate.EdgeTaskCollaborators:
		m.ResetTaskCollaborators()
		return nil
	case teammate.EdgeTaskFeeds:
		m.ResetTaskFeeds()
		return nil
	case teammate.EdgeTaskFeedLikes:
		m.ResetTaskFeedLikes()
		return nil
	case teammate.EdgeTaskActivities:
		m.ResetTaskActivities()
		return nil
	case teammate.EdgeWorkspaceActivities:
		m.ResetWorkspaceActivities()
		return nil
	case teammate.EdgeArchivedTaskActivities:
		m.ResetArchivedTaskActivities()
		return nil
	case teammate.EdgeArchivedWorkspaceActivities:
		m.ResetArchivedWorkspaceActivities()
		return nil
	}
	return fmt.Errorf("unknown Teammate edge %s", name)
}

// TeammateTaskMutation represents an operation that mutates the TeammateTask nodes in the graph.
type TeammateTaskMutation struct {
	config
	op                         Op
	typ                        string
	id                         *ulid.ID
	created_at                 *time.Time
	updated_at                 *time.Time
	clearedFields              map[string]struct{}
	teammate                   *ulid.ID
	clearedteammate            bool
	task                       *ulid.ID
	clearedtask                bool
	teammateTaskSection        *ulid.ID
	clearedteammateTaskSection bool
	workspace                  *ulid.ID
	clearedworkspace           bool
	done                       bool
	oldValue                   func(context.Context) (*TeammateTask, error)
	predicates                 []predicate.TeammateTask
}

var _ ent.Mutation = (*TeammateTaskMutation)(nil)

// teammatetaskOption allows management of the mutation configuration using functional options.
type teammatetaskOption func(*TeammateTaskMutation)

// newTeammateTaskMutation creates new mutation for the TeammateTask entity.
func newTeammateTaskMutation(c config, op Op, opts ...teammatetaskOption) *TeammateTaskMutation {
	m := &TeammateTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTeammateTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeammateTaskID sets the ID field of the mutation.
func withTeammateTaskID(id ulid.ID) teammatetaskOption {
	return func(m *TeammateTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *TeammateTask
		)
		m.oldValue = func(ctx context.Context) (*TeammateTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TeammateTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeammateTask sets the old TeammateTask of the mutation.
func withTeammateTask(node *TeammateTask) teammatetaskOption {
	return func(m *TeammateTaskMutation) {
		m.oldValue = func(context.Context) (*TeammateTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeammateTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeammateTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TeammateTask entities.
func (m *TeammateTaskMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeammateTaskMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeammateTaskMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TeammateTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTeammateID sets the "teammate_id" field.
func (m *TeammateTaskMutation) SetTeammateID(u ulid.ID) {
	m.teammate = &u
}

// TeammateID returns the value of the "teammate_id" field in the mutation.
func (m *TeammateTaskMutation) TeammateID() (r ulid.ID, exists bool) {
	v := m.teammate
	if v == nil {
		return
	}
	return *v, true
}

// OldTeammateID returns the old "teammate_id" field's value of the TeammateTask entity.
// If the TeammateTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskMutation) OldTeammateID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeammateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeammateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeammateID: %w", err)
	}
	return oldValue.TeammateID, nil
}

// ResetTeammateID resets all changes to the "teammate_id" field.
func (m *TeammateTaskMutation) ResetTeammateID() {
	m.teammate = nil
}

// SetTaskID sets the "task_id" field.
func (m *TeammateTaskMutation) SetTaskID(u ulid.ID) {
	m.task = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *TeammateTaskMutation) TaskID() (r ulid.ID, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the TeammateTask entity.
// If the TeammateTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskMutation) OldTaskID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *TeammateTaskMutation) ResetTaskID() {
	m.task = nil
}

// SetTeammateTaskSectionID sets the "teammate_task_section_id" field.
func (m *TeammateTaskMutation) SetTeammateTaskSectionID(u ulid.ID) {
	m.teammateTaskSection = &u
}

// TeammateTaskSectionID returns the value of the "teammate_task_section_id" field in the mutation.
func (m *TeammateTaskMutation) TeammateTaskSectionID() (r ulid.ID, exists bool) {
	v := m.teammateTaskSection
	if v == nil {
		return
	}
	return *v, true
}

// OldTeammateTaskSectionID returns the old "teammate_task_section_id" field's value of the TeammateTask entity.
// If the TeammateTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskMutation) OldTeammateTaskSectionID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeammateTaskSectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeammateTaskSectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeammateTaskSectionID: %w", err)
	}
	return oldValue.TeammateTaskSectionID, nil
}

// ResetTeammateTaskSectionID resets all changes to the "teammate_task_section_id" field.
func (m *TeammateTaskMutation) ResetTeammateTaskSectionID() {
	m.teammateTaskSection = nil
}

// SetWorkspaceID sets the "workspace_id" field.
func (m *TeammateTaskMutation) SetWorkspaceID(u ulid.ID) {
	m.workspace = &u
}

// WorkspaceID returns the value of the "workspace_id" field in the mutation.
func (m *TeammateTaskMutation) WorkspaceID() (r ulid.ID, exists bool) {
	v := m.workspace
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspaceID returns the old "workspace_id" field's value of the TeammateTask entity.
// If the TeammateTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskMutation) OldWorkspaceID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspaceID: %w", err)
	}
	return oldValue.WorkspaceID, nil
}

// ResetWorkspaceID resets all changes to the "workspace_id" field.
func (m *TeammateTaskMutation) ResetWorkspaceID() {
	m.workspace = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TeammateTaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeammateTaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TeammateTask entity.
// If the TeammateTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeammateTaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeammateTaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeammateTaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TeammateTask entity.
// If the TeammateTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeammateTaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTeammate clears the "teammate" edge to the Teammate entity.
func (m *TeammateTaskMutation) ClearTeammate() {
	m.clearedteammate = true
}

// TeammateCleared reports if the "teammate" edge to the Teammate entity was cleared.
func (m *TeammateTaskMutation) TeammateCleared() bool {
	return m.clearedteammate
}

// TeammateIDs returns the "teammate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeammateID instead. It exists only for internal usage by the builders.
func (m *TeammateTaskMutation) TeammateIDs() (ids []ulid.ID) {
	if id := m.teammate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeammate resets all changes to the "teammate" edge.
func (m *TeammateTaskMutation) ResetTeammate() {
	m.teammate = nil
	m.clearedteammate = false
}

// ClearTask clears the "task" edge to the Task entity.
func (m *TeammateTaskMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *TeammateTaskMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *TeammateTaskMutation) TaskIDs() (ids []ulid.ID) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *TeammateTaskMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// ClearTeammateTaskSection clears the "teammateTaskSection" edge to the TeammateTaskSection entity.
func (m *TeammateTaskMutation) ClearTeammateTaskSection() {
	m.clearedteammateTaskSection = true
}

// TeammateTaskSectionCleared reports if the "teammateTaskSection" edge to the TeammateTaskSection entity was cleared.
func (m *TeammateTaskMutation) TeammateTaskSectionCleared() bool {
	return m.clearedteammateTaskSection
}

// TeammateTaskSectionIDs returns the "teammateTaskSection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeammateTaskSectionID instead. It exists only for internal usage by the builders.
func (m *TeammateTaskMutation) TeammateTaskSectionIDs() (ids []ulid.ID) {
	if id := m.teammateTaskSection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeammateTaskSection resets all changes to the "teammateTaskSection" edge.
func (m *TeammateTaskMutation) ResetTeammateTaskSection() {
	m.teammateTaskSection = nil
	m.clearedteammateTaskSection = false
}

// ClearWorkspace clears the "workspace" edge to the Workspace entity.
func (m *TeammateTaskMutation) ClearWorkspace() {
	m.clearedworkspace = true
}

// WorkspaceCleared reports if the "workspace" edge to the Workspace entity was cleared.
func (m *TeammateTaskMutation) WorkspaceCleared() bool {
	return m.clearedworkspace
}

// WorkspaceIDs returns the "workspace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkspaceID instead. It exists only for internal usage by the builders.
func (m *TeammateTaskMutation) WorkspaceIDs() (ids []ulid.ID) {
	if id := m.workspace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkspace resets all changes to the "workspace" edge.
func (m *TeammateTaskMutation) ResetWorkspace() {
	m.workspace = nil
	m.clearedworkspace = false
}

// Where appends a list predicates to the TeammateTaskMutation builder.
func (m *TeammateTaskMutation) Where(ps ...predicate.TeammateTask) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TeammateTaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TeammateTask).
func (m *TeammateTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeammateTaskMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.teammate != nil {
		fields = append(fields, teammatetask.FieldTeammateID)
	}
	if m.task != nil {
		fields = append(fields, teammatetask.FieldTaskID)
	}
	if m.teammateTaskSection != nil {
		fields = append(fields, teammatetask.FieldTeammateTaskSectionID)
	}
	if m.workspace != nil {
		fields = append(fields, teammatetask.FieldWorkspaceID)
	}
	if m.created_at != nil {
		fields = append(fields, teammatetask.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, teammatetask.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeammateTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teammatetask.FieldTeammateID:
		return m.TeammateID()
	case teammatetask.FieldTaskID:
		return m.TaskID()
	case teammatetask.FieldTeammateTaskSectionID:
		return m.TeammateTaskSectionID()
	case teammatetask.FieldWorkspaceID:
		return m.WorkspaceID()
	case teammatetask.FieldCreatedAt:
		return m.CreatedAt()
	case teammatetask.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeammateTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teammatetask.FieldTeammateID:
		return m.OldTeammateID(ctx)
	case teammatetask.FieldTaskID:
		return m.OldTaskID(ctx)
	case teammatetask.FieldTeammateTaskSectionID:
		return m.OldTeammateTaskSectionID(ctx)
	case teammatetask.FieldWorkspaceID:
		return m.OldWorkspaceID(ctx)
	case teammatetask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case teammatetask.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TeammateTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeammateTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teammatetask.FieldTeammateID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeammateID(v)
		return nil
	case teammatetask.FieldTaskID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case teammatetask.FieldTeammateTaskSectionID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeammateTaskSectionID(v)
		return nil
	case teammatetask.FieldWorkspaceID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspaceID(v)
		return nil
	case teammatetask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case teammatetask.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TeammateTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeammateTaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeammateTaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeammateTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TeammateTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeammateTaskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeammateTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeammateTaskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TeammateTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeammateTaskMutation) ResetField(name string) error {
	switch name {
	case teammatetask.FieldTeammateID:
		m.ResetTeammateID()
		return nil
	case teammatetask.FieldTaskID:
		m.ResetTaskID()
		return nil
	case teammatetask.FieldTeammateTaskSectionID:
		m.ResetTeammateTaskSectionID()
		return nil
	case teammatetask.FieldWorkspaceID:
		m.ResetWorkspaceID()
		return nil
	case teammatetask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case teammatetask.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TeammateTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeammateTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.teammate != nil {
		edges = append(edges, teammatetask.EdgeTeammate)
	}
	if m.task != nil {
		edges = append(edges, teammatetask.EdgeTask)
	}
	if m.teammateTaskSection != nil {
		edges = append(edges, teammatetask.EdgeTeammateTaskSection)
	}
	if m.workspace != nil {
		edges = append(edges, teammatetask.EdgeWorkspace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeammateTaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teammatetask.EdgeTeammate:
		if id := m.teammate; id != nil {
			return []ent.Value{*id}
		}
	case teammatetask.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case teammatetask.EdgeTeammateTaskSection:
		if id := m.teammateTaskSection; id != nil {
			return []ent.Value{*id}
		}
	case teammatetask.EdgeWorkspace:
		if id := m.workspace; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeammateTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeammateTaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeammateTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedteammate {
		edges = append(edges, teammatetask.EdgeTeammate)
	}
	if m.clearedtask {
		edges = append(edges, teammatetask.EdgeTask)
	}
	if m.clearedteammateTaskSection {
		edges = append(edges, teammatetask.EdgeTeammateTaskSection)
	}
	if m.clearedworkspace {
		edges = append(edges, teammatetask.EdgeWorkspace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeammateTaskMutation) EdgeCleared(name string) bool {
	switch name {
	case teammatetask.EdgeTeammate:
		return m.clearedteammate
	case teammatetask.EdgeTask:
		return m.clearedtask
	case teammatetask.EdgeTeammateTaskSection:
		return m.clearedteammateTaskSection
	case teammatetask.EdgeWorkspace:
		return m.clearedworkspace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeammateTaskMutation) ClearEdge(name string) error {
	switch name {
	case teammatetask.EdgeTeammate:
		m.ClearTeammate()
		return nil
	case teammatetask.EdgeTask:
		m.ClearTask()
		return nil
	case teammatetask.EdgeTeammateTaskSection:
		m.ClearTeammateTaskSection()
		return nil
	case teammatetask.EdgeWorkspace:
		m.ClearWorkspace()
		return nil
	}
	return fmt.Errorf("unknown TeammateTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeammateTaskMutation) ResetEdge(name string) error {
	switch name {
	case teammatetask.EdgeTeammate:
		m.ResetTeammate()
		return nil
	case teammatetask.EdgeTask:
		m.ResetTask()
		return nil
	case teammatetask.EdgeTeammateTaskSection:
		m.ResetTeammateTaskSection()
		return nil
	case teammatetask.EdgeWorkspace:
		m.ResetWorkspace()
		return nil
	}
	return fmt.Errorf("unknown TeammateTask edge %s", name)
}

// TeammateTaskColumnMutation represents an operation that mutates the TeammateTaskColumn nodes in the graph.
type TeammateTaskColumnMutation struct {
	config
	op                Op
	typ               string
	id                *ulid.ID
	width             *string
	disabled          *bool
	customizable      *bool
	_order            *int
	add_order         *int
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	teammate          *ulid.ID
	clearedteammate   bool
	workspace         *ulid.ID
	clearedworkspace  bool
	taskColumn        *ulid.ID
	clearedtaskColumn bool
	done              bool
	oldValue          func(context.Context) (*TeammateTaskColumn, error)
	predicates        []predicate.TeammateTaskColumn
}

var _ ent.Mutation = (*TeammateTaskColumnMutation)(nil)

// teammatetaskcolumnOption allows management of the mutation configuration using functional options.
type teammatetaskcolumnOption func(*TeammateTaskColumnMutation)

// newTeammateTaskColumnMutation creates new mutation for the TeammateTaskColumn entity.
func newTeammateTaskColumnMutation(c config, op Op, opts ...teammatetaskcolumnOption) *TeammateTaskColumnMutation {
	m := &TeammateTaskColumnMutation{
		config:        c,
		op:            op,
		typ:           TypeTeammateTaskColumn,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeammateTaskColumnID sets the ID field of the mutation.
func withTeammateTaskColumnID(id ulid.ID) teammatetaskcolumnOption {
	return func(m *TeammateTaskColumnMutation) {
		var (
			err   error
			once  sync.Once
			value *TeammateTaskColumn
		)
		m.oldValue = func(ctx context.Context) (*TeammateTaskColumn, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TeammateTaskColumn.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeammateTaskColumn sets the old TeammateTaskColumn of the mutation.
func withTeammateTaskColumn(node *TeammateTaskColumn) teammatetaskcolumnOption {
	return func(m *TeammateTaskColumnMutation) {
		m.oldValue = func(context.Context) (*TeammateTaskColumn, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeammateTaskColumnMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeammateTaskColumnMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TeammateTaskColumn entities.
func (m *TeammateTaskColumnMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeammateTaskColumnMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeammateTaskColumnMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TeammateTaskColumn.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTeammateID sets the "teammate_id" field.
func (m *TeammateTaskColumnMutation) SetTeammateID(u ulid.ID) {
	m.teammate = &u
}

// TeammateID returns the value of the "teammate_id" field in the mutation.
func (m *TeammateTaskColumnMutation) TeammateID() (r ulid.ID, exists bool) {
	v := m.teammate
	if v == nil {
		return
	}
	return *v, true
}

// OldTeammateID returns the old "teammate_id" field's value of the TeammateTaskColumn entity.
// If the TeammateTaskColumn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskColumnMutation) OldTeammateID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeammateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeammateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeammateID: %w", err)
	}
	return oldValue.TeammateID, nil
}

// ResetTeammateID resets all changes to the "teammate_id" field.
func (m *TeammateTaskColumnMutation) ResetTeammateID() {
	m.teammate = nil
}

// SetTaskColumnID sets the "task_column_id" field.
func (m *TeammateTaskColumnMutation) SetTaskColumnID(u ulid.ID) {
	m.taskColumn = &u
}

// TaskColumnID returns the value of the "task_column_id" field in the mutation.
func (m *TeammateTaskColumnMutation) TaskColumnID() (r ulid.ID, exists bool) {
	v := m.taskColumn
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskColumnID returns the old "task_column_id" field's value of the TeammateTaskColumn entity.
// If the TeammateTaskColumn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskColumnMutation) OldTaskColumnID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskColumnID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskColumnID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskColumnID: %w", err)
	}
	return oldValue.TaskColumnID, nil
}

// ResetTaskColumnID resets all changes to the "task_column_id" field.
func (m *TeammateTaskColumnMutation) ResetTaskColumnID() {
	m.taskColumn = nil
}

// SetWorkspaceID sets the "workspace_id" field.
func (m *TeammateTaskColumnMutation) SetWorkspaceID(u ulid.ID) {
	m.workspace = &u
}

// WorkspaceID returns the value of the "workspace_id" field in the mutation.
func (m *TeammateTaskColumnMutation) WorkspaceID() (r ulid.ID, exists bool) {
	v := m.workspace
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspaceID returns the old "workspace_id" field's value of the TeammateTaskColumn entity.
// If the TeammateTaskColumn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskColumnMutation) OldWorkspaceID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspaceID: %w", err)
	}
	return oldValue.WorkspaceID, nil
}

// ResetWorkspaceID resets all changes to the "workspace_id" field.
func (m *TeammateTaskColumnMutation) ResetWorkspaceID() {
	m.workspace = nil
}

// SetWidth sets the "width" field.
func (m *TeammateTaskColumnMutation) SetWidth(s string) {
	m.width = &s
}

// Width returns the value of the "width" field in the mutation.
func (m *TeammateTaskColumnMutation) Width() (r string, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the TeammateTaskColumn entity.
// If the TeammateTaskColumn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskColumnMutation) OldWidth(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// ResetWidth resets all changes to the "width" field.
func (m *TeammateTaskColumnMutation) ResetWidth() {
	m.width = nil
}

// SetDisabled sets the "disabled" field.
func (m *TeammateTaskColumnMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *TeammateTaskColumnMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the TeammateTaskColumn entity.
// If the TeammateTaskColumn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskColumnMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *TeammateTaskColumnMutation) ResetDisabled() {
	m.disabled = nil
}

// SetCustomizable sets the "customizable" field.
func (m *TeammateTaskColumnMutation) SetCustomizable(b bool) {
	m.customizable = &b
}

// Customizable returns the value of the "customizable" field in the mutation.
func (m *TeammateTaskColumnMutation) Customizable() (r bool, exists bool) {
	v := m.customizable
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomizable returns the old "customizable" field's value of the TeammateTaskColumn entity.
// If the TeammateTaskColumn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskColumnMutation) OldCustomizable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomizable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomizable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomizable: %w", err)
	}
	return oldValue.Customizable, nil
}

// ResetCustomizable resets all changes to the "customizable" field.
func (m *TeammateTaskColumnMutation) ResetCustomizable() {
	m.customizable = nil
}

// SetOrder sets the "order" field.
func (m *TeammateTaskColumnMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *TeammateTaskColumnMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the TeammateTaskColumn entity.
// If the TeammateTaskColumn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskColumnMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *TeammateTaskColumnMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *TeammateTaskColumnMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *TeammateTaskColumnMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TeammateTaskColumnMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeammateTaskColumnMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TeammateTaskColumn entity.
// If the TeammateTaskColumn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskColumnMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeammateTaskColumnMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeammateTaskColumnMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeammateTaskColumnMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TeammateTaskColumn entity.
// If the TeammateTaskColumn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskColumnMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeammateTaskColumnMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTeammate clears the "teammate" edge to the Teammate entity.
func (m *TeammateTaskColumnMutation) ClearTeammate() {
	m.clearedteammate = true
}

// TeammateCleared reports if the "teammate" edge to the Teammate entity was cleared.
func (m *TeammateTaskColumnMutation) TeammateCleared() bool {
	return m.clearedteammate
}

// TeammateIDs returns the "teammate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeammateID instead. It exists only for internal usage by the builders.
func (m *TeammateTaskColumnMutation) TeammateIDs() (ids []ulid.ID) {
	if id := m.teammate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeammate resets all changes to the "teammate" edge.
func (m *TeammateTaskColumnMutation) ResetTeammate() {
	m.teammate = nil
	m.clearedteammate = false
}

// ClearWorkspace clears the "workspace" edge to the Workspace entity.
func (m *TeammateTaskColumnMutation) ClearWorkspace() {
	m.clearedworkspace = true
}

// WorkspaceCleared reports if the "workspace" edge to the Workspace entity was cleared.
func (m *TeammateTaskColumnMutation) WorkspaceCleared() bool {
	return m.clearedworkspace
}

// WorkspaceIDs returns the "workspace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkspaceID instead. It exists only for internal usage by the builders.
func (m *TeammateTaskColumnMutation) WorkspaceIDs() (ids []ulid.ID) {
	if id := m.workspace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkspace resets all changes to the "workspace" edge.
func (m *TeammateTaskColumnMutation) ResetWorkspace() {
	m.workspace = nil
	m.clearedworkspace = false
}

// ClearTaskColumn clears the "taskColumn" edge to the TaskColumn entity.
func (m *TeammateTaskColumnMutation) ClearTaskColumn() {
	m.clearedtaskColumn = true
}

// TaskColumnCleared reports if the "taskColumn" edge to the TaskColumn entity was cleared.
func (m *TeammateTaskColumnMutation) TaskColumnCleared() bool {
	return m.clearedtaskColumn
}

// TaskColumnIDs returns the "taskColumn" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskColumnID instead. It exists only for internal usage by the builders.
func (m *TeammateTaskColumnMutation) TaskColumnIDs() (ids []ulid.ID) {
	if id := m.taskColumn; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTaskColumn resets all changes to the "taskColumn" edge.
func (m *TeammateTaskColumnMutation) ResetTaskColumn() {
	m.taskColumn = nil
	m.clearedtaskColumn = false
}

// Where appends a list predicates to the TeammateTaskColumnMutation builder.
func (m *TeammateTaskColumnMutation) Where(ps ...predicate.TeammateTaskColumn) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TeammateTaskColumnMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TeammateTaskColumn).
func (m *TeammateTaskColumnMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeammateTaskColumnMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.teammate != nil {
		fields = append(fields, teammatetaskcolumn.FieldTeammateID)
	}
	if m.taskColumn != nil {
		fields = append(fields, teammatetaskcolumn.FieldTaskColumnID)
	}
	if m.workspace != nil {
		fields = append(fields, teammatetaskcolumn.FieldWorkspaceID)
	}
	if m.width != nil {
		fields = append(fields, teammatetaskcolumn.FieldWidth)
	}
	if m.disabled != nil {
		fields = append(fields, teammatetaskcolumn.FieldDisabled)
	}
	if m.customizable != nil {
		fields = append(fields, teammatetaskcolumn.FieldCustomizable)
	}
	if m._order != nil {
		fields = append(fields, teammatetaskcolumn.FieldOrder)
	}
	if m.created_at != nil {
		fields = append(fields, teammatetaskcolumn.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, teammatetaskcolumn.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeammateTaskColumnMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teammatetaskcolumn.FieldTeammateID:
		return m.TeammateID()
	case teammatetaskcolumn.FieldTaskColumnID:
		return m.TaskColumnID()
	case teammatetaskcolumn.FieldWorkspaceID:
		return m.WorkspaceID()
	case teammatetaskcolumn.FieldWidth:
		return m.Width()
	case teammatetaskcolumn.FieldDisabled:
		return m.Disabled()
	case teammatetaskcolumn.FieldCustomizable:
		return m.Customizable()
	case teammatetaskcolumn.FieldOrder:
		return m.Order()
	case teammatetaskcolumn.FieldCreatedAt:
		return m.CreatedAt()
	case teammatetaskcolumn.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeammateTaskColumnMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teammatetaskcolumn.FieldTeammateID:
		return m.OldTeammateID(ctx)
	case teammatetaskcolumn.FieldTaskColumnID:
		return m.OldTaskColumnID(ctx)
	case teammatetaskcolumn.FieldWorkspaceID:
		return m.OldWorkspaceID(ctx)
	case teammatetaskcolumn.FieldWidth:
		return m.OldWidth(ctx)
	case teammatetaskcolumn.FieldDisabled:
		return m.OldDisabled(ctx)
	case teammatetaskcolumn.FieldCustomizable:
		return m.OldCustomizable(ctx)
	case teammatetaskcolumn.FieldOrder:
		return m.OldOrder(ctx)
	case teammatetaskcolumn.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case teammatetaskcolumn.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TeammateTaskColumn field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeammateTaskColumnMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teammatetaskcolumn.FieldTeammateID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeammateID(v)
		return nil
	case teammatetaskcolumn.FieldTaskColumnID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskColumnID(v)
		return nil
	case teammatetaskcolumn.FieldWorkspaceID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspaceID(v)
		return nil
	case teammatetaskcolumn.FieldWidth:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case teammatetaskcolumn.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case teammatetaskcolumn.FieldCustomizable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomizable(v)
		return nil
	case teammatetaskcolumn.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case teammatetaskcolumn.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case teammatetaskcolumn.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TeammateTaskColumn field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeammateTaskColumnMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, teammatetaskcolumn.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeammateTaskColumnMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case teammatetaskcolumn.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeammateTaskColumnMutation) AddField(name string, value ent.Value) error {
	switch name {
	case teammatetaskcolumn.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown TeammateTaskColumn numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeammateTaskColumnMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeammateTaskColumnMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeammateTaskColumnMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TeammateTaskColumn nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeammateTaskColumnMutation) ResetField(name string) error {
	switch name {
	case teammatetaskcolumn.FieldTeammateID:
		m.ResetTeammateID()
		return nil
	case teammatetaskcolumn.FieldTaskColumnID:
		m.ResetTaskColumnID()
		return nil
	case teammatetaskcolumn.FieldWorkspaceID:
		m.ResetWorkspaceID()
		return nil
	case teammatetaskcolumn.FieldWidth:
		m.ResetWidth()
		return nil
	case teammatetaskcolumn.FieldDisabled:
		m.ResetDisabled()
		return nil
	case teammatetaskcolumn.FieldCustomizable:
		m.ResetCustomizable()
		return nil
	case teammatetaskcolumn.FieldOrder:
		m.ResetOrder()
		return nil
	case teammatetaskcolumn.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case teammatetaskcolumn.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TeammateTaskColumn field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeammateTaskColumnMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.teammate != nil {
		edges = append(edges, teammatetaskcolumn.EdgeTeammate)
	}
	if m.workspace != nil {
		edges = append(edges, teammatetaskcolumn.EdgeWorkspace)
	}
	if m.taskColumn != nil {
		edges = append(edges, teammatetaskcolumn.EdgeTaskColumn)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeammateTaskColumnMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teammatetaskcolumn.EdgeTeammate:
		if id := m.teammate; id != nil {
			return []ent.Value{*id}
		}
	case teammatetaskcolumn.EdgeWorkspace:
		if id := m.workspace; id != nil {
			return []ent.Value{*id}
		}
	case teammatetaskcolumn.EdgeTaskColumn:
		if id := m.taskColumn; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeammateTaskColumnMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeammateTaskColumnMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeammateTaskColumnMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedteammate {
		edges = append(edges, teammatetaskcolumn.EdgeTeammate)
	}
	if m.clearedworkspace {
		edges = append(edges, teammatetaskcolumn.EdgeWorkspace)
	}
	if m.clearedtaskColumn {
		edges = append(edges, teammatetaskcolumn.EdgeTaskColumn)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeammateTaskColumnMutation) EdgeCleared(name string) bool {
	switch name {
	case teammatetaskcolumn.EdgeTeammate:
		return m.clearedteammate
	case teammatetaskcolumn.EdgeWorkspace:
		return m.clearedworkspace
	case teammatetaskcolumn.EdgeTaskColumn:
		return m.clearedtaskColumn
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeammateTaskColumnMutation) ClearEdge(name string) error {
	switch name {
	case teammatetaskcolumn.EdgeTeammate:
		m.ClearTeammate()
		return nil
	case teammatetaskcolumn.EdgeWorkspace:
		m.ClearWorkspace()
		return nil
	case teammatetaskcolumn.EdgeTaskColumn:
		m.ClearTaskColumn()
		return nil
	}
	return fmt.Errorf("unknown TeammateTaskColumn unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeammateTaskColumnMutation) ResetEdge(name string) error {
	switch name {
	case teammatetaskcolumn.EdgeTeammate:
		m.ResetTeammate()
		return nil
	case teammatetaskcolumn.EdgeWorkspace:
		m.ResetWorkspace()
		return nil
	case teammatetaskcolumn.EdgeTaskColumn:
		m.ResetTaskColumn()
		return nil
	}
	return fmt.Errorf("unknown TeammateTaskColumn edge %s", name)
}

// TeammateTaskListStatusMutation represents an operation that mutates the TeammateTaskListStatus nodes in the graph.
type TeammateTaskListStatusMutation struct {
	config
	op                             Op
	typ                            string
	id                             *ulid.ID
	created_at                     *time.Time
	updated_at                     *time.Time
	clearedFields                  map[string]struct{}
	workspace                      *ulid.ID
	clearedworkspace               bool
	teammate                       *ulid.ID
	clearedteammate                bool
	taskListCompletedStatus        *ulid.ID
	clearedtaskListCompletedStatus bool
	taskListSortStatus             *ulid.ID
	clearedtaskListSortStatus      bool
	done                           bool
	oldValue                       func(context.Context) (*TeammateTaskListStatus, error)
	predicates                     []predicate.TeammateTaskListStatus
}

var _ ent.Mutation = (*TeammateTaskListStatusMutation)(nil)

// teammatetaskliststatusOption allows management of the mutation configuration using functional options.
type teammatetaskliststatusOption func(*TeammateTaskListStatusMutation)

// newTeammateTaskListStatusMutation creates new mutation for the TeammateTaskListStatus entity.
func newTeammateTaskListStatusMutation(c config, op Op, opts ...teammatetaskliststatusOption) *TeammateTaskListStatusMutation {
	m := &TeammateTaskListStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeTeammateTaskListStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeammateTaskListStatusID sets the ID field of the mutation.
func withTeammateTaskListStatusID(id ulid.ID) teammatetaskliststatusOption {
	return func(m *TeammateTaskListStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *TeammateTaskListStatus
		)
		m.oldValue = func(ctx context.Context) (*TeammateTaskListStatus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TeammateTaskListStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeammateTaskListStatus sets the old TeammateTaskListStatus of the mutation.
func withTeammateTaskListStatus(node *TeammateTaskListStatus) teammatetaskliststatusOption {
	return func(m *TeammateTaskListStatusMutation) {
		m.oldValue = func(context.Context) (*TeammateTaskListStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeammateTaskListStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeammateTaskListStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TeammateTaskListStatus entities.
func (m *TeammateTaskListStatusMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeammateTaskListStatusMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeammateTaskListStatusMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TeammateTaskListStatus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkspaceID sets the "workspace_id" field.
func (m *TeammateTaskListStatusMutation) SetWorkspaceID(u ulid.ID) {
	m.workspace = &u
}

// WorkspaceID returns the value of the "workspace_id" field in the mutation.
func (m *TeammateTaskListStatusMutation) WorkspaceID() (r ulid.ID, exists bool) {
	v := m.workspace
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspaceID returns the old "workspace_id" field's value of the TeammateTaskListStatus entity.
// If the TeammateTaskListStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskListStatusMutation) OldWorkspaceID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspaceID: %w", err)
	}
	return oldValue.WorkspaceID, nil
}

// ResetWorkspaceID resets all changes to the "workspace_id" field.
func (m *TeammateTaskListStatusMutation) ResetWorkspaceID() {
	m.workspace = nil
}

// SetTeammateID sets the "teammate_id" field.
func (m *TeammateTaskListStatusMutation) SetTeammateID(u ulid.ID) {
	m.teammate = &u
}

// TeammateID returns the value of the "teammate_id" field in the mutation.
func (m *TeammateTaskListStatusMutation) TeammateID() (r ulid.ID, exists bool) {
	v := m.teammate
	if v == nil {
		return
	}
	return *v, true
}

// OldTeammateID returns the old "teammate_id" field's value of the TeammateTaskListStatus entity.
// If the TeammateTaskListStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskListStatusMutation) OldTeammateID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeammateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeammateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeammateID: %w", err)
	}
	return oldValue.TeammateID, nil
}

// ResetTeammateID resets all changes to the "teammate_id" field.
func (m *TeammateTaskListStatusMutation) ResetTeammateID() {
	m.teammate = nil
}

// SetTaskListCompletedStatusID sets the "task_list_completed_status_id" field.
func (m *TeammateTaskListStatusMutation) SetTaskListCompletedStatusID(u ulid.ID) {
	m.taskListCompletedStatus = &u
}

// TaskListCompletedStatusID returns the value of the "task_list_completed_status_id" field in the mutation.
func (m *TeammateTaskListStatusMutation) TaskListCompletedStatusID() (r ulid.ID, exists bool) {
	v := m.taskListCompletedStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskListCompletedStatusID returns the old "task_list_completed_status_id" field's value of the TeammateTaskListStatus entity.
// If the TeammateTaskListStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskListStatusMutation) OldTaskListCompletedStatusID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskListCompletedStatusID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskListCompletedStatusID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskListCompletedStatusID: %w", err)
	}
	return oldValue.TaskListCompletedStatusID, nil
}

// ResetTaskListCompletedStatusID resets all changes to the "task_list_completed_status_id" field.
func (m *TeammateTaskListStatusMutation) ResetTaskListCompletedStatusID() {
	m.taskListCompletedStatus = nil
}

// SetTaskListSortStatusID sets the "task_list_sort_status_id" field.
func (m *TeammateTaskListStatusMutation) SetTaskListSortStatusID(u ulid.ID) {
	m.taskListSortStatus = &u
}

// TaskListSortStatusID returns the value of the "task_list_sort_status_id" field in the mutation.
func (m *TeammateTaskListStatusMutation) TaskListSortStatusID() (r ulid.ID, exists bool) {
	v := m.taskListSortStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskListSortStatusID returns the old "task_list_sort_status_id" field's value of the TeammateTaskListStatus entity.
// If the TeammateTaskListStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskListStatusMutation) OldTaskListSortStatusID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskListSortStatusID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskListSortStatusID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskListSortStatusID: %w", err)
	}
	return oldValue.TaskListSortStatusID, nil
}

// ResetTaskListSortStatusID resets all changes to the "task_list_sort_status_id" field.
func (m *TeammateTaskListStatusMutation) ResetTaskListSortStatusID() {
	m.taskListSortStatus = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TeammateTaskListStatusMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeammateTaskListStatusMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TeammateTaskListStatus entity.
// If the TeammateTaskListStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskListStatusMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeammateTaskListStatusMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeammateTaskListStatusMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeammateTaskListStatusMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TeammateTaskListStatus entity.
// If the TeammateTaskListStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskListStatusMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeammateTaskListStatusMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearWorkspace clears the "workspace" edge to the Workspace entity.
func (m *TeammateTaskListStatusMutation) ClearWorkspace() {
	m.clearedworkspace = true
}

// WorkspaceCleared reports if the "workspace" edge to the Workspace entity was cleared.
func (m *TeammateTaskListStatusMutation) WorkspaceCleared() bool {
	return m.clearedworkspace
}

// WorkspaceIDs returns the "workspace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkspaceID instead. It exists only for internal usage by the builders.
func (m *TeammateTaskListStatusMutation) WorkspaceIDs() (ids []ulid.ID) {
	if id := m.workspace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkspace resets all changes to the "workspace" edge.
func (m *TeammateTaskListStatusMutation) ResetWorkspace() {
	m.workspace = nil
	m.clearedworkspace = false
}

// ClearTeammate clears the "teammate" edge to the Teammate entity.
func (m *TeammateTaskListStatusMutation) ClearTeammate() {
	m.clearedteammate = true
}

// TeammateCleared reports if the "teammate" edge to the Teammate entity was cleared.
func (m *TeammateTaskListStatusMutation) TeammateCleared() bool {
	return m.clearedteammate
}

// TeammateIDs returns the "teammate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeammateID instead. It exists only for internal usage by the builders.
func (m *TeammateTaskListStatusMutation) TeammateIDs() (ids []ulid.ID) {
	if id := m.teammate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeammate resets all changes to the "teammate" edge.
func (m *TeammateTaskListStatusMutation) ResetTeammate() {
	m.teammate = nil
	m.clearedteammate = false
}

// ClearTaskListCompletedStatus clears the "taskListCompletedStatus" edge to the TaskListCompletedStatus entity.
func (m *TeammateTaskListStatusMutation) ClearTaskListCompletedStatus() {
	m.clearedtaskListCompletedStatus = true
}

// TaskListCompletedStatusCleared reports if the "taskListCompletedStatus" edge to the TaskListCompletedStatus entity was cleared.
func (m *TeammateTaskListStatusMutation) TaskListCompletedStatusCleared() bool {
	return m.clearedtaskListCompletedStatus
}

// TaskListCompletedStatusIDs returns the "taskListCompletedStatus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskListCompletedStatusID instead. It exists only for internal usage by the builders.
func (m *TeammateTaskListStatusMutation) TaskListCompletedStatusIDs() (ids []ulid.ID) {
	if id := m.taskListCompletedStatus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTaskListCompletedStatus resets all changes to the "taskListCompletedStatus" edge.
func (m *TeammateTaskListStatusMutation) ResetTaskListCompletedStatus() {
	m.taskListCompletedStatus = nil
	m.clearedtaskListCompletedStatus = false
}

// ClearTaskListSortStatus clears the "taskListSortStatus" edge to the TaskListSortStatus entity.
func (m *TeammateTaskListStatusMutation) ClearTaskListSortStatus() {
	m.clearedtaskListSortStatus = true
}

// TaskListSortStatusCleared reports if the "taskListSortStatus" edge to the TaskListSortStatus entity was cleared.
func (m *TeammateTaskListStatusMutation) TaskListSortStatusCleared() bool {
	return m.clearedtaskListSortStatus
}

// TaskListSortStatusIDs returns the "taskListSortStatus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskListSortStatusID instead. It exists only for internal usage by the builders.
func (m *TeammateTaskListStatusMutation) TaskListSortStatusIDs() (ids []ulid.ID) {
	if id := m.taskListSortStatus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTaskListSortStatus resets all changes to the "taskListSortStatus" edge.
func (m *TeammateTaskListStatusMutation) ResetTaskListSortStatus() {
	m.taskListSortStatus = nil
	m.clearedtaskListSortStatus = false
}

// Where appends a list predicates to the TeammateTaskListStatusMutation builder.
func (m *TeammateTaskListStatusMutation) Where(ps ...predicate.TeammateTaskListStatus) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TeammateTaskListStatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TeammateTaskListStatus).
func (m *TeammateTaskListStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeammateTaskListStatusMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.workspace != nil {
		fields = append(fields, teammatetaskliststatus.FieldWorkspaceID)
	}
	if m.teammate != nil {
		fields = append(fields, teammatetaskliststatus.FieldTeammateID)
	}
	if m.taskListCompletedStatus != nil {
		fields = append(fields, teammatetaskliststatus.FieldTaskListCompletedStatusID)
	}
	if m.taskListSortStatus != nil {
		fields = append(fields, teammatetaskliststatus.FieldTaskListSortStatusID)
	}
	if m.created_at != nil {
		fields = append(fields, teammatetaskliststatus.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, teammatetaskliststatus.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeammateTaskListStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teammatetaskliststatus.FieldWorkspaceID:
		return m.WorkspaceID()
	case teammatetaskliststatus.FieldTeammateID:
		return m.TeammateID()
	case teammatetaskliststatus.FieldTaskListCompletedStatusID:
		return m.TaskListCompletedStatusID()
	case teammatetaskliststatus.FieldTaskListSortStatusID:
		return m.TaskListSortStatusID()
	case teammatetaskliststatus.FieldCreatedAt:
		return m.CreatedAt()
	case teammatetaskliststatus.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeammateTaskListStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teammatetaskliststatus.FieldWorkspaceID:
		return m.OldWorkspaceID(ctx)
	case teammatetaskliststatus.FieldTeammateID:
		return m.OldTeammateID(ctx)
	case teammatetaskliststatus.FieldTaskListCompletedStatusID:
		return m.OldTaskListCompletedStatusID(ctx)
	case teammatetaskliststatus.FieldTaskListSortStatusID:
		return m.OldTaskListSortStatusID(ctx)
	case teammatetaskliststatus.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case teammatetaskliststatus.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TeammateTaskListStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeammateTaskListStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teammatetaskliststatus.FieldWorkspaceID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspaceID(v)
		return nil
	case teammatetaskliststatus.FieldTeammateID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeammateID(v)
		return nil
	case teammatetaskliststatus.FieldTaskListCompletedStatusID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskListCompletedStatusID(v)
		return nil
	case teammatetaskliststatus.FieldTaskListSortStatusID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskListSortStatusID(v)
		return nil
	case teammatetaskliststatus.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case teammatetaskliststatus.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TeammateTaskListStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeammateTaskListStatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeammateTaskListStatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeammateTaskListStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TeammateTaskListStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeammateTaskListStatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeammateTaskListStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeammateTaskListStatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TeammateTaskListStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeammateTaskListStatusMutation) ResetField(name string) error {
	switch name {
	case teammatetaskliststatus.FieldWorkspaceID:
		m.ResetWorkspaceID()
		return nil
	case teammatetaskliststatus.FieldTeammateID:
		m.ResetTeammateID()
		return nil
	case teammatetaskliststatus.FieldTaskListCompletedStatusID:
		m.ResetTaskListCompletedStatusID()
		return nil
	case teammatetaskliststatus.FieldTaskListSortStatusID:
		m.ResetTaskListSortStatusID()
		return nil
	case teammatetaskliststatus.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case teammatetaskliststatus.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TeammateTaskListStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeammateTaskListStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.workspace != nil {
		edges = append(edges, teammatetaskliststatus.EdgeWorkspace)
	}
	if m.teammate != nil {
		edges = append(edges, teammatetaskliststatus.EdgeTeammate)
	}
	if m.taskListCompletedStatus != nil {
		edges = append(edges, teammatetaskliststatus.EdgeTaskListCompletedStatus)
	}
	if m.taskListSortStatus != nil {
		edges = append(edges, teammatetaskliststatus.EdgeTaskListSortStatus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeammateTaskListStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teammatetaskliststatus.EdgeWorkspace:
		if id := m.workspace; id != nil {
			return []ent.Value{*id}
		}
	case teammatetaskliststatus.EdgeTeammate:
		if id := m.teammate; id != nil {
			return []ent.Value{*id}
		}
	case teammatetaskliststatus.EdgeTaskListCompletedStatus:
		if id := m.taskListCompletedStatus; id != nil {
			return []ent.Value{*id}
		}
	case teammatetaskliststatus.EdgeTaskListSortStatus:
		if id := m.taskListSortStatus; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeammateTaskListStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeammateTaskListStatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeammateTaskListStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedworkspace {
		edges = append(edges, teammatetaskliststatus.EdgeWorkspace)
	}
	if m.clearedteammate {
		edges = append(edges, teammatetaskliststatus.EdgeTeammate)
	}
	if m.clearedtaskListCompletedStatus {
		edges = append(edges, teammatetaskliststatus.EdgeTaskListCompletedStatus)
	}
	if m.clearedtaskListSortStatus {
		edges = append(edges, teammatetaskliststatus.EdgeTaskListSortStatus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeammateTaskListStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case teammatetaskliststatus.EdgeWorkspace:
		return m.clearedworkspace
	case teammatetaskliststatus.EdgeTeammate:
		return m.clearedteammate
	case teammatetaskliststatus.EdgeTaskListCompletedStatus:
		return m.clearedtaskListCompletedStatus
	case teammatetaskliststatus.EdgeTaskListSortStatus:
		return m.clearedtaskListSortStatus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeammateTaskListStatusMutation) ClearEdge(name string) error {
	switch name {
	case teammatetaskliststatus.EdgeWorkspace:
		m.ClearWorkspace()
		return nil
	case teammatetaskliststatus.EdgeTeammate:
		m.ClearTeammate()
		return nil
	case teammatetaskliststatus.EdgeTaskListCompletedStatus:
		m.ClearTaskListCompletedStatus()
		return nil
	case teammatetaskliststatus.EdgeTaskListSortStatus:
		m.ClearTaskListSortStatus()
		return nil
	}
	return fmt.Errorf("unknown TeammateTaskListStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeammateTaskListStatusMutation) ResetEdge(name string) error {
	switch name {
	case teammatetaskliststatus.EdgeWorkspace:
		m.ResetWorkspace()
		return nil
	case teammatetaskliststatus.EdgeTeammate:
		m.ResetTeammate()
		return nil
	case teammatetaskliststatus.EdgeTaskListCompletedStatus:
		m.ResetTaskListCompletedStatus()
		return nil
	case teammatetaskliststatus.EdgeTaskListSortStatus:
		m.ResetTaskListSortStatus()
		return nil
	}
	return fmt.Errorf("unknown TeammateTaskListStatus edge %s", name)
}

// TeammateTaskSectionMutation represents an operation that mutates the TeammateTaskSection nodes in the graph.
type TeammateTaskSectionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *ulid.ID
	name                 *string
	assigned             *bool
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	teammate             *ulid.ID
	clearedteammate      bool
	workspace            *ulid.ID
	clearedworkspace     bool
	teammateTasks        map[ulid.ID]struct{}
	removedteammateTasks map[ulid.ID]struct{}
	clearedteammateTasks bool
	done                 bool
	oldValue             func(context.Context) (*TeammateTaskSection, error)
	predicates           []predicate.TeammateTaskSection
}

var _ ent.Mutation = (*TeammateTaskSectionMutation)(nil)

// teammatetasksectionOption allows management of the mutation configuration using functional options.
type teammatetasksectionOption func(*TeammateTaskSectionMutation)

// newTeammateTaskSectionMutation creates new mutation for the TeammateTaskSection entity.
func newTeammateTaskSectionMutation(c config, op Op, opts ...teammatetasksectionOption) *TeammateTaskSectionMutation {
	m := &TeammateTaskSectionMutation{
		config:        c,
		op:            op,
		typ:           TypeTeammateTaskSection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeammateTaskSectionID sets the ID field of the mutation.
func withTeammateTaskSectionID(id ulid.ID) teammatetasksectionOption {
	return func(m *TeammateTaskSectionMutation) {
		var (
			err   error
			once  sync.Once
			value *TeammateTaskSection
		)
		m.oldValue = func(ctx context.Context) (*TeammateTaskSection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TeammateTaskSection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeammateTaskSection sets the old TeammateTaskSection of the mutation.
func withTeammateTaskSection(node *TeammateTaskSection) teammatetasksectionOption {
	return func(m *TeammateTaskSectionMutation) {
		m.oldValue = func(context.Context) (*TeammateTaskSection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeammateTaskSectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeammateTaskSectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TeammateTaskSection entities.
func (m *TeammateTaskSectionMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeammateTaskSectionMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeammateTaskSectionMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TeammateTaskSection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTeammateID sets the "teammate_id" field.
func (m *TeammateTaskSectionMutation) SetTeammateID(u ulid.ID) {
	m.teammate = &u
}

// TeammateID returns the value of the "teammate_id" field in the mutation.
func (m *TeammateTaskSectionMutation) TeammateID() (r ulid.ID, exists bool) {
	v := m.teammate
	if v == nil {
		return
	}
	return *v, true
}

// OldTeammateID returns the old "teammate_id" field's value of the TeammateTaskSection entity.
// If the TeammateTaskSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskSectionMutation) OldTeammateID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeammateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeammateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeammateID: %w", err)
	}
	return oldValue.TeammateID, nil
}

// ResetTeammateID resets all changes to the "teammate_id" field.
func (m *TeammateTaskSectionMutation) ResetTeammateID() {
	m.teammate = nil
}

// SetWorkspaceID sets the "workspace_id" field.
func (m *TeammateTaskSectionMutation) SetWorkspaceID(u ulid.ID) {
	m.workspace = &u
}

// WorkspaceID returns the value of the "workspace_id" field in the mutation.
func (m *TeammateTaskSectionMutation) WorkspaceID() (r ulid.ID, exists bool) {
	v := m.workspace
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspaceID returns the old "workspace_id" field's value of the TeammateTaskSection entity.
// If the TeammateTaskSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskSectionMutation) OldWorkspaceID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspaceID: %w", err)
	}
	return oldValue.WorkspaceID, nil
}

// ResetWorkspaceID resets all changes to the "workspace_id" field.
func (m *TeammateTaskSectionMutation) ResetWorkspaceID() {
	m.workspace = nil
}

// SetName sets the "name" field.
func (m *TeammateTaskSectionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeammateTaskSectionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TeammateTaskSection entity.
// If the TeammateTaskSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskSectionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeammateTaskSectionMutation) ResetName() {
	m.name = nil
}

// SetAssigned sets the "assigned" field.
func (m *TeammateTaskSectionMutation) SetAssigned(b bool) {
	m.assigned = &b
}

// Assigned returns the value of the "assigned" field in the mutation.
func (m *TeammateTaskSectionMutation) Assigned() (r bool, exists bool) {
	v := m.assigned
	if v == nil {
		return
	}
	return *v, true
}

// OldAssigned returns the old "assigned" field's value of the TeammateTaskSection entity.
// If the TeammateTaskSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskSectionMutation) OldAssigned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssigned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssigned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssigned: %w", err)
	}
	return oldValue.Assigned, nil
}

// ResetAssigned resets all changes to the "assigned" field.
func (m *TeammateTaskSectionMutation) ResetAssigned() {
	m.assigned = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TeammateTaskSectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeammateTaskSectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TeammateTaskSection entity.
// If the TeammateTaskSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskSectionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeammateTaskSectionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeammateTaskSectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeammateTaskSectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TeammateTaskSection entity.
// If the TeammateTaskSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskSectionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeammateTaskSectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTeammate clears the "teammate" edge to the Teammate entity.
func (m *TeammateTaskSectionMutation) ClearTeammate() {
	m.clearedteammate = true
}

// TeammateCleared reports if the "teammate" edge to the Teammate entity was cleared.
func (m *TeammateTaskSectionMutation) TeammateCleared() bool {
	return m.clearedteammate
}

// TeammateIDs returns the "teammate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeammateID instead. It exists only for internal usage by the builders.
func (m *TeammateTaskSectionMutation) TeammateIDs() (ids []ulid.ID) {
	if id := m.teammate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeammate resets all changes to the "teammate" edge.
func (m *TeammateTaskSectionMutation) ResetTeammate() {
	m.teammate = nil
	m.clearedteammate = false
}

// ClearWorkspace clears the "workspace" edge to the Workspace entity.
func (m *TeammateTaskSectionMutation) ClearWorkspace() {
	m.clearedworkspace = true
}

// WorkspaceCleared reports if the "workspace" edge to the Workspace entity was cleared.
func (m *TeammateTaskSectionMutation) WorkspaceCleared() bool {
	return m.clearedworkspace
}

// WorkspaceIDs returns the "workspace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkspaceID instead. It exists only for internal usage by the builders.
func (m *TeammateTaskSectionMutation) WorkspaceIDs() (ids []ulid.ID) {
	if id := m.workspace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkspace resets all changes to the "workspace" edge.
func (m *TeammateTaskSectionMutation) ResetWorkspace() {
	m.workspace = nil
	m.clearedworkspace = false
}

// AddTeammateTaskIDs adds the "teammateTasks" edge to the TeammateTask entity by ids.
func (m *TeammateTaskSectionMutation) AddTeammateTaskIDs(ids ...ulid.ID) {
	if m.teammateTasks == nil {
		m.teammateTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.teammateTasks[ids[i]] = struct{}{}
	}
}

// ClearTeammateTasks clears the "teammateTasks" edge to the TeammateTask entity.
func (m *TeammateTaskSectionMutation) ClearTeammateTasks() {
	m.clearedteammateTasks = true
}

// TeammateTasksCleared reports if the "teammateTasks" edge to the TeammateTask entity was cleared.
func (m *TeammateTaskSectionMutation) TeammateTasksCleared() bool {
	return m.clearedteammateTasks
}

// RemoveTeammateTaskIDs removes the "teammateTasks" edge to the TeammateTask entity by IDs.
func (m *TeammateTaskSectionMutation) RemoveTeammateTaskIDs(ids ...ulid.ID) {
	if m.removedteammateTasks == nil {
		m.removedteammateTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.teammateTasks, ids[i])
		m.removedteammateTasks[ids[i]] = struct{}{}
	}
}

// RemovedTeammateTasks returns the removed IDs of the "teammateTasks" edge to the TeammateTask entity.
func (m *TeammateTaskSectionMutation) RemovedTeammateTasksIDs() (ids []ulid.ID) {
	for id := range m.removedteammateTasks {
		ids = append(ids, id)
	}
	return
}

// TeammateTasksIDs returns the "teammateTasks" edge IDs in the mutation.
func (m *TeammateTaskSectionMutation) TeammateTasksIDs() (ids []ulid.ID) {
	for id := range m.teammateTasks {
		ids = append(ids, id)
	}
	return
}

// ResetTeammateTasks resets all changes to the "teammateTasks" edge.
func (m *TeammateTaskSectionMutation) ResetTeammateTasks() {
	m.teammateTasks = nil
	m.clearedteammateTasks = false
	m.removedteammateTasks = nil
}

// Where appends a list predicates to the TeammateTaskSectionMutation builder.
func (m *TeammateTaskSectionMutation) Where(ps ...predicate.TeammateTaskSection) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TeammateTaskSectionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TeammateTaskSection).
func (m *TeammateTaskSectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeammateTaskSectionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.teammate != nil {
		fields = append(fields, teammatetasksection.FieldTeammateID)
	}
	if m.workspace != nil {
		fields = append(fields, teammatetasksection.FieldWorkspaceID)
	}
	if m.name != nil {
		fields = append(fields, teammatetasksection.FieldName)
	}
	if m.assigned != nil {
		fields = append(fields, teammatetasksection.FieldAssigned)
	}
	if m.created_at != nil {
		fields = append(fields, teammatetasksection.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, teammatetasksection.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeammateTaskSectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teammatetasksection.FieldTeammateID:
		return m.TeammateID()
	case teammatetasksection.FieldWorkspaceID:
		return m.WorkspaceID()
	case teammatetasksection.FieldName:
		return m.Name()
	case teammatetasksection.FieldAssigned:
		return m.Assigned()
	case teammatetasksection.FieldCreatedAt:
		return m.CreatedAt()
	case teammatetasksection.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeammateTaskSectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teammatetasksection.FieldTeammateID:
		return m.OldTeammateID(ctx)
	case teammatetasksection.FieldWorkspaceID:
		return m.OldWorkspaceID(ctx)
	case teammatetasksection.FieldName:
		return m.OldName(ctx)
	case teammatetasksection.FieldAssigned:
		return m.OldAssigned(ctx)
	case teammatetasksection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case teammatetasksection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TeammateTaskSection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeammateTaskSectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teammatetasksection.FieldTeammateID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeammateID(v)
		return nil
	case teammatetasksection.FieldWorkspaceID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspaceID(v)
		return nil
	case teammatetasksection.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case teammatetasksection.FieldAssigned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssigned(v)
		return nil
	case teammatetasksection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case teammatetasksection.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TeammateTaskSection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeammateTaskSectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeammateTaskSectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeammateTaskSectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TeammateTaskSection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeammateTaskSectionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeammateTaskSectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeammateTaskSectionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TeammateTaskSection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeammateTaskSectionMutation) ResetField(name string) error {
	switch name {
	case teammatetasksection.FieldTeammateID:
		m.ResetTeammateID()
		return nil
	case teammatetasksection.FieldWorkspaceID:
		m.ResetWorkspaceID()
		return nil
	case teammatetasksection.FieldName:
		m.ResetName()
		return nil
	case teammatetasksection.FieldAssigned:
		m.ResetAssigned()
		return nil
	case teammatetasksection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case teammatetasksection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TeammateTaskSection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeammateTaskSectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.teammate != nil {
		edges = append(edges, teammatetasksection.EdgeTeammate)
	}
	if m.workspace != nil {
		edges = append(edges, teammatetasksection.EdgeWorkspace)
	}
	if m.teammateTasks != nil {
		edges = append(edges, teammatetasksection.EdgeTeammateTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeammateTaskSectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teammatetasksection.EdgeTeammate:
		if id := m.teammate; id != nil {
			return []ent.Value{*id}
		}
	case teammatetasksection.EdgeWorkspace:
		if id := m.workspace; id != nil {
			return []ent.Value{*id}
		}
	case teammatetasksection.EdgeTeammateTasks:
		ids := make([]ent.Value, 0, len(m.teammateTasks))
		for id := range m.teammateTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeammateTaskSectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedteammateTasks != nil {
		edges = append(edges, teammatetasksection.EdgeTeammateTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeammateTaskSectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case teammatetasksection.EdgeTeammateTasks:
		ids := make([]ent.Value, 0, len(m.removedteammateTasks))
		for id := range m.removedteammateTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeammateTaskSectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedteammate {
		edges = append(edges, teammatetasksection.EdgeTeammate)
	}
	if m.clearedworkspace {
		edges = append(edges, teammatetasksection.EdgeWorkspace)
	}
	if m.clearedteammateTasks {
		edges = append(edges, teammatetasksection.EdgeTeammateTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeammateTaskSectionMutation) EdgeCleared(name string) bool {
	switch name {
	case teammatetasksection.EdgeTeammate:
		return m.clearedteammate
	case teammatetasksection.EdgeWorkspace:
		return m.clearedworkspace
	case teammatetasksection.EdgeTeammateTasks:
		return m.clearedteammateTasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeammateTaskSectionMutation) ClearEdge(name string) error {
	switch name {
	case teammatetasksection.EdgeTeammate:
		m.ClearTeammate()
		return nil
	case teammatetasksection.EdgeWorkspace:
		m.ClearWorkspace()
		return nil
	}
	return fmt.Errorf("unknown TeammateTaskSection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeammateTaskSectionMutation) ResetEdge(name string) error {
	switch name {
	case teammatetasksection.EdgeTeammate:
		m.ResetTeammate()
		return nil
	case teammatetasksection.EdgeWorkspace:
		m.ResetWorkspace()
		return nil
	case teammatetasksection.EdgeTeammateTasks:
		m.ResetTeammateTasks()
		return nil
	}
	return fmt.Errorf("unknown TeammateTaskSection edge %s", name)
}

// TeammateTaskTabStatusMutation represents an operation that mutates the TeammateTaskTabStatus nodes in the graph.
type TeammateTaskTabStatusMutation struct {
	config
	op               Op
	typ              string
	id               *ulid.ID
	status_code      *teammatetasktabstatus.StatusCode
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	workspace        *ulid.ID
	clearedworkspace bool
	teammate         *ulid.ID
	clearedteammate  bool
	done             bool
	oldValue         func(context.Context) (*TeammateTaskTabStatus, error)
	predicates       []predicate.TeammateTaskTabStatus
}

var _ ent.Mutation = (*TeammateTaskTabStatusMutation)(nil)

// teammatetasktabstatusOption allows management of the mutation configuration using functional options.
type teammatetasktabstatusOption func(*TeammateTaskTabStatusMutation)

// newTeammateTaskTabStatusMutation creates new mutation for the TeammateTaskTabStatus entity.
func newTeammateTaskTabStatusMutation(c config, op Op, opts ...teammatetasktabstatusOption) *TeammateTaskTabStatusMutation {
	m := &TeammateTaskTabStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeTeammateTaskTabStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeammateTaskTabStatusID sets the ID field of the mutation.
func withTeammateTaskTabStatusID(id ulid.ID) teammatetasktabstatusOption {
	return func(m *TeammateTaskTabStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *TeammateTaskTabStatus
		)
		m.oldValue = func(ctx context.Context) (*TeammateTaskTabStatus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TeammateTaskTabStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeammateTaskTabStatus sets the old TeammateTaskTabStatus of the mutation.
func withTeammateTaskTabStatus(node *TeammateTaskTabStatus) teammatetasktabstatusOption {
	return func(m *TeammateTaskTabStatusMutation) {
		m.oldValue = func(context.Context) (*TeammateTaskTabStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeammateTaskTabStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeammateTaskTabStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TeammateTaskTabStatus entities.
func (m *TeammateTaskTabStatusMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeammateTaskTabStatusMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeammateTaskTabStatusMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TeammateTaskTabStatus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkspaceID sets the "workspace_id" field.
func (m *TeammateTaskTabStatusMutation) SetWorkspaceID(u ulid.ID) {
	m.workspace = &u
}

// WorkspaceID returns the value of the "workspace_id" field in the mutation.
func (m *TeammateTaskTabStatusMutation) WorkspaceID() (r ulid.ID, exists bool) {
	v := m.workspace
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspaceID returns the old "workspace_id" field's value of the TeammateTaskTabStatus entity.
// If the TeammateTaskTabStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskTabStatusMutation) OldWorkspaceID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspaceID: %w", err)
	}
	return oldValue.WorkspaceID, nil
}

// ResetWorkspaceID resets all changes to the "workspace_id" field.
func (m *TeammateTaskTabStatusMutation) ResetWorkspaceID() {
	m.workspace = nil
}

// SetTeammateID sets the "teammate_id" field.
func (m *TeammateTaskTabStatusMutation) SetTeammateID(u ulid.ID) {
	m.teammate = &u
}

// TeammateID returns the value of the "teammate_id" field in the mutation.
func (m *TeammateTaskTabStatusMutation) TeammateID() (r ulid.ID, exists bool) {
	v := m.teammate
	if v == nil {
		return
	}
	return *v, true
}

// OldTeammateID returns the old "teammate_id" field's value of the TeammateTaskTabStatus entity.
// If the TeammateTaskTabStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskTabStatusMutation) OldTeammateID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeammateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeammateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeammateID: %w", err)
	}
	return oldValue.TeammateID, nil
}

// ResetTeammateID resets all changes to the "teammate_id" field.
func (m *TeammateTaskTabStatusMutation) ResetTeammateID() {
	m.teammate = nil
}

// SetStatusCode sets the "status_code" field.
func (m *TeammateTaskTabStatusMutation) SetStatusCode(tc teammatetasktabstatus.StatusCode) {
	m.status_code = &tc
}

// StatusCode returns the value of the "status_code" field in the mutation.
func (m *TeammateTaskTabStatusMutation) StatusCode() (r teammatetasktabstatus.StatusCode, exists bool) {
	v := m.status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusCode returns the old "status_code" field's value of the TeammateTaskTabStatus entity.
// If the TeammateTaskTabStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskTabStatusMutation) OldStatusCode(ctx context.Context) (v teammatetasktabstatus.StatusCode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusCode: %w", err)
	}
	return oldValue.StatusCode, nil
}

// ResetStatusCode resets all changes to the "status_code" field.
func (m *TeammateTaskTabStatusMutation) ResetStatusCode() {
	m.status_code = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TeammateTaskTabStatusMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeammateTaskTabStatusMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TeammateTaskTabStatus entity.
// If the TeammateTaskTabStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskTabStatusMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeammateTaskTabStatusMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeammateTaskTabStatusMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeammateTaskTabStatusMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TeammateTaskTabStatus entity.
// If the TeammateTaskTabStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeammateTaskTabStatusMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeammateTaskTabStatusMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearWorkspace clears the "workspace" edge to the Workspace entity.
func (m *TeammateTaskTabStatusMutation) ClearWorkspace() {
	m.clearedworkspace = true
}

// WorkspaceCleared reports if the "workspace" edge to the Workspace entity was cleared.
func (m *TeammateTaskTabStatusMutation) WorkspaceCleared() bool {
	return m.clearedworkspace
}

// WorkspaceIDs returns the "workspace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkspaceID instead. It exists only for internal usage by the builders.
func (m *TeammateTaskTabStatusMutation) WorkspaceIDs() (ids []ulid.ID) {
	if id := m.workspace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkspace resets all changes to the "workspace" edge.
func (m *TeammateTaskTabStatusMutation) ResetWorkspace() {
	m.workspace = nil
	m.clearedworkspace = false
}

// ClearTeammate clears the "teammate" edge to the Teammate entity.
func (m *TeammateTaskTabStatusMutation) ClearTeammate() {
	m.clearedteammate = true
}

// TeammateCleared reports if the "teammate" edge to the Teammate entity was cleared.
func (m *TeammateTaskTabStatusMutation) TeammateCleared() bool {
	return m.clearedteammate
}

// TeammateIDs returns the "teammate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeammateID instead. It exists only for internal usage by the builders.
func (m *TeammateTaskTabStatusMutation) TeammateIDs() (ids []ulid.ID) {
	if id := m.teammate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeammate resets all changes to the "teammate" edge.
func (m *TeammateTaskTabStatusMutation) ResetTeammate() {
	m.teammate = nil
	m.clearedteammate = false
}

// Where appends a list predicates to the TeammateTaskTabStatusMutation builder.
func (m *TeammateTaskTabStatusMutation) Where(ps ...predicate.TeammateTaskTabStatus) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TeammateTaskTabStatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TeammateTaskTabStatus).
func (m *TeammateTaskTabStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeammateTaskTabStatusMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.workspace != nil {
		fields = append(fields, teammatetasktabstatus.FieldWorkspaceID)
	}
	if m.teammate != nil {
		fields = append(fields, teammatetasktabstatus.FieldTeammateID)
	}
	if m.status_code != nil {
		fields = append(fields, teammatetasktabstatus.FieldStatusCode)
	}
	if m.created_at != nil {
		fields = append(fields, teammatetasktabstatus.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, teammatetasktabstatus.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeammateTaskTabStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teammatetasktabstatus.FieldWorkspaceID:
		return m.WorkspaceID()
	case teammatetasktabstatus.FieldTeammateID:
		return m.TeammateID()
	case teammatetasktabstatus.FieldStatusCode:
		return m.StatusCode()
	case teammatetasktabstatus.FieldCreatedAt:
		return m.CreatedAt()
	case teammatetasktabstatus.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeammateTaskTabStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teammatetasktabstatus.FieldWorkspaceID:
		return m.OldWorkspaceID(ctx)
	case teammatetasktabstatus.FieldTeammateID:
		return m.OldTeammateID(ctx)
	case teammatetasktabstatus.FieldStatusCode:
		return m.OldStatusCode(ctx)
	case teammatetasktabstatus.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case teammatetasktabstatus.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TeammateTaskTabStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeammateTaskTabStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teammatetasktabstatus.FieldWorkspaceID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspaceID(v)
		return nil
	case teammatetasktabstatus.FieldTeammateID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeammateID(v)
		return nil
	case teammatetasktabstatus.FieldStatusCode:
		v, ok := value.(teammatetasktabstatus.StatusCode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusCode(v)
		return nil
	case teammatetasktabstatus.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case teammatetasktabstatus.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TeammateTaskTabStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeammateTaskTabStatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeammateTaskTabStatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeammateTaskTabStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TeammateTaskTabStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeammateTaskTabStatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeammateTaskTabStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeammateTaskTabStatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TeammateTaskTabStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeammateTaskTabStatusMutation) ResetField(name string) error {
	switch name {
	case teammatetasktabstatus.FieldWorkspaceID:
		m.ResetWorkspaceID()
		return nil
	case teammatetasktabstatus.FieldTeammateID:
		m.ResetTeammateID()
		return nil
	case teammatetasktabstatus.FieldStatusCode:
		m.ResetStatusCode()
		return nil
	case teammatetasktabstatus.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case teammatetasktabstatus.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TeammateTaskTabStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeammateTaskTabStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.workspace != nil {
		edges = append(edges, teammatetasktabstatus.EdgeWorkspace)
	}
	if m.teammate != nil {
		edges = append(edges, teammatetasktabstatus.EdgeTeammate)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeammateTaskTabStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teammatetasktabstatus.EdgeWorkspace:
		if id := m.workspace; id != nil {
			return []ent.Value{*id}
		}
	case teammatetasktabstatus.EdgeTeammate:
		if id := m.teammate; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeammateTaskTabStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeammateTaskTabStatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeammateTaskTabStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedworkspace {
		edges = append(edges, teammatetasktabstatus.EdgeWorkspace)
	}
	if m.clearedteammate {
		edges = append(edges, teammatetasktabstatus.EdgeTeammate)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeammateTaskTabStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case teammatetasktabstatus.EdgeWorkspace:
		return m.clearedworkspace
	case teammatetasktabstatus.EdgeTeammate:
		return m.clearedteammate
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeammateTaskTabStatusMutation) ClearEdge(name string) error {
	switch name {
	case teammatetasktabstatus.EdgeWorkspace:
		m.ClearWorkspace()
		return nil
	case teammatetasktabstatus.EdgeTeammate:
		m.ClearTeammate()
		return nil
	}
	return fmt.Errorf("unknown TeammateTaskTabStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeammateTaskTabStatusMutation) ResetEdge(name string) error {
	switch name {
	case teammatetasktabstatus.EdgeWorkspace:
		m.ResetWorkspace()
		return nil
	case teammatetasktabstatus.EdgeTeammate:
		m.ResetTeammate()
		return nil
	}
	return fmt.Errorf("unknown TeammateTaskTabStatus edge %s", name)
}

// TestTodoMutation represents an operation that mutates the TestTodo nodes in the graph.
type TestTodoMutation struct {
	config
	op              Op
	typ             string
	id              *ulid.ID
	created_by      *ulid.ID
	name            *string
	status          *testtodo.Status
	priority        *int
	addpriority     *int
	due_date        *time.Time
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	testUser        *ulid.ID
	clearedtestUser bool
	parent          *ulid.ID
	clearedparent   bool
	children        map[ulid.ID]struct{}
	removedchildren map[ulid.ID]struct{}
	clearedchildren bool
	done            bool
	oldValue        func(context.Context) (*TestTodo, error)
	predicates      []predicate.TestTodo
}

var _ ent.Mutation = (*TestTodoMutation)(nil)

// testtodoOption allows management of the mutation configuration using functional options.
type testtodoOption func(*TestTodoMutation)

// newTestTodoMutation creates new mutation for the TestTodo entity.
func newTestTodoMutation(c config, op Op, opts ...testtodoOption) *TestTodoMutation {
	m := &TestTodoMutation{
		config:        c,
		op:            op,
		typ:           TypeTestTodo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestTodoID sets the ID field of the mutation.
func withTestTodoID(id ulid.ID) testtodoOption {
	return func(m *TestTodoMutation) {
		var (
			err   error
			once  sync.Once
			value *TestTodo
		)
		m.oldValue = func(ctx context.Context) (*TestTodo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestTodo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestTodo sets the old TestTodo of the mutation.
func withTestTodo(node *TestTodo) testtodoOption {
	return func(m *TestTodoMutation) {
		m.oldValue = func(context.Context) (*TestTodo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestTodoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestTodoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TestTodo entities.
func (m *TestTodoMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestTodoMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestTodoMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TestTodo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTestUserID sets the "test_user_id" field.
func (m *TestTodoMutation) SetTestUserID(u ulid.ID) {
	m.testUser = &u
}

// TestUserID returns the value of the "test_user_id" field in the mutation.
func (m *TestTodoMutation) TestUserID() (r ulid.ID, exists bool) {
	v := m.testUser
	if v == nil {
		return
	}
	return *v, true
}

// OldTestUserID returns the old "test_user_id" field's value of the TestTodo entity.
// If the TestTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestTodoMutation) OldTestUserID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestUserID: %w", err)
	}
	return oldValue.TestUserID, nil
}

// ClearTestUserID clears the value of the "test_user_id" field.
func (m *TestTodoMutation) ClearTestUserID() {
	m.testUser = nil
	m.clearedFields[testtodo.FieldTestUserID] = struct{}{}
}

// TestUserIDCleared returns if the "test_user_id" field was cleared in this mutation.
func (m *TestTodoMutation) TestUserIDCleared() bool {
	_, ok := m.clearedFields[testtodo.FieldTestUserID]
	return ok
}

// ResetTestUserID resets all changes to the "test_user_id" field.
func (m *TestTodoMutation) ResetTestUserID() {
	m.testUser = nil
	delete(m.clearedFields, testtodo.FieldTestUserID)
}

// SetCreatedBy sets the "created_by" field.
func (m *TestTodoMutation) SetCreatedBy(u ulid.ID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TestTodoMutation) CreatedBy() (r ulid.ID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TestTodo entity.
// If the TestTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestTodoMutation) OldCreatedBy(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TestTodoMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetParentTodoID sets the "parent_todo_id" field.
func (m *TestTodoMutation) SetParentTodoID(u ulid.ID) {
	m.parent = &u
}

// ParentTodoID returns the value of the "parent_todo_id" field in the mutation.
func (m *TestTodoMutation) ParentTodoID() (r ulid.ID, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentTodoID returns the old "parent_todo_id" field's value of the TestTodo entity.
// If the TestTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestTodoMutation) OldParentTodoID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentTodoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentTodoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentTodoID: %w", err)
	}
	return oldValue.ParentTodoID, nil
}

// ClearParentTodoID clears the value of the "parent_todo_id" field.
func (m *TestTodoMutation) ClearParentTodoID() {
	m.parent = nil
	m.clearedFields[testtodo.FieldParentTodoID] = struct{}{}
}

// ParentTodoIDCleared returns if the "parent_todo_id" field was cleared in this mutation.
func (m *TestTodoMutation) ParentTodoIDCleared() bool {
	_, ok := m.clearedFields[testtodo.FieldParentTodoID]
	return ok
}

// ResetParentTodoID resets all changes to the "parent_todo_id" field.
func (m *TestTodoMutation) ResetParentTodoID() {
	m.parent = nil
	delete(m.clearedFields, testtodo.FieldParentTodoID)
}

// SetName sets the "name" field.
func (m *TestTodoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TestTodoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TestTodo entity.
// If the TestTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestTodoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TestTodoMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *TestTodoMutation) SetStatus(t testtodo.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TestTodoMutation) Status() (r testtodo.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TestTodo entity.
// If the TestTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestTodoMutation) OldStatus(ctx context.Context) (v testtodo.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TestTodoMutation) ResetStatus() {
	m.status = nil
}

// SetPriority sets the "priority" field.
func (m *TestTodoMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *TestTodoMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the TestTodo entity.
// If the TestTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestTodoMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *TestTodoMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *TestTodoMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *TestTodoMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetDueDate sets the "due_date" field.
func (m *TestTodoMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *TestTodoMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the TestTodo entity.
// If the TestTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestTodoMutation) OldDueDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ClearDueDate clears the value of the "due_date" field.
func (m *TestTodoMutation) ClearDueDate() {
	m.due_date = nil
	m.clearedFields[testtodo.FieldDueDate] = struct{}{}
}

// DueDateCleared returns if the "due_date" field was cleared in this mutation.
func (m *TestTodoMutation) DueDateCleared() bool {
	_, ok := m.clearedFields[testtodo.FieldDueDate]
	return ok
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *TestTodoMutation) ResetDueDate() {
	m.due_date = nil
	delete(m.clearedFields, testtodo.FieldDueDate)
}

// SetCreatedAt sets the "created_at" field.
func (m *TestTodoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TestTodoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TestTodo entity.
// If the TestTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestTodoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TestTodoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TestTodoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TestTodoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TestTodo entity.
// If the TestTodo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestTodoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TestTodoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTestUser clears the "testUser" edge to the TestUser entity.
func (m *TestTodoMutation) ClearTestUser() {
	m.clearedtestUser = true
}

// TestUserCleared reports if the "testUser" edge to the TestUser entity was cleared.
func (m *TestTodoMutation) TestUserCleared() bool {
	return m.TestUserIDCleared() || m.clearedtestUser
}

// TestUserIDs returns the "testUser" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TestUserID instead. It exists only for internal usage by the builders.
func (m *TestTodoMutation) TestUserIDs() (ids []ulid.ID) {
	if id := m.testUser; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTestUser resets all changes to the "testUser" edge.
func (m *TestTodoMutation) ResetTestUser() {
	m.testUser = nil
	m.clearedtestUser = false
}

// SetParentID sets the "parent" edge to the TestTodo entity by id.
func (m *TestTodoMutation) SetParentID(id ulid.ID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the TestTodo entity.
func (m *TestTodoMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the TestTodo entity was cleared.
func (m *TestTodoMutation) ParentCleared() bool {
	return m.ParentTodoIDCleared() || m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *TestTodoMutation) ParentID() (id ulid.ID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *TestTodoMutation) ParentIDs() (ids []ulid.ID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *TestTodoMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the TestTodo entity by ids.
func (m *TestTodoMutation) AddChildIDs(ids ...ulid.ID) {
	if m.children == nil {
		m.children = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the TestTodo entity.
func (m *TestTodoMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the TestTodo entity was cleared.
func (m *TestTodoMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the TestTodo entity by IDs.
func (m *TestTodoMutation) RemoveChildIDs(ids ...ulid.ID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the TestTodo entity.
func (m *TestTodoMutation) RemovedChildrenIDs() (ids []ulid.ID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *TestTodoMutation) ChildrenIDs() (ids []ulid.ID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *TestTodoMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the TestTodoMutation builder.
func (m *TestTodoMutation) Where(ps ...predicate.TestTodo) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TestTodoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TestTodo).
func (m *TestTodoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestTodoMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.testUser != nil {
		fields = append(fields, testtodo.FieldTestUserID)
	}
	if m.created_by != nil {
		fields = append(fields, testtodo.FieldCreatedBy)
	}
	if m.parent != nil {
		fields = append(fields, testtodo.FieldParentTodoID)
	}
	if m.name != nil {
		fields = append(fields, testtodo.FieldName)
	}
	if m.status != nil {
		fields = append(fields, testtodo.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, testtodo.FieldPriority)
	}
	if m.due_date != nil {
		fields = append(fields, testtodo.FieldDueDate)
	}
	if m.created_at != nil {
		fields = append(fields, testtodo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, testtodo.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestTodoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testtodo.FieldTestUserID:
		return m.TestUserID()
	case testtodo.FieldCreatedBy:
		return m.CreatedBy()
	case testtodo.FieldParentTodoID:
		return m.ParentTodoID()
	case testtodo.FieldName:
		return m.Name()
	case testtodo.FieldStatus:
		return m.Status()
	case testtodo.FieldPriority:
		return m.Priority()
	case testtodo.FieldDueDate:
		return m.DueDate()
	case testtodo.FieldCreatedAt:
		return m.CreatedAt()
	case testtodo.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestTodoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testtodo.FieldTestUserID:
		return m.OldTestUserID(ctx)
	case testtodo.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case testtodo.FieldParentTodoID:
		return m.OldParentTodoID(ctx)
	case testtodo.FieldName:
		return m.OldName(ctx)
	case testtodo.FieldStatus:
		return m.OldStatus(ctx)
	case testtodo.FieldPriority:
		return m.OldPriority(ctx)
	case testtodo.FieldDueDate:
		return m.OldDueDate(ctx)
	case testtodo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case testtodo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TestTodo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestTodoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testtodo.FieldTestUserID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestUserID(v)
		return nil
	case testtodo.FieldCreatedBy:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case testtodo.FieldParentTodoID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentTodoID(v)
		return nil
	case testtodo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case testtodo.FieldStatus:
		v, ok := value.(testtodo.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case testtodo.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case testtodo.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case testtodo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case testtodo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TestTodo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestTodoMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, testtodo.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestTodoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case testtodo.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestTodoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case testtodo.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown TestTodo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestTodoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(testtodo.FieldTestUserID) {
		fields = append(fields, testtodo.FieldTestUserID)
	}
	if m.FieldCleared(testtodo.FieldParentTodoID) {
		fields = append(fields, testtodo.FieldParentTodoID)
	}
	if m.FieldCleared(testtodo.FieldDueDate) {
		fields = append(fields, testtodo.FieldDueDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestTodoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestTodoMutation) ClearField(name string) error {
	switch name {
	case testtodo.FieldTestUserID:
		m.ClearTestUserID()
		return nil
	case testtodo.FieldParentTodoID:
		m.ClearParentTodoID()
		return nil
	case testtodo.FieldDueDate:
		m.ClearDueDate()
		return nil
	}
	return fmt.Errorf("unknown TestTodo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestTodoMutation) ResetField(name string) error {
	switch name {
	case testtodo.FieldTestUserID:
		m.ResetTestUserID()
		return nil
	case testtodo.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case testtodo.FieldParentTodoID:
		m.ResetParentTodoID()
		return nil
	case testtodo.FieldName:
		m.ResetName()
		return nil
	case testtodo.FieldStatus:
		m.ResetStatus()
		return nil
	case testtodo.FieldPriority:
		m.ResetPriority()
		return nil
	case testtodo.FieldDueDate:
		m.ResetDueDate()
		return nil
	case testtodo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case testtodo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TestTodo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestTodoMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.testUser != nil {
		edges = append(edges, testtodo.EdgeTestUser)
	}
	if m.parent != nil {
		edges = append(edges, testtodo.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, testtodo.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestTodoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case testtodo.EdgeTestUser:
		if id := m.testUser; id != nil {
			return []ent.Value{*id}
		}
	case testtodo.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case testtodo.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestTodoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, testtodo.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestTodoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case testtodo.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestTodoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtestUser {
		edges = append(edges, testtodo.EdgeTestUser)
	}
	if m.clearedparent {
		edges = append(edges, testtodo.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, testtodo.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestTodoMutation) EdgeCleared(name string) bool {
	switch name {
	case testtodo.EdgeTestUser:
		return m.clearedtestUser
	case testtodo.EdgeParent:
		return m.clearedparent
	case testtodo.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestTodoMutation) ClearEdge(name string) error {
	switch name {
	case testtodo.EdgeTestUser:
		m.ClearTestUser()
		return nil
	case testtodo.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown TestTodo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestTodoMutation) ResetEdge(name string) error {
	switch name {
	case testtodo.EdgeTestUser:
		m.ResetTestUser()
		return nil
	case testtodo.EdgeParent:
		m.ResetParent()
		return nil
	case testtodo.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown TestTodo edge %s", name)
}

// TestUserMutation represents an operation that mutates the TestUser nodes in the graph.
type TestUserMutation struct {
	config
	op               Op
	typ              string
	id               *ulid.ID
	name             *string
	age              *int
	addage           *int
	profile          *testuserprofile.TestUserProfile
	description      *map[string]interface{}
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	testTodos        map[ulid.ID]struct{}
	removedtestTodos map[ulid.ID]struct{}
	clearedtestTodos bool
	done             bool
	oldValue         func(context.Context) (*TestUser, error)
	predicates       []predicate.TestUser
}

var _ ent.Mutation = (*TestUserMutation)(nil)

// testuserOption allows management of the mutation configuration using functional options.
type testuserOption func(*TestUserMutation)

// newTestUserMutation creates new mutation for the TestUser entity.
func newTestUserMutation(c config, op Op, opts ...testuserOption) *TestUserMutation {
	m := &TestUserMutation{
		config:        c,
		op:            op,
		typ:           TypeTestUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestUserID sets the ID field of the mutation.
func withTestUserID(id ulid.ID) testuserOption {
	return func(m *TestUserMutation) {
		var (
			err   error
			once  sync.Once
			value *TestUser
		)
		m.oldValue = func(ctx context.Context) (*TestUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestUser sets the old TestUser of the mutation.
func withTestUser(node *TestUser) testuserOption {
	return func(m *TestUserMutation) {
		m.oldValue = func(context.Context) (*TestUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TestUser entities.
func (m *TestUserMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestUserMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestUserMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TestUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TestUserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TestUserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TestUser entity.
// If the TestUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestUserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TestUserMutation) ResetName() {
	m.name = nil
}

// SetAge sets the "age" field.
func (m *TestUserMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *TestUserMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the TestUser entity.
// If the TestUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestUserMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to the "age" field.
func (m *TestUserMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *TestUserMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *TestUserMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetProfile sets the "profile" field.
func (m *TestUserMutation) SetProfile(tup testuserprofile.TestUserProfile) {
	m.profile = &tup
}

// Profile returns the value of the "profile" field in the mutation.
func (m *TestUserMutation) Profile() (r testuserprofile.TestUserProfile, exists bool) {
	v := m.profile
	if v == nil {
		return
	}
	return *v, true
}

// OldProfile returns the old "profile" field's value of the TestUser entity.
// If the TestUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestUserMutation) OldProfile(ctx context.Context) (v testuserprofile.TestUserProfile, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfile: %w", err)
	}
	return oldValue.Profile, nil
}

// ResetProfile resets all changes to the "profile" field.
func (m *TestUserMutation) ResetProfile() {
	m.profile = nil
}

// SetDescription sets the "description" field.
func (m *TestUserMutation) SetDescription(value map[string]interface{}) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *TestUserMutation) Description() (r map[string]interface{}, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TestUser entity.
// If the TestUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestUserMutation) OldDescription(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TestUserMutation) ResetDescription() {
	m.description = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TestUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TestUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TestUser entity.
// If the TestUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TestUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TestUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TestUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TestUser entity.
// If the TestUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TestUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddTestTodoIDs adds the "testTodos" edge to the TestTodo entity by ids.
func (m *TestUserMutation) AddTestTodoIDs(ids ...ulid.ID) {
	if m.testTodos == nil {
		m.testTodos = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.testTodos[ids[i]] = struct{}{}
	}
}

// ClearTestTodos clears the "testTodos" edge to the TestTodo entity.
func (m *TestUserMutation) ClearTestTodos() {
	m.clearedtestTodos = true
}

// TestTodosCleared reports if the "testTodos" edge to the TestTodo entity was cleared.
func (m *TestUserMutation) TestTodosCleared() bool {
	return m.clearedtestTodos
}

// RemoveTestTodoIDs removes the "testTodos" edge to the TestTodo entity by IDs.
func (m *TestUserMutation) RemoveTestTodoIDs(ids ...ulid.ID) {
	if m.removedtestTodos == nil {
		m.removedtestTodos = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.testTodos, ids[i])
		m.removedtestTodos[ids[i]] = struct{}{}
	}
}

// RemovedTestTodos returns the removed IDs of the "testTodos" edge to the TestTodo entity.
func (m *TestUserMutation) RemovedTestTodosIDs() (ids []ulid.ID) {
	for id := range m.removedtestTodos {
		ids = append(ids, id)
	}
	return
}

// TestTodosIDs returns the "testTodos" edge IDs in the mutation.
func (m *TestUserMutation) TestTodosIDs() (ids []ulid.ID) {
	for id := range m.testTodos {
		ids = append(ids, id)
	}
	return
}

// ResetTestTodos resets all changes to the "testTodos" edge.
func (m *TestUserMutation) ResetTestTodos() {
	m.testTodos = nil
	m.clearedtestTodos = false
	m.removedtestTodos = nil
}

// Where appends a list predicates to the TestUserMutation builder.
func (m *TestUserMutation) Where(ps ...predicate.TestUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TestUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TestUser).
func (m *TestUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestUserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, testuser.FieldName)
	}
	if m.age != nil {
		fields = append(fields, testuser.FieldAge)
	}
	if m.profile != nil {
		fields = append(fields, testuser.FieldProfile)
	}
	if m.description != nil {
		fields = append(fields, testuser.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, testuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, testuser.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testuser.FieldName:
		return m.Name()
	case testuser.FieldAge:
		return m.Age()
	case testuser.FieldProfile:
		return m.Profile()
	case testuser.FieldDescription:
		return m.Description()
	case testuser.FieldCreatedAt:
		return m.CreatedAt()
	case testuser.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testuser.FieldName:
		return m.OldName(ctx)
	case testuser.FieldAge:
		return m.OldAge(ctx)
	case testuser.FieldProfile:
		return m.OldProfile(ctx)
	case testuser.FieldDescription:
		return m.OldDescription(ctx)
	case testuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case testuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TestUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testuser.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case testuser.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case testuser.FieldProfile:
		v, ok := value.(testuserprofile.TestUserProfile)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfile(v)
		return nil
	case testuser.FieldDescription:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case testuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case testuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TestUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestUserMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, testuser.FieldAge)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case testuser.FieldAge:
		return m.AddedAge()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case testuser.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	}
	return fmt.Errorf("unknown TestUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TestUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestUserMutation) ResetField(name string) error {
	switch name {
	case testuser.FieldName:
		m.ResetName()
		return nil
	case testuser.FieldAge:
		m.ResetAge()
		return nil
	case testuser.FieldProfile:
		m.ResetProfile()
		return nil
	case testuser.FieldDescription:
		m.ResetDescription()
		return nil
	case testuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case testuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TestUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.testTodos != nil {
		edges = append(edges, testuser.EdgeTestTodos)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case testuser.EdgeTestTodos:
		ids := make([]ent.Value, 0, len(m.testTodos))
		for id := range m.testTodos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtestTodos != nil {
		edges = append(edges, testuser.EdgeTestTodos)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case testuser.EdgeTestTodos:
		ids := make([]ent.Value, 0, len(m.removedtestTodos))
		for id := range m.removedtestTodos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtestTodos {
		edges = append(edges, testuser.EdgeTestTodos)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestUserMutation) EdgeCleared(name string) bool {
	switch name {
	case testuser.EdgeTestTodos:
		return m.clearedtestTodos
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestUserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TestUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestUserMutation) ResetEdge(name string) error {
	switch name {
	case testuser.EdgeTestTodos:
		m.ResetTestTodos()
		return nil
	}
	return fmt.Errorf("unknown TestUser edge %s", name)
}

// WorkspaceMutation represents an operation that mutates the Workspace nodes in the graph.
type WorkspaceMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *ulid.ID
	name                               *string
	description                        *map[string]interface{}
	created_at                         *time.Time
	updated_at                         *time.Time
	clearedFields                      map[string]struct{}
	teammate                           *ulid.ID
	clearedteammate                    bool
	projects                           map[ulid.ID]struct{}
	removedprojects                    map[ulid.ID]struct{}
	clearedprojects                    bool
	workspaceTeammates                 map[ulid.ID]struct{}
	removedworkspaceTeammates          map[ulid.ID]struct{}
	clearedworkspaceTeammates          bool
	favoriteWorkspaces                 map[ulid.ID]struct{}
	removedfavoriteWorkspaces          map[ulid.ID]struct{}
	clearedfavoriteWorkspaces          bool
	teammateTaskTabStatuses            map[ulid.ID]struct{}
	removedteammateTaskTabStatuses     map[ulid.ID]struct{}
	clearedteammateTaskTabStatuses     bool
	teammateTaskListStatuses           map[ulid.ID]struct{}
	removedteammateTaskListStatuses    map[ulid.ID]struct{}
	clearedteammateTaskListStatuses    bool
	teammateTaskSections               map[ulid.ID]struct{}
	removedteammateTaskSections        map[ulid.ID]struct{}
	clearedteammateTaskSections        bool
	taskLikes                          map[ulid.ID]struct{}
	removedtaskLikes                   map[ulid.ID]struct{}
	clearedtaskLikes                   bool
	tags                               map[ulid.ID]struct{}
	removedtags                        map[ulid.ID]struct{}
	clearedtags                        bool
	teammateTaskColumns                map[ulid.ID]struct{}
	removedteammateTaskColumns         map[ulid.ID]struct{}
	clearedteammateTaskColumns         bool
	teammateTasks                      map[ulid.ID]struct{}
	removedteammateTasks               map[ulid.ID]struct{}
	clearedteammateTasks               bool
	deletedTasksRef                    map[ulid.ID]struct{}
	removeddeletedTasksRef             map[ulid.ID]struct{}
	cleareddeletedTasksRef             bool
	workspaceActivities                map[ulid.ID]struct{}
	removedworkspaceActivities         map[ulid.ID]struct{}
	clearedworkspaceActivities         bool
	taskActivities                     map[ulid.ID]struct{}
	removedtaskActivities              map[ulid.ID]struct{}
	clearedtaskActivities              bool
	archivedTaskActivities             map[ulid.ID]struct{}
	removedarchivedTaskActivities      map[ulid.ID]struct{}
	clearedarchivedTaskActivities      bool
	archivedWorkspaceActivities        map[ulid.ID]struct{}
	removedarchivedWorkspaceActivities map[ulid.ID]struct{}
	clearedarchivedWorkspaceActivities bool
	done                               bool
	oldValue                           func(context.Context) (*Workspace, error)
	predicates                         []predicate.Workspace
}

var _ ent.Mutation = (*WorkspaceMutation)(nil)

// workspaceOption allows management of the mutation configuration using functional options.
type workspaceOption func(*WorkspaceMutation)

// newWorkspaceMutation creates new mutation for the Workspace entity.
func newWorkspaceMutation(c config, op Op, opts ...workspaceOption) *WorkspaceMutation {
	m := &WorkspaceMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkspace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkspaceID sets the ID field of the mutation.
func withWorkspaceID(id ulid.ID) workspaceOption {
	return func(m *WorkspaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Workspace
		)
		m.oldValue = func(ctx context.Context) (*Workspace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Workspace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkspace sets the old Workspace of the mutation.
func withWorkspace(node *Workspace) workspaceOption {
	return func(m *WorkspaceMutation) {
		m.oldValue = func(context.Context) (*Workspace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkspaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkspaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Workspace entities.
func (m *WorkspaceMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkspaceMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkspaceMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Workspace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *WorkspaceMutation) SetCreatedBy(u ulid.ID) {
	m.teammate = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *WorkspaceMutation) CreatedBy() (r ulid.ID, exists bool) {
	v := m.teammate
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldCreatedBy(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *WorkspaceMutation) ResetCreatedBy() {
	m.teammate = nil
}

// SetName sets the "name" field.
func (m *WorkspaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WorkspaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WorkspaceMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *WorkspaceMutation) SetDescription(value map[string]interface{}) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkspaceMutation) Description() (r map[string]interface{}, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldDescription(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkspaceMutation) ResetDescription() {
	m.description = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkspaceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkspaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkspaceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkspaceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkspaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkspaceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTeammateID sets the "teammate" edge to the Teammate entity by id.
func (m *WorkspaceMutation) SetTeammateID(id ulid.ID) {
	m.teammate = &id
}

// ClearTeammate clears the "teammate" edge to the Teammate entity.
func (m *WorkspaceMutation) ClearTeammate() {
	m.clearedteammate = true
}

// TeammateCleared reports if the "teammate" edge to the Teammate entity was cleared.
func (m *WorkspaceMutation) TeammateCleared() bool {
	return m.clearedteammate
}

// TeammateID returns the "teammate" edge ID in the mutation.
func (m *WorkspaceMutation) TeammateID() (id ulid.ID, exists bool) {
	if m.teammate != nil {
		return *m.teammate, true
	}
	return
}

// TeammateIDs returns the "teammate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeammateID instead. It exists only for internal usage by the builders.
func (m *WorkspaceMutation) TeammateIDs() (ids []ulid.ID) {
	if id := m.teammate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeammate resets all changes to the "teammate" edge.
func (m *WorkspaceMutation) ResetTeammate() {
	m.teammate = nil
	m.clearedteammate = false
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *WorkspaceMutation) AddProjectIDs(ids ...ulid.ID) {
	if m.projects == nil {
		m.projects = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *WorkspaceMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *WorkspaceMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *WorkspaceMutation) RemoveProjectIDs(ids ...ulid.ID) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *WorkspaceMutation) RemovedProjectsIDs() (ids []ulid.ID) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *WorkspaceMutation) ProjectsIDs() (ids []ulid.ID) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *WorkspaceMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddWorkspaceTeammateIDs adds the "workspaceTeammates" edge to the WorkspaceTeammate entity by ids.
func (m *WorkspaceMutation) AddWorkspaceTeammateIDs(ids ...ulid.ID) {
	if m.workspaceTeammates == nil {
		m.workspaceTeammates = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.workspaceTeammates[ids[i]] = struct{}{}
	}
}

// ClearWorkspaceTeammates clears the "workspaceTeammates" edge to the WorkspaceTeammate entity.
func (m *WorkspaceMutation) ClearWorkspaceTeammates() {
	m.clearedworkspaceTeammates = true
}

// WorkspaceTeammatesCleared reports if the "workspaceTeammates" edge to the WorkspaceTeammate entity was cleared.
func (m *WorkspaceMutation) WorkspaceTeammatesCleared() bool {
	return m.clearedworkspaceTeammates
}

// RemoveWorkspaceTeammateIDs removes the "workspaceTeammates" edge to the WorkspaceTeammate entity by IDs.
func (m *WorkspaceMutation) RemoveWorkspaceTeammateIDs(ids ...ulid.ID) {
	if m.removedworkspaceTeammates == nil {
		m.removedworkspaceTeammates = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.workspaceTeammates, ids[i])
		m.removedworkspaceTeammates[ids[i]] = struct{}{}
	}
}

// RemovedWorkspaceTeammates returns the removed IDs of the "workspaceTeammates" edge to the WorkspaceTeammate entity.
func (m *WorkspaceMutation) RemovedWorkspaceTeammatesIDs() (ids []ulid.ID) {
	for id := range m.removedworkspaceTeammates {
		ids = append(ids, id)
	}
	return
}

// WorkspaceTeammatesIDs returns the "workspaceTeammates" edge IDs in the mutation.
func (m *WorkspaceMutation) WorkspaceTeammatesIDs() (ids []ulid.ID) {
	for id := range m.workspaceTeammates {
		ids = append(ids, id)
	}
	return
}

// ResetWorkspaceTeammates resets all changes to the "workspaceTeammates" edge.
func (m *WorkspaceMutation) ResetWorkspaceTeammates() {
	m.workspaceTeammates = nil
	m.clearedworkspaceTeammates = false
	m.removedworkspaceTeammates = nil
}

// AddFavoriteWorkspaceIDs adds the "favoriteWorkspaces" edge to the FavoriteWorkspace entity by ids.
func (m *WorkspaceMutation) AddFavoriteWorkspaceIDs(ids ...ulid.ID) {
	if m.favoriteWorkspaces == nil {
		m.favoriteWorkspaces = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.favoriteWorkspaces[ids[i]] = struct{}{}
	}
}

// ClearFavoriteWorkspaces clears the "favoriteWorkspaces" edge to the FavoriteWorkspace entity.
func (m *WorkspaceMutation) ClearFavoriteWorkspaces() {
	m.clearedfavoriteWorkspaces = true
}

// FavoriteWorkspacesCleared reports if the "favoriteWorkspaces" edge to the FavoriteWorkspace entity was cleared.
func (m *WorkspaceMutation) FavoriteWorkspacesCleared() bool {
	return m.clearedfavoriteWorkspaces
}

// RemoveFavoriteWorkspaceIDs removes the "favoriteWorkspaces" edge to the FavoriteWorkspace entity by IDs.
func (m *WorkspaceMutation) RemoveFavoriteWorkspaceIDs(ids ...ulid.ID) {
	if m.removedfavoriteWorkspaces == nil {
		m.removedfavoriteWorkspaces = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.favoriteWorkspaces, ids[i])
		m.removedfavoriteWorkspaces[ids[i]] = struct{}{}
	}
}

// RemovedFavoriteWorkspaces returns the removed IDs of the "favoriteWorkspaces" edge to the FavoriteWorkspace entity.
func (m *WorkspaceMutation) RemovedFavoriteWorkspacesIDs() (ids []ulid.ID) {
	for id := range m.removedfavoriteWorkspaces {
		ids = append(ids, id)
	}
	return
}

// FavoriteWorkspacesIDs returns the "favoriteWorkspaces" edge IDs in the mutation.
func (m *WorkspaceMutation) FavoriteWorkspacesIDs() (ids []ulid.ID) {
	for id := range m.favoriteWorkspaces {
		ids = append(ids, id)
	}
	return
}

// ResetFavoriteWorkspaces resets all changes to the "favoriteWorkspaces" edge.
func (m *WorkspaceMutation) ResetFavoriteWorkspaces() {
	m.favoriteWorkspaces = nil
	m.clearedfavoriteWorkspaces = false
	m.removedfavoriteWorkspaces = nil
}

// AddTeammateTaskTabStatuseIDs adds the "teammateTaskTabStatuses" edge to the TeammateTaskTabStatus entity by ids.
func (m *WorkspaceMutation) AddTeammateTaskTabStatuseIDs(ids ...ulid.ID) {
	if m.teammateTaskTabStatuses == nil {
		m.teammateTaskTabStatuses = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.teammateTaskTabStatuses[ids[i]] = struct{}{}
	}
}

// ClearTeammateTaskTabStatuses clears the "teammateTaskTabStatuses" edge to the TeammateTaskTabStatus entity.
func (m *WorkspaceMutation) ClearTeammateTaskTabStatuses() {
	m.clearedteammateTaskTabStatuses = true
}

// TeammateTaskTabStatusesCleared reports if the "teammateTaskTabStatuses" edge to the TeammateTaskTabStatus entity was cleared.
func (m *WorkspaceMutation) TeammateTaskTabStatusesCleared() bool {
	return m.clearedteammateTaskTabStatuses
}

// RemoveTeammateTaskTabStatuseIDs removes the "teammateTaskTabStatuses" edge to the TeammateTaskTabStatus entity by IDs.
func (m *WorkspaceMutation) RemoveTeammateTaskTabStatuseIDs(ids ...ulid.ID) {
	if m.removedteammateTaskTabStatuses == nil {
		m.removedteammateTaskTabStatuses = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.teammateTaskTabStatuses, ids[i])
		m.removedteammateTaskTabStatuses[ids[i]] = struct{}{}
	}
}

// RemovedTeammateTaskTabStatuses returns the removed IDs of the "teammateTaskTabStatuses" edge to the TeammateTaskTabStatus entity.
func (m *WorkspaceMutation) RemovedTeammateTaskTabStatusesIDs() (ids []ulid.ID) {
	for id := range m.removedteammateTaskTabStatuses {
		ids = append(ids, id)
	}
	return
}

// TeammateTaskTabStatusesIDs returns the "teammateTaskTabStatuses" edge IDs in the mutation.
func (m *WorkspaceMutation) TeammateTaskTabStatusesIDs() (ids []ulid.ID) {
	for id := range m.teammateTaskTabStatuses {
		ids = append(ids, id)
	}
	return
}

// ResetTeammateTaskTabStatuses resets all changes to the "teammateTaskTabStatuses" edge.
func (m *WorkspaceMutation) ResetTeammateTaskTabStatuses() {
	m.teammateTaskTabStatuses = nil
	m.clearedteammateTaskTabStatuses = false
	m.removedteammateTaskTabStatuses = nil
}

// AddTeammateTaskListStatuseIDs adds the "teammateTaskListStatuses" edge to the TeammateTaskListStatus entity by ids.
func (m *WorkspaceMutation) AddTeammateTaskListStatuseIDs(ids ...ulid.ID) {
	if m.teammateTaskListStatuses == nil {
		m.teammateTaskListStatuses = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.teammateTaskListStatuses[ids[i]] = struct{}{}
	}
}

// ClearTeammateTaskListStatuses clears the "teammateTaskListStatuses" edge to the TeammateTaskListStatus entity.
func (m *WorkspaceMutation) ClearTeammateTaskListStatuses() {
	m.clearedteammateTaskListStatuses = true
}

// TeammateTaskListStatusesCleared reports if the "teammateTaskListStatuses" edge to the TeammateTaskListStatus entity was cleared.
func (m *WorkspaceMutation) TeammateTaskListStatusesCleared() bool {
	return m.clearedteammateTaskListStatuses
}

// RemoveTeammateTaskListStatuseIDs removes the "teammateTaskListStatuses" edge to the TeammateTaskListStatus entity by IDs.
func (m *WorkspaceMutation) RemoveTeammateTaskListStatuseIDs(ids ...ulid.ID) {
	if m.removedteammateTaskListStatuses == nil {
		m.removedteammateTaskListStatuses = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.teammateTaskListStatuses, ids[i])
		m.removedteammateTaskListStatuses[ids[i]] = struct{}{}
	}
}

// RemovedTeammateTaskListStatuses returns the removed IDs of the "teammateTaskListStatuses" edge to the TeammateTaskListStatus entity.
func (m *WorkspaceMutation) RemovedTeammateTaskListStatusesIDs() (ids []ulid.ID) {
	for id := range m.removedteammateTaskListStatuses {
		ids = append(ids, id)
	}
	return
}

// TeammateTaskListStatusesIDs returns the "teammateTaskListStatuses" edge IDs in the mutation.
func (m *WorkspaceMutation) TeammateTaskListStatusesIDs() (ids []ulid.ID) {
	for id := range m.teammateTaskListStatuses {
		ids = append(ids, id)
	}
	return
}

// ResetTeammateTaskListStatuses resets all changes to the "teammateTaskListStatuses" edge.
func (m *WorkspaceMutation) ResetTeammateTaskListStatuses() {
	m.teammateTaskListStatuses = nil
	m.clearedteammateTaskListStatuses = false
	m.removedteammateTaskListStatuses = nil
}

// AddTeammateTaskSectionIDs adds the "teammateTaskSections" edge to the TeammateTaskSection entity by ids.
func (m *WorkspaceMutation) AddTeammateTaskSectionIDs(ids ...ulid.ID) {
	if m.teammateTaskSections == nil {
		m.teammateTaskSections = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.teammateTaskSections[ids[i]] = struct{}{}
	}
}

// ClearTeammateTaskSections clears the "teammateTaskSections" edge to the TeammateTaskSection entity.
func (m *WorkspaceMutation) ClearTeammateTaskSections() {
	m.clearedteammateTaskSections = true
}

// TeammateTaskSectionsCleared reports if the "teammateTaskSections" edge to the TeammateTaskSection entity was cleared.
func (m *WorkspaceMutation) TeammateTaskSectionsCleared() bool {
	return m.clearedteammateTaskSections
}

// RemoveTeammateTaskSectionIDs removes the "teammateTaskSections" edge to the TeammateTaskSection entity by IDs.
func (m *WorkspaceMutation) RemoveTeammateTaskSectionIDs(ids ...ulid.ID) {
	if m.removedteammateTaskSections == nil {
		m.removedteammateTaskSections = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.teammateTaskSections, ids[i])
		m.removedteammateTaskSections[ids[i]] = struct{}{}
	}
}

// RemovedTeammateTaskSections returns the removed IDs of the "teammateTaskSections" edge to the TeammateTaskSection entity.
func (m *WorkspaceMutation) RemovedTeammateTaskSectionsIDs() (ids []ulid.ID) {
	for id := range m.removedteammateTaskSections {
		ids = append(ids, id)
	}
	return
}

// TeammateTaskSectionsIDs returns the "teammateTaskSections" edge IDs in the mutation.
func (m *WorkspaceMutation) TeammateTaskSectionsIDs() (ids []ulid.ID) {
	for id := range m.teammateTaskSections {
		ids = append(ids, id)
	}
	return
}

// ResetTeammateTaskSections resets all changes to the "teammateTaskSections" edge.
func (m *WorkspaceMutation) ResetTeammateTaskSections() {
	m.teammateTaskSections = nil
	m.clearedteammateTaskSections = false
	m.removedteammateTaskSections = nil
}

// AddTaskLikeIDs adds the "taskLikes" edge to the TaskLike entity by ids.
func (m *WorkspaceMutation) AddTaskLikeIDs(ids ...ulid.ID) {
	if m.taskLikes == nil {
		m.taskLikes = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.taskLikes[ids[i]] = struct{}{}
	}
}

// ClearTaskLikes clears the "taskLikes" edge to the TaskLike entity.
func (m *WorkspaceMutation) ClearTaskLikes() {
	m.clearedtaskLikes = true
}

// TaskLikesCleared reports if the "taskLikes" edge to the TaskLike entity was cleared.
func (m *WorkspaceMutation) TaskLikesCleared() bool {
	return m.clearedtaskLikes
}

// RemoveTaskLikeIDs removes the "taskLikes" edge to the TaskLike entity by IDs.
func (m *WorkspaceMutation) RemoveTaskLikeIDs(ids ...ulid.ID) {
	if m.removedtaskLikes == nil {
		m.removedtaskLikes = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.taskLikes, ids[i])
		m.removedtaskLikes[ids[i]] = struct{}{}
	}
}

// RemovedTaskLikes returns the removed IDs of the "taskLikes" edge to the TaskLike entity.
func (m *WorkspaceMutation) RemovedTaskLikesIDs() (ids []ulid.ID) {
	for id := range m.removedtaskLikes {
		ids = append(ids, id)
	}
	return
}

// TaskLikesIDs returns the "taskLikes" edge IDs in the mutation.
func (m *WorkspaceMutation) TaskLikesIDs() (ids []ulid.ID) {
	for id := range m.taskLikes {
		ids = append(ids, id)
	}
	return
}

// ResetTaskLikes resets all changes to the "taskLikes" edge.
func (m *WorkspaceMutation) ResetTaskLikes() {
	m.taskLikes = nil
	m.clearedtaskLikes = false
	m.removedtaskLikes = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *WorkspaceMutation) AddTagIDs(ids ...ulid.ID) {
	if m.tags == nil {
		m.tags = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *WorkspaceMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *WorkspaceMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *WorkspaceMutation) RemoveTagIDs(ids ...ulid.ID) {
	if m.removedtags == nil {
		m.removedtags = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *WorkspaceMutation) RemovedTagsIDs() (ids []ulid.ID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *WorkspaceMutation) TagsIDs() (ids []ulid.ID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *WorkspaceMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddTeammateTaskColumnIDs adds the "teammateTaskColumns" edge to the TeammateTaskColumn entity by ids.
func (m *WorkspaceMutation) AddTeammateTaskColumnIDs(ids ...ulid.ID) {
	if m.teammateTaskColumns == nil {
		m.teammateTaskColumns = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.teammateTaskColumns[ids[i]] = struct{}{}
	}
}

// ClearTeammateTaskColumns clears the "teammateTaskColumns" edge to the TeammateTaskColumn entity.
func (m *WorkspaceMutation) ClearTeammateTaskColumns() {
	m.clearedteammateTaskColumns = true
}

// TeammateTaskColumnsCleared reports if the "teammateTaskColumns" edge to the TeammateTaskColumn entity was cleared.
func (m *WorkspaceMutation) TeammateTaskColumnsCleared() bool {
	return m.clearedteammateTaskColumns
}

// RemoveTeammateTaskColumnIDs removes the "teammateTaskColumns" edge to the TeammateTaskColumn entity by IDs.
func (m *WorkspaceMutation) RemoveTeammateTaskColumnIDs(ids ...ulid.ID) {
	if m.removedteammateTaskColumns == nil {
		m.removedteammateTaskColumns = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.teammateTaskColumns, ids[i])
		m.removedteammateTaskColumns[ids[i]] = struct{}{}
	}
}

// RemovedTeammateTaskColumns returns the removed IDs of the "teammateTaskColumns" edge to the TeammateTaskColumn entity.
func (m *WorkspaceMutation) RemovedTeammateTaskColumnsIDs() (ids []ulid.ID) {
	for id := range m.removedteammateTaskColumns {
		ids = append(ids, id)
	}
	return
}

// TeammateTaskColumnsIDs returns the "teammateTaskColumns" edge IDs in the mutation.
func (m *WorkspaceMutation) TeammateTaskColumnsIDs() (ids []ulid.ID) {
	for id := range m.teammateTaskColumns {
		ids = append(ids, id)
	}
	return
}

// ResetTeammateTaskColumns resets all changes to the "teammateTaskColumns" edge.
func (m *WorkspaceMutation) ResetTeammateTaskColumns() {
	m.teammateTaskColumns = nil
	m.clearedteammateTaskColumns = false
	m.removedteammateTaskColumns = nil
}

// AddTeammateTaskIDs adds the "teammateTasks" edge to the TeammateTask entity by ids.
func (m *WorkspaceMutation) AddTeammateTaskIDs(ids ...ulid.ID) {
	if m.teammateTasks == nil {
		m.teammateTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.teammateTasks[ids[i]] = struct{}{}
	}
}

// ClearTeammateTasks clears the "teammateTasks" edge to the TeammateTask entity.
func (m *WorkspaceMutation) ClearTeammateTasks() {
	m.clearedteammateTasks = true
}

// TeammateTasksCleared reports if the "teammateTasks" edge to the TeammateTask entity was cleared.
func (m *WorkspaceMutation) TeammateTasksCleared() bool {
	return m.clearedteammateTasks
}

// RemoveTeammateTaskIDs removes the "teammateTasks" edge to the TeammateTask entity by IDs.
func (m *WorkspaceMutation) RemoveTeammateTaskIDs(ids ...ulid.ID) {
	if m.removedteammateTasks == nil {
		m.removedteammateTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.teammateTasks, ids[i])
		m.removedteammateTasks[ids[i]] = struct{}{}
	}
}

// RemovedTeammateTasks returns the removed IDs of the "teammateTasks" edge to the TeammateTask entity.
func (m *WorkspaceMutation) RemovedTeammateTasksIDs() (ids []ulid.ID) {
	for id := range m.removedteammateTasks {
		ids = append(ids, id)
	}
	return
}

// TeammateTasksIDs returns the "teammateTasks" edge IDs in the mutation.
func (m *WorkspaceMutation) TeammateTasksIDs() (ids []ulid.ID) {
	for id := range m.teammateTasks {
		ids = append(ids, id)
	}
	return
}

// ResetTeammateTasks resets all changes to the "teammateTasks" edge.
func (m *WorkspaceMutation) ResetTeammateTasks() {
	m.teammateTasks = nil
	m.clearedteammateTasks = false
	m.removedteammateTasks = nil
}

// AddDeletedTasksRefIDs adds the "deletedTasksRef" edge to the DeletedTask entity by ids.
func (m *WorkspaceMutation) AddDeletedTasksRefIDs(ids ...ulid.ID) {
	if m.deletedTasksRef == nil {
		m.deletedTasksRef = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.deletedTasksRef[ids[i]] = struct{}{}
	}
}

// ClearDeletedTasksRef clears the "deletedTasksRef" edge to the DeletedTask entity.
func (m *WorkspaceMutation) ClearDeletedTasksRef() {
	m.cleareddeletedTasksRef = true
}

// DeletedTasksRefCleared reports if the "deletedTasksRef" edge to the DeletedTask entity was cleared.
func (m *WorkspaceMutation) DeletedTasksRefCleared() bool {
	return m.cleareddeletedTasksRef
}

// RemoveDeletedTasksRefIDs removes the "deletedTasksRef" edge to the DeletedTask entity by IDs.
func (m *WorkspaceMutation) RemoveDeletedTasksRefIDs(ids ...ulid.ID) {
	if m.removeddeletedTasksRef == nil {
		m.removeddeletedTasksRef = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.deletedTasksRef, ids[i])
		m.removeddeletedTasksRef[ids[i]] = struct{}{}
	}
}

// RemovedDeletedTasksRef returns the removed IDs of the "deletedTasksRef" edge to the DeletedTask entity.
func (m *WorkspaceMutation) RemovedDeletedTasksRefIDs() (ids []ulid.ID) {
	for id := range m.removeddeletedTasksRef {
		ids = append(ids, id)
	}
	return
}

// DeletedTasksRefIDs returns the "deletedTasksRef" edge IDs in the mutation.
func (m *WorkspaceMutation) DeletedTasksRefIDs() (ids []ulid.ID) {
	for id := range m.deletedTasksRef {
		ids = append(ids, id)
	}
	return
}

// ResetDeletedTasksRef resets all changes to the "deletedTasksRef" edge.
func (m *WorkspaceMutation) ResetDeletedTasksRef() {
	m.deletedTasksRef = nil
	m.cleareddeletedTasksRef = false
	m.removeddeletedTasksRef = nil
}

// AddWorkspaceActivityIDs adds the "workspaceActivities" edge to the WorkspaceActivity entity by ids.
func (m *WorkspaceMutation) AddWorkspaceActivityIDs(ids ...ulid.ID) {
	if m.workspaceActivities == nil {
		m.workspaceActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.workspaceActivities[ids[i]] = struct{}{}
	}
}

// ClearWorkspaceActivities clears the "workspaceActivities" edge to the WorkspaceActivity entity.
func (m *WorkspaceMutation) ClearWorkspaceActivities() {
	m.clearedworkspaceActivities = true
}

// WorkspaceActivitiesCleared reports if the "workspaceActivities" edge to the WorkspaceActivity entity was cleared.
func (m *WorkspaceMutation) WorkspaceActivitiesCleared() bool {
	return m.clearedworkspaceActivities
}

// RemoveWorkspaceActivityIDs removes the "workspaceActivities" edge to the WorkspaceActivity entity by IDs.
func (m *WorkspaceMutation) RemoveWorkspaceActivityIDs(ids ...ulid.ID) {
	if m.removedworkspaceActivities == nil {
		m.removedworkspaceActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.workspaceActivities, ids[i])
		m.removedworkspaceActivities[ids[i]] = struct{}{}
	}
}

// RemovedWorkspaceActivities returns the removed IDs of the "workspaceActivities" edge to the WorkspaceActivity entity.
func (m *WorkspaceMutation) RemovedWorkspaceActivitiesIDs() (ids []ulid.ID) {
	for id := range m.removedworkspaceActivities {
		ids = append(ids, id)
	}
	return
}

// WorkspaceActivitiesIDs returns the "workspaceActivities" edge IDs in the mutation.
func (m *WorkspaceMutation) WorkspaceActivitiesIDs() (ids []ulid.ID) {
	for id := range m.workspaceActivities {
		ids = append(ids, id)
	}
	return
}

// ResetWorkspaceActivities resets all changes to the "workspaceActivities" edge.
func (m *WorkspaceMutation) ResetWorkspaceActivities() {
	m.workspaceActivities = nil
	m.clearedworkspaceActivities = false
	m.removedworkspaceActivities = nil
}

// AddTaskActivityIDs adds the "taskActivities" edge to the TaskActivity entity by ids.
func (m *WorkspaceMutation) AddTaskActivityIDs(ids ...ulid.ID) {
	if m.taskActivities == nil {
		m.taskActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.taskActivities[ids[i]] = struct{}{}
	}
}

// ClearTaskActivities clears the "taskActivities" edge to the TaskActivity entity.
func (m *WorkspaceMutation) ClearTaskActivities() {
	m.clearedtaskActivities = true
}

// TaskActivitiesCleared reports if the "taskActivities" edge to the TaskActivity entity was cleared.
func (m *WorkspaceMutation) TaskActivitiesCleared() bool {
	return m.clearedtaskActivities
}

// RemoveTaskActivityIDs removes the "taskActivities" edge to the TaskActivity entity by IDs.
func (m *WorkspaceMutation) RemoveTaskActivityIDs(ids ...ulid.ID) {
	if m.removedtaskActivities == nil {
		m.removedtaskActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.taskActivities, ids[i])
		m.removedtaskActivities[ids[i]] = struct{}{}
	}
}

// RemovedTaskActivities returns the removed IDs of the "taskActivities" edge to the TaskActivity entity.
func (m *WorkspaceMutation) RemovedTaskActivitiesIDs() (ids []ulid.ID) {
	for id := range m.removedtaskActivities {
		ids = append(ids, id)
	}
	return
}

// TaskActivitiesIDs returns the "taskActivities" edge IDs in the mutation.
func (m *WorkspaceMutation) TaskActivitiesIDs() (ids []ulid.ID) {
	for id := range m.taskActivities {
		ids = append(ids, id)
	}
	return
}

// ResetTaskActivities resets all changes to the "taskActivities" edge.
func (m *WorkspaceMutation) ResetTaskActivities() {
	m.taskActivities = nil
	m.clearedtaskActivities = false
	m.removedtaskActivities = nil
}

// AddArchivedTaskActivityIDs adds the "archivedTaskActivities" edge to the ArchivedTaskActivity entity by ids.
func (m *WorkspaceMutation) AddArchivedTaskActivityIDs(ids ...ulid.ID) {
	if m.archivedTaskActivities == nil {
		m.archivedTaskActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.archivedTaskActivities[ids[i]] = struct{}{}
	}
}

// ClearArchivedTaskActivities clears the "archivedTaskActivities" edge to the ArchivedTaskActivity entity.
func (m *WorkspaceMutation) ClearArchivedTaskActivities() {
	m.clearedarchivedTaskActivities = true
}

// ArchivedTaskActivitiesCleared reports if the "archivedTaskActivities" edge to the ArchivedTaskActivity entity was cleared.
func (m *WorkspaceMutation) ArchivedTaskActivitiesCleared() bool {
	return m.clearedarchivedTaskActivities
}

// RemoveArchivedTaskActivityIDs removes the "archivedTaskActivities" edge to the ArchivedTaskActivity entity by IDs.
func (m *WorkspaceMutation) RemoveArchivedTaskActivityIDs(ids ...ulid.ID) {
	if m.removedarchivedTaskActivities == nil {
		m.removedarchivedTaskActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.archivedTaskActivities, ids[i])
		m.removedarchivedTaskActivities[ids[i]] = struct{}{}
	}
}

// RemovedArchivedTaskActivities returns the removed IDs of the "archivedTaskActivities" edge to the ArchivedTaskActivity entity.
func (m *WorkspaceMutation) RemovedArchivedTaskActivitiesIDs() (ids []ulid.ID) {
	for id := range m.removedarchivedTaskActivities {
		ids = append(ids, id)
	}
	return
}

// ArchivedTaskActivitiesIDs returns the "archivedTaskActivities" edge IDs in the mutation.
func (m *WorkspaceMutation) ArchivedTaskActivitiesIDs() (ids []ulid.ID) {
	for id := range m.archivedTaskActivities {
		ids = append(ids, id)
	}
	return
}

// ResetArchivedTaskActivities resets all changes to the "archivedTaskActivities" edge.
func (m *WorkspaceMutation) ResetArchivedTaskActivities() {
	m.archivedTaskActivities = nil
	m.clearedarchivedTaskActivities = false
	m.removedarchivedTaskActivities = nil
}

// AddArchivedWorkspaceActivityIDs adds the "archivedWorkspaceActivities" edge to the ArchivedWorkspaceActivity entity by ids.
func (m *WorkspaceMutation) AddArchivedWorkspaceActivityIDs(ids ...ulid.ID) {
	if m.archivedWorkspaceActivities == nil {
		m.archivedWorkspaceActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.archivedWorkspaceActivities[ids[i]] = struct{}{}
	}
}

// ClearArchivedWorkspaceActivities clears the "archivedWorkspaceActivities" edge to the ArchivedWorkspaceActivity entity.
func (m *WorkspaceMutation) ClearArchivedWorkspaceActivities() {
	m.clearedarchivedWorkspaceActivities = true
}

// ArchivedWorkspaceActivitiesCleared reports if the "archivedWorkspaceActivities" edge to the ArchivedWorkspaceActivity entity was cleared.
func (m *WorkspaceMutation) ArchivedWorkspaceActivitiesCleared() bool {
	return m.clearedarchivedWorkspaceActivities
}

// RemoveArchivedWorkspaceActivityIDs removes the "archivedWorkspaceActivities" edge to the ArchivedWorkspaceActivity entity by IDs.
func (m *WorkspaceMutation) RemoveArchivedWorkspaceActivityIDs(ids ...ulid.ID) {
	if m.removedarchivedWorkspaceActivities == nil {
		m.removedarchivedWorkspaceActivities = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.archivedWorkspaceActivities, ids[i])
		m.removedarchivedWorkspaceActivities[ids[i]] = struct{}{}
	}
}

// RemovedArchivedWorkspaceActivities returns the removed IDs of the "archivedWorkspaceActivities" edge to the ArchivedWorkspaceActivity entity.
func (m *WorkspaceMutation) RemovedArchivedWorkspaceActivitiesIDs() (ids []ulid.ID) {
	for id := range m.removedarchivedWorkspaceActivities {
		ids = append(ids, id)
	}
	return
}

// ArchivedWorkspaceActivitiesIDs returns the "archivedWorkspaceActivities" edge IDs in the mutation.
func (m *WorkspaceMutation) ArchivedWorkspaceActivitiesIDs() (ids []ulid.ID) {
	for id := range m.archivedWorkspaceActivities {
		ids = append(ids, id)
	}
	return
}

// ResetArchivedWorkspaceActivities resets all changes to the "archivedWorkspaceActivities" edge.
func (m *WorkspaceMutation) ResetArchivedWorkspaceActivities() {
	m.archivedWorkspaceActivities = nil
	m.clearedarchivedWorkspaceActivities = false
	m.removedarchivedWorkspaceActivities = nil
}

// Where appends a list predicates to the WorkspaceMutation builder.
func (m *WorkspaceMutation) Where(ps ...predicate.Workspace) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WorkspaceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Workspace).
func (m *WorkspaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkspaceMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.teammate != nil {
		fields = append(fields, workspace.FieldCreatedBy)
	}
	if m.name != nil {
		fields = append(fields, workspace.FieldName)
	}
	if m.description != nil {
		fields = append(fields, workspace.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, workspace.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workspace.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkspaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workspace.FieldCreatedBy:
		return m.CreatedBy()
	case workspace.FieldName:
		return m.Name()
	case workspace.FieldDescription:
		return m.Description()
	case workspace.FieldCreatedAt:
		return m.CreatedAt()
	case workspace.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkspaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workspace.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case workspace.FieldName:
		return m.OldName(ctx)
	case workspace.FieldDescription:
		return m.OldDescription(ctx)
	case workspace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workspace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Workspace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkspaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workspace.FieldCreatedBy:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case workspace.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workspace.FieldDescription:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workspace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workspace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Workspace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkspaceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkspaceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkspaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Workspace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkspaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkspaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkspaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Workspace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkspaceMutation) ResetField(name string) error {
	switch name {
	case workspace.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case workspace.FieldName:
		m.ResetName()
		return nil
	case workspace.FieldDescription:
		m.ResetDescription()
		return nil
	case workspace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workspace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Workspace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkspaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 16)
	if m.teammate != nil {
		edges = append(edges, workspace.EdgeTeammate)
	}
	if m.projects != nil {
		edges = append(edges, workspace.EdgeProjects)
	}
	if m.workspaceTeammates != nil {
		edges = append(edges, workspace.EdgeWorkspaceTeammates)
	}
	if m.favoriteWorkspaces != nil {
		edges = append(edges, workspace.EdgeFavoriteWorkspaces)
	}
	if m.teammateTaskTabStatuses != nil {
		edges = append(edges, workspace.EdgeTeammateTaskTabStatuses)
	}
	if m.teammateTaskListStatuses != nil {
		edges = append(edges, workspace.EdgeTeammateTaskListStatuses)
	}
	if m.teammateTaskSections != nil {
		edges = append(edges, workspace.EdgeTeammateTaskSections)
	}
	if m.taskLikes != nil {
		edges = append(edges, workspace.EdgeTaskLikes)
	}
	if m.tags != nil {
		edges = append(edges, workspace.EdgeTags)
	}
	if m.teammateTaskColumns != nil {
		edges = append(edges, workspace.EdgeTeammateTaskColumns)
	}
	if m.teammateTasks != nil {
		edges = append(edges, workspace.EdgeTeammateTasks)
	}
	if m.deletedTasksRef != nil {
		edges = append(edges, workspace.EdgeDeletedTasksRef)
	}
	if m.workspaceActivities != nil {
		edges = append(edges, workspace.EdgeWorkspaceActivities)
	}
	if m.taskActivities != nil {
		edges = append(edges, workspace.EdgeTaskActivities)
	}
	if m.archivedTaskActivities != nil {
		edges = append(edges, workspace.EdgeArchivedTaskActivities)
	}
	if m.archivedWorkspaceActivities != nil {
		edges = append(edges, workspace.EdgeArchivedWorkspaceActivities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkspaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workspace.EdgeTeammate:
		if id := m.teammate; id != nil {
			return []ent.Value{*id}
		}
	case workspace.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeWorkspaceTeammates:
		ids := make([]ent.Value, 0, len(m.workspaceTeammates))
		for id := range m.workspaceTeammates {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeFavoriteWorkspaces:
		ids := make([]ent.Value, 0, len(m.favoriteWorkspaces))
		for id := range m.favoriteWorkspaces {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeTeammateTaskTabStatuses:
		ids := make([]ent.Value, 0, len(m.teammateTaskTabStatuses))
		for id := range m.teammateTaskTabStatuses {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeTeammateTaskListStatuses:
		ids := make([]ent.Value, 0, len(m.teammateTaskListStatuses))
		for id := range m.teammateTaskListStatuses {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeTeammateTaskSections:
		ids := make([]ent.Value, 0, len(m.teammateTaskSections))
		for id := range m.teammateTaskSections {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeTaskLikes:
		ids := make([]ent.Value, 0, len(m.taskLikes))
		for id := range m.taskLikes {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeTeammateTaskColumns:
		ids := make([]ent.Value, 0, len(m.teammateTaskColumns))
		for id := range m.teammateTaskColumns {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeTeammateTasks:
		ids := make([]ent.Value, 0, len(m.teammateTasks))
		for id := range m.teammateTasks {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeDeletedTasksRef:
		ids := make([]ent.Value, 0, len(m.deletedTasksRef))
		for id := range m.deletedTasksRef {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeWorkspaceActivities:
		ids := make([]ent.Value, 0, len(m.workspaceActivities))
		for id := range m.workspaceActivities {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeTaskActivities:
		ids := make([]ent.Value, 0, len(m.taskActivities))
		for id := range m.taskActivities {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeArchivedTaskActivities:
		ids := make([]ent.Value, 0, len(m.archivedTaskActivities))
		for id := range m.archivedTaskActivities {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeArchivedWorkspaceActivities:
		ids := make([]ent.Value, 0, len(m.archivedWorkspaceActivities))
		for id := range m.archivedWorkspaceActivities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkspaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 16)
	if m.removedprojects != nil {
		edges = append(edges, workspace.EdgeProjects)
	}
	if m.removedworkspaceTeammates != nil {
		edges = append(edges, workspace.EdgeWorkspaceTeammates)
	}
	if m.removedfavoriteWorkspaces != nil {
		edges = append(edges, workspace.EdgeFavoriteWorkspaces)
	}
	if m.removedteammateTaskTabStatuses != nil {
		edges = append(edges, workspace.EdgeTeammateTaskTabStatuses)
	}
	if m.removedteammateTaskListStatuses != nil {
		edges = append(edges, workspace.EdgeTeammateTaskListStatuses)
	}
	if m.removedteammateTaskSections != nil {
		edges = append(edges, workspace.EdgeTeammateTaskSections)
	}
	if m.removedtaskLikes != nil {
		edges = append(edges, workspace.EdgeTaskLikes)
	}
	if m.removedtags != nil {
		edges = append(edges, workspace.EdgeTags)
	}
	if m.removedteammateTaskColumns != nil {
		edges = append(edges, workspace.EdgeTeammateTaskColumns)
	}
	if m.removedteammateTasks != nil {
		edges = append(edges, workspace.EdgeTeammateTasks)
	}
	if m.removeddeletedTasksRef != nil {
		edges = append(edges, workspace.EdgeDeletedTasksRef)
	}
	if m.removedworkspaceActivities != nil {
		edges = append(edges, workspace.EdgeWorkspaceActivities)
	}
	if m.removedtaskActivities != nil {
		edges = append(edges, workspace.EdgeTaskActivities)
	}
	if m.removedarchivedTaskActivities != nil {
		edges = append(edges, workspace.EdgeArchivedTaskActivities)
	}
	if m.removedarchivedWorkspaceActivities != nil {
		edges = append(edges, workspace.EdgeArchivedWorkspaceActivities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkspaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workspace.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeWorkspaceTeammates:
		ids := make([]ent.Value, 0, len(m.removedworkspaceTeammates))
		for id := range m.removedworkspaceTeammates {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeFavoriteWorkspaces:
		ids := make([]ent.Value, 0, len(m.removedfavoriteWorkspaces))
		for id := range m.removedfavoriteWorkspaces {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeTeammateTaskTabStatuses:
		ids := make([]ent.Value, 0, len(m.removedteammateTaskTabStatuses))
		for id := range m.removedteammateTaskTabStatuses {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeTeammateTaskListStatuses:
		ids := make([]ent.Value, 0, len(m.removedteammateTaskListStatuses))
		for id := range m.removedteammateTaskListStatuses {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeTeammateTaskSections:
		ids := make([]ent.Value, 0, len(m.removedteammateTaskSections))
		for id := range m.removedteammateTaskSections {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeTaskLikes:
		ids := make([]ent.Value, 0, len(m.removedtaskLikes))
		for id := range m.removedtaskLikes {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeTeammateTaskColumns:
		ids := make([]ent.Value, 0, len(m.removedteammateTaskColumns))
		for id := range m.removedteammateTaskColumns {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeTeammateTasks:
		ids := make([]ent.Value, 0, len(m.removedteammateTasks))
		for id := range m.removedteammateTasks {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeDeletedTasksRef:
		ids := make([]ent.Value, 0, len(m.removeddeletedTasksRef))
		for id := range m.removeddeletedTasksRef {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeWorkspaceActivities:
		ids := make([]ent.Value, 0, len(m.removedworkspaceActivities))
		for id := range m.removedworkspaceActivities {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeTaskActivities:
		ids := make([]ent.Value, 0, len(m.removedtaskActivities))
		for id := range m.removedtaskActivities {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeArchivedTaskActivities:
		ids := make([]ent.Value, 0, len(m.removedarchivedTaskActivities))
		for id := range m.removedarchivedTaskActivities {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeArchivedWorkspaceActivities:
		ids := make([]ent.Value, 0, len(m.removedarchivedWorkspaceActivities))
		for id := range m.removedarchivedWorkspaceActivities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkspaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 16)
	if m.clearedteammate {
		edges = append(edges, workspace.EdgeTeammate)
	}
	if m.clearedprojects {
		edges = append(edges, workspace.EdgeProjects)
	}
	if m.clearedworkspaceTeammates {
		edges = append(edges, workspace.EdgeWorkspaceTeammates)
	}
	if m.clearedfavoriteWorkspaces {
		edges = append(edges, workspace.EdgeFavoriteWorkspaces)
	}
	if m.clearedteammateTaskTabStatuses {
		edges = append(edges, workspace.EdgeTeammateTaskTabStatuses)
	}
	if m.clearedteammateTaskListStatuses {
		edges = append(edges, workspace.EdgeTeammateTaskListStatuses)
	}
	if m.clearedteammateTaskSections {
		edges = append(edges, workspace.EdgeTeammateTaskSections)
	}
	if m.clearedtaskLikes {
		edges = append(edges, workspace.EdgeTaskLikes)
	}
	if m.clearedtags {
		edges = append(edges, workspace.EdgeTags)
	}
	if m.clearedteammateTaskColumns {
		edges = append(edges, workspace.EdgeTeammateTaskColumns)
	}
	if m.clearedteammateTasks {
		edges = append(edges, workspace.EdgeTeammateTasks)
	}
	if m.cleareddeletedTasksRef {
		edges = append(edges, workspace.EdgeDeletedTasksRef)
	}
	if m.clearedworkspaceActivities {
		edges = append(edges, workspace.EdgeWorkspaceActivities)
	}
	if m.clearedtaskActivities {
		edges = append(edges, workspace.EdgeTaskActivities)
	}
	if m.clearedarchivedTaskActivities {
		edges = append(edges, workspace.EdgeArchivedTaskActivities)
	}
	if m.clearedarchivedWorkspaceActivities {
		edges = append(edges, workspace.EdgeArchivedWorkspaceActivities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkspaceMutation) EdgeCleared(name string) bool {
	switch name {
	case workspace.EdgeTeammate:
		return m.clearedteammate
	case workspace.EdgeProjects:
		return m.clearedprojects
	case workspace.EdgeWorkspaceTeammates:
		return m.clearedworkspaceTeammates
	case workspace.EdgeFavoriteWorkspaces:
		return m.clearedfavoriteWorkspaces
	case workspace.EdgeTeammateTaskTabStatuses:
		return m.clearedteammateTaskTabStatuses
	case workspace.EdgeTeammateTaskListStatuses:
		return m.clearedteammateTaskListStatuses
	case workspace.EdgeTeammateTaskSections:
		return m.clearedteammateTaskSections
	case workspace.EdgeTaskLikes:
		return m.clearedtaskLikes
	case workspace.EdgeTags:
		return m.clearedtags
	case workspace.EdgeTeammateTaskColumns:
		return m.clearedteammateTaskColumns
	case workspace.EdgeTeammateTasks:
		return m.clearedteammateTasks
	case workspace.EdgeDeletedTasksRef:
		return m.cleareddeletedTasksRef
	case workspace.EdgeWorkspaceActivities:
		return m.clearedworkspaceActivities
	case workspace.EdgeTaskActivities:
		return m.clearedtaskActivities
	case workspace.EdgeArchivedTaskActivities:
		return m.clearedarchivedTaskActivities
	case workspace.EdgeArchivedWorkspaceActivities:
		return m.clearedarchivedWorkspaceActivities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkspaceMutation) ClearEdge(name string) error {
	switch name {
	case workspace.EdgeTeammate:
		m.ClearTeammate()
		return nil
	}
	return fmt.Errorf("unknown Workspace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkspaceMutation) ResetEdge(name string) error {
	switch name {
	case workspace.EdgeTeammate:
		m.ResetTeammate()
		return nil
	case workspace.EdgeProjects:
		m.ResetProjects()
		return nil
	case workspace.EdgeWorkspaceTeammates:
		m.ResetWorkspaceTeammates()
		return nil
	case workspace.EdgeFavoriteWorkspaces:
		m.ResetFavoriteWorkspaces()
		return nil
	case workspace.EdgeTeammateTaskTabStatuses:
		m.ResetTeammateTaskTabStatuses()
		return nil
	case workspace.EdgeTeammateTaskListStatuses:
		m.ResetTeammateTaskListStatuses()
		return nil
	case workspace.EdgeTeammateTaskSections:
		m.ResetTeammateTaskSections()
		return nil
	case workspace.EdgeTaskLikes:
		m.ResetTaskLikes()
		return nil
	case workspace.EdgeTags:
		m.ResetTags()
		return nil
	case workspace.EdgeTeammateTaskColumns:
		m.ResetTeammateTaskColumns()
		return nil
	case workspace.EdgeTeammateTasks:
		m.ResetTeammateTasks()
		return nil
	case workspace.EdgeDeletedTasksRef:
		m.ResetDeletedTasksRef()
		return nil
	case workspace.EdgeWorkspaceActivities:
		m.ResetWorkspaceActivities()
		return nil
	case workspace.EdgeTaskActivities:
		m.ResetTaskActivities()
		return nil
	case workspace.EdgeArchivedTaskActivities:
		m.ResetArchivedTaskActivities()
		return nil
	case workspace.EdgeArchivedWorkspaceActivities:
		m.ResetArchivedWorkspaceActivities()
		return nil
	}
	return fmt.Errorf("unknown Workspace edge %s", name)
}

// WorkspaceActivityMutation represents an operation that mutates the WorkspaceActivity nodes in the graph.
type WorkspaceActivityMutation struct {
	config
	op                            Op
	typ                           string
	id                            *ulid.ID
	created_at                    *time.Time
	updated_at                    *time.Time
	clearedFields                 map[string]struct{}
	activityType                  *ulid.ID
	clearedactivityType           bool
	workspace                     *ulid.ID
	clearedworkspace              bool
	project                       *ulid.ID
	clearedproject                bool
	teammate                      *ulid.ID
	clearedteammate               bool
	workspaceActivityTasks        map[ulid.ID]struct{}
	removedworkspaceActivityTasks map[ulid.ID]struct{}
	clearedworkspaceActivityTasks bool
	done                          bool
	oldValue                      func(context.Context) (*WorkspaceActivity, error)
	predicates                    []predicate.WorkspaceActivity
}

var _ ent.Mutation = (*WorkspaceActivityMutation)(nil)

// workspaceactivityOption allows management of the mutation configuration using functional options.
type workspaceactivityOption func(*WorkspaceActivityMutation)

// newWorkspaceActivityMutation creates new mutation for the WorkspaceActivity entity.
func newWorkspaceActivityMutation(c config, op Op, opts ...workspaceactivityOption) *WorkspaceActivityMutation {
	m := &WorkspaceActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkspaceActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkspaceActivityID sets the ID field of the mutation.
func withWorkspaceActivityID(id ulid.ID) workspaceactivityOption {
	return func(m *WorkspaceActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkspaceActivity
		)
		m.oldValue = func(ctx context.Context) (*WorkspaceActivity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkspaceActivity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkspaceActivity sets the old WorkspaceActivity of the mutation.
func withWorkspaceActivity(node *WorkspaceActivity) workspaceactivityOption {
	return func(m *WorkspaceActivityMutation) {
		m.oldValue = func(context.Context) (*WorkspaceActivity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkspaceActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkspaceActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkspaceActivity entities.
func (m *WorkspaceActivityMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkspaceActivityMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkspaceActivityMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkspaceActivity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetActivityTypeID sets the "activity_type_id" field.
func (m *WorkspaceActivityMutation) SetActivityTypeID(u ulid.ID) {
	m.activityType = &u
}

// ActivityTypeID returns the value of the "activity_type_id" field in the mutation.
func (m *WorkspaceActivityMutation) ActivityTypeID() (r ulid.ID, exists bool) {
	v := m.activityType
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityTypeID returns the old "activity_type_id" field's value of the WorkspaceActivity entity.
// If the WorkspaceActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceActivityMutation) OldActivityTypeID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivityTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivityTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityTypeID: %w", err)
	}
	return oldValue.ActivityTypeID, nil
}

// ResetActivityTypeID resets all changes to the "activity_type_id" field.
func (m *WorkspaceActivityMutation) ResetActivityTypeID() {
	m.activityType = nil
}

// SetWorkspaceID sets the "workspace_id" field.
func (m *WorkspaceActivityMutation) SetWorkspaceID(u ulid.ID) {
	m.workspace = &u
}

// WorkspaceID returns the value of the "workspace_id" field in the mutation.
func (m *WorkspaceActivityMutation) WorkspaceID() (r ulid.ID, exists bool) {
	v := m.workspace
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspaceID returns the old "workspace_id" field's value of the WorkspaceActivity entity.
// If the WorkspaceActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceActivityMutation) OldWorkspaceID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspaceID: %w", err)
	}
	return oldValue.WorkspaceID, nil
}

// ResetWorkspaceID resets all changes to the "workspace_id" field.
func (m *WorkspaceActivityMutation) ResetWorkspaceID() {
	m.workspace = nil
}

// SetProjectID sets the "project_id" field.
func (m *WorkspaceActivityMutation) SetProjectID(u ulid.ID) {
	m.project = &u
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *WorkspaceActivityMutation) ProjectID() (r ulid.ID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the WorkspaceActivity entity.
// If the WorkspaceActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceActivityMutation) OldProjectID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *WorkspaceActivityMutation) ResetProjectID() {
	m.project = nil
}

// SetTeammateID sets the "teammate_id" field.
func (m *WorkspaceActivityMutation) SetTeammateID(u ulid.ID) {
	m.teammate = &u
}

// TeammateID returns the value of the "teammate_id" field in the mutation.
func (m *WorkspaceActivityMutation) TeammateID() (r ulid.ID, exists bool) {
	v := m.teammate
	if v == nil {
		return
	}
	return *v, true
}

// OldTeammateID returns the old "teammate_id" field's value of the WorkspaceActivity entity.
// If the WorkspaceActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceActivityMutation) OldTeammateID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeammateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeammateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeammateID: %w", err)
	}
	return oldValue.TeammateID, nil
}

// ResetTeammateID resets all changes to the "teammate_id" field.
func (m *WorkspaceActivityMutation) ResetTeammateID() {
	m.teammate = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkspaceActivityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkspaceActivityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkspaceActivity entity.
// If the WorkspaceActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceActivityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkspaceActivityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkspaceActivityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkspaceActivityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkspaceActivity entity.
// If the WorkspaceActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceActivityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkspaceActivityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearActivityType clears the "activityType" edge to the ActivityType entity.
func (m *WorkspaceActivityMutation) ClearActivityType() {
	m.clearedactivityType = true
}

// ActivityTypeCleared reports if the "activityType" edge to the ActivityType entity was cleared.
func (m *WorkspaceActivityMutation) ActivityTypeCleared() bool {
	return m.clearedactivityType
}

// ActivityTypeIDs returns the "activityType" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActivityTypeID instead. It exists only for internal usage by the builders.
func (m *WorkspaceActivityMutation) ActivityTypeIDs() (ids []ulid.ID) {
	if id := m.activityType; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivityType resets all changes to the "activityType" edge.
func (m *WorkspaceActivityMutation) ResetActivityType() {
	m.activityType = nil
	m.clearedactivityType = false
}

// ClearWorkspace clears the "workspace" edge to the Workspace entity.
func (m *WorkspaceActivityMutation) ClearWorkspace() {
	m.clearedworkspace = true
}

// WorkspaceCleared reports if the "workspace" edge to the Workspace entity was cleared.
func (m *WorkspaceActivityMutation) WorkspaceCleared() bool {
	return m.clearedworkspace
}

// WorkspaceIDs returns the "workspace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkspaceID instead. It exists only for internal usage by the builders.
func (m *WorkspaceActivityMutation) WorkspaceIDs() (ids []ulid.ID) {
	if id := m.workspace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkspace resets all changes to the "workspace" edge.
func (m *WorkspaceActivityMutation) ResetWorkspace() {
	m.workspace = nil
	m.clearedworkspace = false
}

// ClearProject clears the "project" edge to the Project entity.
func (m *WorkspaceActivityMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *WorkspaceActivityMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *WorkspaceActivityMutation) ProjectIDs() (ids []ulid.ID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *WorkspaceActivityMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearTeammate clears the "teammate" edge to the Teammate entity.
func (m *WorkspaceActivityMutation) ClearTeammate() {
	m.clearedteammate = true
}

// TeammateCleared reports if the "teammate" edge to the Teammate entity was cleared.
func (m *WorkspaceActivityMutation) TeammateCleared() bool {
	return m.clearedteammate
}

// TeammateIDs returns the "teammate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeammateID instead. It exists only for internal usage by the builders.
func (m *WorkspaceActivityMutation) TeammateIDs() (ids []ulid.ID) {
	if id := m.teammate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeammate resets all changes to the "teammate" edge.
func (m *WorkspaceActivityMutation) ResetTeammate() {
	m.teammate = nil
	m.clearedteammate = false
}

// AddWorkspaceActivityTaskIDs adds the "workspaceActivityTasks" edge to the WorkspaceActivityTask entity by ids.
func (m *WorkspaceActivityMutation) AddWorkspaceActivityTaskIDs(ids ...ulid.ID) {
	if m.workspaceActivityTasks == nil {
		m.workspaceActivityTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		m.workspaceActivityTasks[ids[i]] = struct{}{}
	}
}

// ClearWorkspaceActivityTasks clears the "workspaceActivityTasks" edge to the WorkspaceActivityTask entity.
func (m *WorkspaceActivityMutation) ClearWorkspaceActivityTasks() {
	m.clearedworkspaceActivityTasks = true
}

// WorkspaceActivityTasksCleared reports if the "workspaceActivityTasks" edge to the WorkspaceActivityTask entity was cleared.
func (m *WorkspaceActivityMutation) WorkspaceActivityTasksCleared() bool {
	return m.clearedworkspaceActivityTasks
}

// RemoveWorkspaceActivityTaskIDs removes the "workspaceActivityTasks" edge to the WorkspaceActivityTask entity by IDs.
func (m *WorkspaceActivityMutation) RemoveWorkspaceActivityTaskIDs(ids ...ulid.ID) {
	if m.removedworkspaceActivityTasks == nil {
		m.removedworkspaceActivityTasks = make(map[ulid.ID]struct{})
	}
	for i := range ids {
		delete(m.workspaceActivityTasks, ids[i])
		m.removedworkspaceActivityTasks[ids[i]] = struct{}{}
	}
}

// RemovedWorkspaceActivityTasks returns the removed IDs of the "workspaceActivityTasks" edge to the WorkspaceActivityTask entity.
func (m *WorkspaceActivityMutation) RemovedWorkspaceActivityTasksIDs() (ids []ulid.ID) {
	for id := range m.removedworkspaceActivityTasks {
		ids = append(ids, id)
	}
	return
}

// WorkspaceActivityTasksIDs returns the "workspaceActivityTasks" edge IDs in the mutation.
func (m *WorkspaceActivityMutation) WorkspaceActivityTasksIDs() (ids []ulid.ID) {
	for id := range m.workspaceActivityTasks {
		ids = append(ids, id)
	}
	return
}

// ResetWorkspaceActivityTasks resets all changes to the "workspaceActivityTasks" edge.
func (m *WorkspaceActivityMutation) ResetWorkspaceActivityTasks() {
	m.workspaceActivityTasks = nil
	m.clearedworkspaceActivityTasks = false
	m.removedworkspaceActivityTasks = nil
}

// Where appends a list predicates to the WorkspaceActivityMutation builder.
func (m *WorkspaceActivityMutation) Where(ps ...predicate.WorkspaceActivity) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WorkspaceActivityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WorkspaceActivity).
func (m *WorkspaceActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkspaceActivityMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.activityType != nil {
		fields = append(fields, workspaceactivity.FieldActivityTypeID)
	}
	if m.workspace != nil {
		fields = append(fields, workspaceactivity.FieldWorkspaceID)
	}
	if m.project != nil {
		fields = append(fields, workspaceactivity.FieldProjectID)
	}
	if m.teammate != nil {
		fields = append(fields, workspaceactivity.FieldTeammateID)
	}
	if m.created_at != nil {
		fields = append(fields, workspaceactivity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workspaceactivity.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkspaceActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workspaceactivity.FieldActivityTypeID:
		return m.ActivityTypeID()
	case workspaceactivity.FieldWorkspaceID:
		return m.WorkspaceID()
	case workspaceactivity.FieldProjectID:
		return m.ProjectID()
	case workspaceactivity.FieldTeammateID:
		return m.TeammateID()
	case workspaceactivity.FieldCreatedAt:
		return m.CreatedAt()
	case workspaceactivity.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkspaceActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workspaceactivity.FieldActivityTypeID:
		return m.OldActivityTypeID(ctx)
	case workspaceactivity.FieldWorkspaceID:
		return m.OldWorkspaceID(ctx)
	case workspaceactivity.FieldProjectID:
		return m.OldProjectID(ctx)
	case workspaceactivity.FieldTeammateID:
		return m.OldTeammateID(ctx)
	case workspaceactivity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workspaceactivity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WorkspaceActivity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkspaceActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workspaceactivity.FieldActivityTypeID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityTypeID(v)
		return nil
	case workspaceactivity.FieldWorkspaceID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspaceID(v)
		return nil
	case workspaceactivity.FieldProjectID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case workspaceactivity.FieldTeammateID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeammateID(v)
		return nil
	case workspaceactivity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workspaceactivity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WorkspaceActivity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkspaceActivityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkspaceActivityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkspaceActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkspaceActivity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkspaceActivityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkspaceActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkspaceActivityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WorkspaceActivity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkspaceActivityMutation) ResetField(name string) error {
	switch name {
	case workspaceactivity.FieldActivityTypeID:
		m.ResetActivityTypeID()
		return nil
	case workspaceactivity.FieldWorkspaceID:
		m.ResetWorkspaceID()
		return nil
	case workspaceactivity.FieldProjectID:
		m.ResetProjectID()
		return nil
	case workspaceactivity.FieldTeammateID:
		m.ResetTeammateID()
		return nil
	case workspaceactivity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workspaceactivity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkspaceActivity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkspaceActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.activityType != nil {
		edges = append(edges, workspaceactivity.EdgeActivityType)
	}
	if m.workspace != nil {
		edges = append(edges, workspaceactivity.EdgeWorkspace)
	}
	if m.project != nil {
		edges = append(edges, workspaceactivity.EdgeProject)
	}
	if m.teammate != nil {
		edges = append(edges, workspaceactivity.EdgeTeammate)
	}
	if m.workspaceActivityTasks != nil {
		edges = append(edges, workspaceactivity.EdgeWorkspaceActivityTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkspaceActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workspaceactivity.EdgeActivityType:
		if id := m.activityType; id != nil {
			return []ent.Value{*id}
		}
	case workspaceactivity.EdgeWorkspace:
		if id := m.workspace; id != nil {
			return []ent.Value{*id}
		}
	case workspaceactivity.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case workspaceactivity.EdgeTeammate:
		if id := m.teammate; id != nil {
			return []ent.Value{*id}
		}
	case workspaceactivity.EdgeWorkspaceActivityTasks:
		ids := make([]ent.Value, 0, len(m.workspaceActivityTasks))
		for id := range m.workspaceActivityTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkspaceActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedworkspaceActivityTasks != nil {
		edges = append(edges, workspaceactivity.EdgeWorkspaceActivityTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkspaceActivityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workspaceactivity.EdgeWorkspaceActivityTasks:
		ids := make([]ent.Value, 0, len(m.removedworkspaceActivityTasks))
		for id := range m.removedworkspaceActivityTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkspaceActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedactivityType {
		edges = append(edges, workspaceactivity.EdgeActivityType)
	}
	if m.clearedworkspace {
		edges = append(edges, workspaceactivity.EdgeWorkspace)
	}
	if m.clearedproject {
		edges = append(edges, workspaceactivity.EdgeProject)
	}
	if m.clearedteammate {
		edges = append(edges, workspaceactivity.EdgeTeammate)
	}
	if m.clearedworkspaceActivityTasks {
		edges = append(edges, workspaceactivity.EdgeWorkspaceActivityTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkspaceActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case workspaceactivity.EdgeActivityType:
		return m.clearedactivityType
	case workspaceactivity.EdgeWorkspace:
		return m.clearedworkspace
	case workspaceactivity.EdgeProject:
		return m.clearedproject
	case workspaceactivity.EdgeTeammate:
		return m.clearedteammate
	case workspaceactivity.EdgeWorkspaceActivityTasks:
		return m.clearedworkspaceActivityTasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkspaceActivityMutation) ClearEdge(name string) error {
	switch name {
	case workspaceactivity.EdgeActivityType:
		m.ClearActivityType()
		return nil
	case workspaceactivity.EdgeWorkspace:
		m.ClearWorkspace()
		return nil
	case workspaceactivity.EdgeProject:
		m.ClearProject()
		return nil
	case workspaceactivity.EdgeTeammate:
		m.ClearTeammate()
		return nil
	}
	return fmt.Errorf("unknown WorkspaceActivity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkspaceActivityMutation) ResetEdge(name string) error {
	switch name {
	case workspaceactivity.EdgeActivityType:
		m.ResetActivityType()
		return nil
	case workspaceactivity.EdgeWorkspace:
		m.ResetWorkspace()
		return nil
	case workspaceactivity.EdgeProject:
		m.ResetProject()
		return nil
	case workspaceactivity.EdgeTeammate:
		m.ResetTeammate()
		return nil
	case workspaceactivity.EdgeWorkspaceActivityTasks:
		m.ResetWorkspaceActivityTasks()
		return nil
	}
	return fmt.Errorf("unknown WorkspaceActivity edge %s", name)
}

// WorkspaceActivityTaskMutation represents an operation that mutates the WorkspaceActivityTask nodes in the graph.
type WorkspaceActivityTaskMutation struct {
	config
	op                       Op
	typ                      string
	id                       *ulid.ID
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	task                     *ulid.ID
	clearedtask              bool
	workspaceActivity        *ulid.ID
	clearedworkspaceActivity bool
	done                     bool
	oldValue                 func(context.Context) (*WorkspaceActivityTask, error)
	predicates               []predicate.WorkspaceActivityTask
}

var _ ent.Mutation = (*WorkspaceActivityTaskMutation)(nil)

// workspaceactivitytaskOption allows management of the mutation configuration using functional options.
type workspaceactivitytaskOption func(*WorkspaceActivityTaskMutation)

// newWorkspaceActivityTaskMutation creates new mutation for the WorkspaceActivityTask entity.
func newWorkspaceActivityTaskMutation(c config, op Op, opts ...workspaceactivitytaskOption) *WorkspaceActivityTaskMutation {
	m := &WorkspaceActivityTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkspaceActivityTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkspaceActivityTaskID sets the ID field of the mutation.
func withWorkspaceActivityTaskID(id ulid.ID) workspaceactivitytaskOption {
	return func(m *WorkspaceActivityTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkspaceActivityTask
		)
		m.oldValue = func(ctx context.Context) (*WorkspaceActivityTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkspaceActivityTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkspaceActivityTask sets the old WorkspaceActivityTask of the mutation.
func withWorkspaceActivityTask(node *WorkspaceActivityTask) workspaceactivitytaskOption {
	return func(m *WorkspaceActivityTaskMutation) {
		m.oldValue = func(context.Context) (*WorkspaceActivityTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkspaceActivityTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkspaceActivityTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkspaceActivityTask entities.
func (m *WorkspaceActivityTaskMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkspaceActivityTaskMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkspaceActivityTaskMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkspaceActivityTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkspaceActivityID sets the "workspace_activity_id" field.
func (m *WorkspaceActivityTaskMutation) SetWorkspaceActivityID(u ulid.ID) {
	m.workspaceActivity = &u
}

// WorkspaceActivityID returns the value of the "workspace_activity_id" field in the mutation.
func (m *WorkspaceActivityTaskMutation) WorkspaceActivityID() (r ulid.ID, exists bool) {
	v := m.workspaceActivity
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspaceActivityID returns the old "workspace_activity_id" field's value of the WorkspaceActivityTask entity.
// If the WorkspaceActivityTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceActivityTaskMutation) OldWorkspaceActivityID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspaceActivityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspaceActivityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspaceActivityID: %w", err)
	}
	return oldValue.WorkspaceActivityID, nil
}

// ResetWorkspaceActivityID resets all changes to the "workspace_activity_id" field.
func (m *WorkspaceActivityTaskMutation) ResetWorkspaceActivityID() {
	m.workspaceActivity = nil
}

// SetTaskID sets the "task_id" field.
func (m *WorkspaceActivityTaskMutation) SetTaskID(u ulid.ID) {
	m.task = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *WorkspaceActivityTaskMutation) TaskID() (r ulid.ID, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the WorkspaceActivityTask entity.
// If the WorkspaceActivityTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceActivityTaskMutation) OldTaskID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *WorkspaceActivityTaskMutation) ResetTaskID() {
	m.task = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkspaceActivityTaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkspaceActivityTaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkspaceActivityTask entity.
// If the WorkspaceActivityTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceActivityTaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkspaceActivityTaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkspaceActivityTaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkspaceActivityTaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkspaceActivityTask entity.
// If the WorkspaceActivityTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceActivityTaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkspaceActivityTaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTask clears the "task" edge to the Task entity.
func (m *WorkspaceActivityTaskMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *WorkspaceActivityTaskMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *WorkspaceActivityTaskMutation) TaskIDs() (ids []ulid.ID) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *WorkspaceActivityTaskMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// ClearWorkspaceActivity clears the "workspaceActivity" edge to the WorkspaceActivity entity.
func (m *WorkspaceActivityTaskMutation) ClearWorkspaceActivity() {
	m.clearedworkspaceActivity = true
}

// WorkspaceActivityCleared reports if the "workspaceActivity" edge to the WorkspaceActivity entity was cleared.
func (m *WorkspaceActivityTaskMutation) WorkspaceActivityCleared() bool {
	return m.clearedworkspaceActivity
}

// WorkspaceActivityIDs returns the "workspaceActivity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkspaceActivityID instead. It exists only for internal usage by the builders.
func (m *WorkspaceActivityTaskMutation) WorkspaceActivityIDs() (ids []ulid.ID) {
	if id := m.workspaceActivity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkspaceActivity resets all changes to the "workspaceActivity" edge.
func (m *WorkspaceActivityTaskMutation) ResetWorkspaceActivity() {
	m.workspaceActivity = nil
	m.clearedworkspaceActivity = false
}

// Where appends a list predicates to the WorkspaceActivityTaskMutation builder.
func (m *WorkspaceActivityTaskMutation) Where(ps ...predicate.WorkspaceActivityTask) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WorkspaceActivityTaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WorkspaceActivityTask).
func (m *WorkspaceActivityTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkspaceActivityTaskMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.workspaceActivity != nil {
		fields = append(fields, workspaceactivitytask.FieldWorkspaceActivityID)
	}
	if m.task != nil {
		fields = append(fields, workspaceactivitytask.FieldTaskID)
	}
	if m.created_at != nil {
		fields = append(fields, workspaceactivitytask.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workspaceactivitytask.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkspaceActivityTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workspaceactivitytask.FieldWorkspaceActivityID:
		return m.WorkspaceActivityID()
	case workspaceactivitytask.FieldTaskID:
		return m.TaskID()
	case workspaceactivitytask.FieldCreatedAt:
		return m.CreatedAt()
	case workspaceactivitytask.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkspaceActivityTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workspaceactivitytask.FieldWorkspaceActivityID:
		return m.OldWorkspaceActivityID(ctx)
	case workspaceactivitytask.FieldTaskID:
		return m.OldTaskID(ctx)
	case workspaceactivitytask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workspaceactivitytask.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WorkspaceActivityTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkspaceActivityTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workspaceactivitytask.FieldWorkspaceActivityID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspaceActivityID(v)
		return nil
	case workspaceactivitytask.FieldTaskID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case workspaceactivitytask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workspaceactivitytask.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WorkspaceActivityTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkspaceActivityTaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkspaceActivityTaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkspaceActivityTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkspaceActivityTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkspaceActivityTaskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkspaceActivityTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkspaceActivityTaskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WorkspaceActivityTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkspaceActivityTaskMutation) ResetField(name string) error {
	switch name {
	case workspaceactivitytask.FieldWorkspaceActivityID:
		m.ResetWorkspaceActivityID()
		return nil
	case workspaceactivitytask.FieldTaskID:
		m.ResetTaskID()
		return nil
	case workspaceactivitytask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workspaceactivitytask.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkspaceActivityTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkspaceActivityTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.task != nil {
		edges = append(edges, workspaceactivitytask.EdgeTask)
	}
	if m.workspaceActivity != nil {
		edges = append(edges, workspaceactivitytask.EdgeWorkspaceActivity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkspaceActivityTaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workspaceactivitytask.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case workspaceactivitytask.EdgeWorkspaceActivity:
		if id := m.workspaceActivity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkspaceActivityTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkspaceActivityTaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkspaceActivityTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtask {
		edges = append(edges, workspaceactivitytask.EdgeTask)
	}
	if m.clearedworkspaceActivity {
		edges = append(edges, workspaceactivitytask.EdgeWorkspaceActivity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkspaceActivityTaskMutation) EdgeCleared(name string) bool {
	switch name {
	case workspaceactivitytask.EdgeTask:
		return m.clearedtask
	case workspaceactivitytask.EdgeWorkspaceActivity:
		return m.clearedworkspaceActivity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkspaceActivityTaskMutation) ClearEdge(name string) error {
	switch name {
	case workspaceactivitytask.EdgeTask:
		m.ClearTask()
		return nil
	case workspaceactivitytask.EdgeWorkspaceActivity:
		m.ClearWorkspaceActivity()
		return nil
	}
	return fmt.Errorf("unknown WorkspaceActivityTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkspaceActivityTaskMutation) ResetEdge(name string) error {
	switch name {
	case workspaceactivitytask.EdgeTask:
		m.ResetTask()
		return nil
	case workspaceactivitytask.EdgeWorkspaceActivity:
		m.ResetWorkspaceActivity()
		return nil
	}
	return fmt.Errorf("unknown WorkspaceActivityTask edge %s", name)
}

// WorkspaceTeammateMutation represents an operation that mutates the WorkspaceTeammate nodes in the graph.
type WorkspaceTeammateMutation struct {
	config
	op               Op
	typ              string
	id               *ulid.ID
	role             *string
	is_owner         *bool
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	workspace        *ulid.ID
	clearedworkspace bool
	teammate         *ulid.ID
	clearedteammate  bool
	done             bool
	oldValue         func(context.Context) (*WorkspaceTeammate, error)
	predicates       []predicate.WorkspaceTeammate
}

var _ ent.Mutation = (*WorkspaceTeammateMutation)(nil)

// workspaceteammateOption allows management of the mutation configuration using functional options.
type workspaceteammateOption func(*WorkspaceTeammateMutation)

// newWorkspaceTeammateMutation creates new mutation for the WorkspaceTeammate entity.
func newWorkspaceTeammateMutation(c config, op Op, opts ...workspaceteammateOption) *WorkspaceTeammateMutation {
	m := &WorkspaceTeammateMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkspaceTeammate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkspaceTeammateID sets the ID field of the mutation.
func withWorkspaceTeammateID(id ulid.ID) workspaceteammateOption {
	return func(m *WorkspaceTeammateMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkspaceTeammate
		)
		m.oldValue = func(ctx context.Context) (*WorkspaceTeammate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkspaceTeammate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkspaceTeammate sets the old WorkspaceTeammate of the mutation.
func withWorkspaceTeammate(node *WorkspaceTeammate) workspaceteammateOption {
	return func(m *WorkspaceTeammateMutation) {
		m.oldValue = func(context.Context) (*WorkspaceTeammate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkspaceTeammateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkspaceTeammateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkspaceTeammate entities.
func (m *WorkspaceTeammateMutation) SetID(id ulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkspaceTeammateMutation) ID() (id ulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkspaceTeammateMutation) IDs(ctx context.Context) ([]ulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkspaceTeammate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkspaceID sets the "workspace_id" field.
func (m *WorkspaceTeammateMutation) SetWorkspaceID(u ulid.ID) {
	m.workspace = &u
}

// WorkspaceID returns the value of the "workspace_id" field in the mutation.
func (m *WorkspaceTeammateMutation) WorkspaceID() (r ulid.ID, exists bool) {
	v := m.workspace
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspaceID returns the old "workspace_id" field's value of the WorkspaceTeammate entity.
// If the WorkspaceTeammate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceTeammateMutation) OldWorkspaceID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspaceID: %w", err)
	}
	return oldValue.WorkspaceID, nil
}

// ResetWorkspaceID resets all changes to the "workspace_id" field.
func (m *WorkspaceTeammateMutation) ResetWorkspaceID() {
	m.workspace = nil
}

// SetTeammateID sets the "teammate_id" field.
func (m *WorkspaceTeammateMutation) SetTeammateID(u ulid.ID) {
	m.teammate = &u
}

// TeammateID returns the value of the "teammate_id" field in the mutation.
func (m *WorkspaceTeammateMutation) TeammateID() (r ulid.ID, exists bool) {
	v := m.teammate
	if v == nil {
		return
	}
	return *v, true
}

// OldTeammateID returns the old "teammate_id" field's value of the WorkspaceTeammate entity.
// If the WorkspaceTeammate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceTeammateMutation) OldTeammateID(ctx context.Context) (v ulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeammateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeammateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeammateID: %w", err)
	}
	return oldValue.TeammateID, nil
}

// ResetTeammateID resets all changes to the "teammate_id" field.
func (m *WorkspaceTeammateMutation) ResetTeammateID() {
	m.teammate = nil
}

// SetRole sets the "role" field.
func (m *WorkspaceTeammateMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *WorkspaceTeammateMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the WorkspaceTeammate entity.
// If the WorkspaceTeammate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceTeammateMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *WorkspaceTeammateMutation) ResetRole() {
	m.role = nil
}

// SetIsOwner sets the "is_owner" field.
func (m *WorkspaceTeammateMutation) SetIsOwner(b bool) {
	m.is_owner = &b
}

// IsOwner returns the value of the "is_owner" field in the mutation.
func (m *WorkspaceTeammateMutation) IsOwner() (r bool, exists bool) {
	v := m.is_owner
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOwner returns the old "is_owner" field's value of the WorkspaceTeammate entity.
// If the WorkspaceTeammate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceTeammateMutation) OldIsOwner(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOwner: %w", err)
	}
	return oldValue.IsOwner, nil
}

// ResetIsOwner resets all changes to the "is_owner" field.
func (m *WorkspaceTeammateMutation) ResetIsOwner() {
	m.is_owner = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkspaceTeammateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkspaceTeammateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkspaceTeammate entity.
// If the WorkspaceTeammate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceTeammateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkspaceTeammateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkspaceTeammateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkspaceTeammateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkspaceTeammate entity.
// If the WorkspaceTeammate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceTeammateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkspaceTeammateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearWorkspace clears the "workspace" edge to the Workspace entity.
func (m *WorkspaceTeammateMutation) ClearWorkspace() {
	m.clearedworkspace = true
}

// WorkspaceCleared reports if the "workspace" edge to the Workspace entity was cleared.
func (m *WorkspaceTeammateMutation) WorkspaceCleared() bool {
	return m.clearedworkspace
}

// WorkspaceIDs returns the "workspace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkspaceID instead. It exists only for internal usage by the builders.
func (m *WorkspaceTeammateMutation) WorkspaceIDs() (ids []ulid.ID) {
	if id := m.workspace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkspace resets all changes to the "workspace" edge.
func (m *WorkspaceTeammateMutation) ResetWorkspace() {
	m.workspace = nil
	m.clearedworkspace = false
}

// ClearTeammate clears the "teammate" edge to the Teammate entity.
func (m *WorkspaceTeammateMutation) ClearTeammate() {
	m.clearedteammate = true
}

// TeammateCleared reports if the "teammate" edge to the Teammate entity was cleared.
func (m *WorkspaceTeammateMutation) TeammateCleared() bool {
	return m.clearedteammate
}

// TeammateIDs returns the "teammate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeammateID instead. It exists only for internal usage by the builders.
func (m *WorkspaceTeammateMutation) TeammateIDs() (ids []ulid.ID) {
	if id := m.teammate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeammate resets all changes to the "teammate" edge.
func (m *WorkspaceTeammateMutation) ResetTeammate() {
	m.teammate = nil
	m.clearedteammate = false
}

// Where appends a list predicates to the WorkspaceTeammateMutation builder.
func (m *WorkspaceTeammateMutation) Where(ps ...predicate.WorkspaceTeammate) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WorkspaceTeammateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WorkspaceTeammate).
func (m *WorkspaceTeammateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkspaceTeammateMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.workspace != nil {
		fields = append(fields, workspaceteammate.FieldWorkspaceID)
	}
	if m.teammate != nil {
		fields = append(fields, workspaceteammate.FieldTeammateID)
	}
	if m.role != nil {
		fields = append(fields, workspaceteammate.FieldRole)
	}
	if m.is_owner != nil {
		fields = append(fields, workspaceteammate.FieldIsOwner)
	}
	if m.created_at != nil {
		fields = append(fields, workspaceteammate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workspaceteammate.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkspaceTeammateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workspaceteammate.FieldWorkspaceID:
		return m.WorkspaceID()
	case workspaceteammate.FieldTeammateID:
		return m.TeammateID()
	case workspaceteammate.FieldRole:
		return m.Role()
	case workspaceteammate.FieldIsOwner:
		return m.IsOwner()
	case workspaceteammate.FieldCreatedAt:
		return m.CreatedAt()
	case workspaceteammate.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkspaceTeammateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workspaceteammate.FieldWorkspaceID:
		return m.OldWorkspaceID(ctx)
	case workspaceteammate.FieldTeammateID:
		return m.OldTeammateID(ctx)
	case workspaceteammate.FieldRole:
		return m.OldRole(ctx)
	case workspaceteammate.FieldIsOwner:
		return m.OldIsOwner(ctx)
	case workspaceteammate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workspaceteammate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WorkspaceTeammate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkspaceTeammateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workspaceteammate.FieldWorkspaceID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspaceID(v)
		return nil
	case workspaceteammate.FieldTeammateID:
		v, ok := value.(ulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeammateID(v)
		return nil
	case workspaceteammate.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case workspaceteammate.FieldIsOwner:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOwner(v)
		return nil
	case workspaceteammate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workspaceteammate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WorkspaceTeammate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkspaceTeammateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkspaceTeammateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkspaceTeammateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkspaceTeammate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkspaceTeammateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkspaceTeammateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkspaceTeammateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WorkspaceTeammate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkspaceTeammateMutation) ResetField(name string) error {
	switch name {
	case workspaceteammate.FieldWorkspaceID:
		m.ResetWorkspaceID()
		return nil
	case workspaceteammate.FieldTeammateID:
		m.ResetTeammateID()
		return nil
	case workspaceteammate.FieldRole:
		m.ResetRole()
		return nil
	case workspaceteammate.FieldIsOwner:
		m.ResetIsOwner()
		return nil
	case workspaceteammate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workspaceteammate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkspaceTeammate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkspaceTeammateMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.workspace != nil {
		edges = append(edges, workspaceteammate.EdgeWorkspace)
	}
	if m.teammate != nil {
		edges = append(edges, workspaceteammate.EdgeTeammate)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkspaceTeammateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workspaceteammate.EdgeWorkspace:
		if id := m.workspace; id != nil {
			return []ent.Value{*id}
		}
	case workspaceteammate.EdgeTeammate:
		if id := m.teammate; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkspaceTeammateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkspaceTeammateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkspaceTeammateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedworkspace {
		edges = append(edges, workspaceteammate.EdgeWorkspace)
	}
	if m.clearedteammate {
		edges = append(edges, workspaceteammate.EdgeTeammate)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkspaceTeammateMutation) EdgeCleared(name string) bool {
	switch name {
	case workspaceteammate.EdgeWorkspace:
		return m.clearedworkspace
	case workspaceteammate.EdgeTeammate:
		return m.clearedteammate
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkspaceTeammateMutation) ClearEdge(name string) error {
	switch name {
	case workspaceteammate.EdgeWorkspace:
		m.ClearWorkspace()
		return nil
	case workspaceteammate.EdgeTeammate:
		m.ClearTeammate()
		return nil
	}
	return fmt.Errorf("unknown WorkspaceTeammate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkspaceTeammateMutation) ResetEdge(name string) error {
	switch name {
	case workspaceteammate.EdgeWorkspace:
		m.ResetWorkspace()
		return nil
	case workspaceteammate.EdgeTeammate:
		m.ResetTeammate()
		return nil
	}
	return fmt.Errorf("unknown WorkspaceTeammate edge %s", name)
}
